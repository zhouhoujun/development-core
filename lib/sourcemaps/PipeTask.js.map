{"version":3,"sources":["PipeTask.js","PipeTask.ts"],"names":["TaskConfig_1","require","utils_1","coregulp","chalk","_","PipeTask","info","runWay","RunWay","parallel","operateFileds","name","ctx","dist","gulp","option","source","isFunction","loader","src","getSrc","getInfo","pipes","filter","p","opps","length","concat","isString","isArray","output","stream","pipe","dest","getDist","cfgopt","prsrc","oper","getTransformOperate","cpipe2Promise","then","setTransformOperate","context","trsOperate","isOutput","endsWith","toStr","noneOutput","nonePipe","opt","Promise","resolve","reject","ps","err","pick","operate","each","isUndefined","n","subTaskName","all","map","match","toTransform","trs","order","tans","sortOrder","tanseq","it","transformSourcePipe","transformPipe","outputs","once","removeAllListeners","result","customPipe","psrc","pipes2Promise","output2Promise","catch","console","log","red","process","exit","getOption","working","st","sequence","pthen","tk","cyan","task","execute","taskName","exports"],"mappings":"AAAA;;;;;;;;ACCA,IAAAA,eAAAC,QAAmK,cAAnK,CAAA;AACA,IAAAC,UAAAD,QAA0B,SAA1B,CAAA;AACA,IAAYE,WAAQF,QAAM,MAAN,CAApB;AACA,IAAYG,QAAKH,QAAM,OAAN,CAAjB;AACA,IAAYI,IAACJ,QAAM,QAAN,CAAb;AA6DA;;;;;;;;IAOAK,Q;AAiBI,sBAAYC,IAAZ,EAA4B;AAAA;;AAhB5B;;;;;;AAMO,aAAAC,MAAA,GAASR,aAAAS,MAAA,CAAOC,QAAhB;AAoPG,aAAAC,aAAA,GAAgB,CAAC,MAAD,EAAS,MAAT,EAAiB,OAAjB,EAA0B,UAA1B,EAAsC,YAAtC,CAAhB;AAzON,aAAKJ,IAAL,GAAYA,QAAQ,EAApB;AACA,aAAKA,IAAL,CAAUK,IAAV,GAAiB,KAAKL,IAAL,CAAUK,IAAV,IAAkB,KAAKA,IAAxC;AACH;AAID;;;;;;;;;;kCAMc;AACV,gBAAI,CAAC,KAAKL,IAAL,CAAUK,IAAf,EAAqB;AACjB,qBAAKL,IAAL,CAAUK,IAAV,GAAiB,KAAKA,IAAtB;AACH;AACD,mBAAO,KAAKL,IAAZ;AACH;AAED;;;;;;;;;;;;;+BAUOM,G,EAAmBC,I,EAAmBC,I,EAAU;AACnD,gBAAIC,SAASH,IAAIG,MAAjB;AACA,gBAAIA,OAAOC,MAAX,EAAmB;AACf,uBAAOZ,EAAEa,UAAF,CAAaF,OAAOC,MAApB,IAA8BD,OAAOC,MAAP,CAAcJ,GAAd,EAAmBC,IAAnB,EAAyBC,IAAzB,CAA9B,GAA+DC,OAAOC,MAA7E;AACH;AACD,gBAAIE,SAAsBH,OAAO,QAAP,CAA1B;AACA,gBAAIG,UAAUH,OAAOC,MAArB,EAA6B;AACzB,uBAAOZ,EAAEa,UAAF,CAAaC,OAAOF,MAApB,IAA8BE,OAAOF,MAAP,CAAcJ,GAAd,EAAmBC,IAAnB,EAAyBC,IAAzB,CAA9B,GAA+DI,OAAOF,MAA7E;AACH;AACD,mBAAOF,KAAKK,GAAL,CAASP,IAAIQ,MAAJ,CAAW,KAAKC,OAAL,EAAX,CAAT,CAAP;AACH;AAID;;;;;;;;;;;;;8BAUMT,G,EAAmBC,I,EAAmBC,I,EAAW;AACnD,gBAAIC,SAASH,IAAIG,MAAjB;AACA,gBAAIO,QAAgB,IAApB;AACA,gBAAIJ,SAAsBH,OAAO,QAAP,CAA1B;AACA,gBAAIG,UAAUd,EAAEa,UAAF,CAAaC,OAAOI,KAApB,CAAd,EAA0C;AACtCA,wBAAQlB,EAAEa,UAAF,CAAaC,OAAOI,KAApB,IAA6BJ,OAAOI,KAAP,CAAaV,GAAb,EAAkBG,MAAlB,EAA0BD,IAA1B,CAA7B,GAA+DV,EAAEmB,MAAF,CAAiBL,OAAOI,KAAxB,EAA+B;AAAA,2BAAKlB,EAAEa,UAAF,CAAaO,CAAb,KAAoBA,EAAEb,IAAF,IAAUa,EAAEb,IAAF,KAAWE,KAAKF,IAAnD;AAAA,iBAA/B,CAAvE;AACH;AAED,gBAAII,OAAOO,KAAX,EAAkB;AACd,oBAAIG,OAAOrB,EAAEa,UAAF,CAAaF,OAAOO,KAApB,IAA6BP,OAAOO,KAAP,CAAaV,GAAb,EAAkBG,MAAlB,EAA0BD,IAA1B,CAA7B,GAA+DV,EAAEmB,MAAF,CAAiBR,OAAOO,KAAxB,EAA+B;AAAA,2BAAKlB,EAAEa,UAAF,CAAaO,CAAb,KAAoBA,EAAEb,IAAF,IAAUa,EAAEb,IAAF,KAAWE,KAAKF,IAAnD;AAAA,iBAA/B,CAA1E;AACA,oBAAIc,QAAQA,KAAKC,MAAL,GAAc,CAA1B,EAA6B;AACzBJ,4BAAQA,QAAQA,MAAMK,MAAN,CAAaF,IAAb,CAAR,GAA6BA,IAArC;AACH;AACJ;AACD,mBAAOH,SAAS,EAAhB;AACH;AAED;;;;;;;;;;;;;+BAUOV,G,EAAmBC,I,EAAmBC,I,EAAW;AACpD,gBAAIC,SAASH,IAAIG,MAAjB;AACA,gBAAIO,QAAsB,IAA1B;AACA,gBAAIJ,SAAsBH,OAAO,QAAP,CAA1B;AACA,gBAAIG,UAAU,CAACd,EAAEwB,QAAF,CAAWV,MAAX,CAAX,IAAiC,CAACd,EAAEyB,OAAF,CAAUX,MAAV,CAAtC,EAAyD;AACrD,oBAAIA,OAAOY,MAAX,EAAmB;AACfR,4BAAQlB,EAAEa,UAAF,CAAaC,OAAOY,MAApB,IAA8BZ,OAAOY,MAAP,CAAclB,GAAd,EAAmBG,MAAnB,EAA2BD,IAA3B,CAA9B,GAAiEV,EAAEmB,MAAF,CAAuBL,OAAOI,KAA9B,EAAqC;AAAA,+BAAKlB,EAAEa,UAAF,CAAaO,CAAb,KAAoBA,EAAEb,IAAF,IAAUa,EAAEb,IAAF,KAAWE,KAAKF,IAAnD;AAAA,qBAArC,CAAzE;AACH,iBAFD,MAEO,IAAIO,OAAOY,MAAP,KAAkB,IAAtB,EAA4B;AAC/B,2BAAO,CAAC,UAACC,MAAD;AAAA,+BAAYA,MAAZ;AAAA,qBAAD,CAAP;AACH;AACJ;AACD,gBAAIhB,OAAOe,MAAX,EAAmB;AACf,oBAAIL,OAAOrB,EAAEa,UAAF,CAAaF,OAAOe,MAApB,IAA8Bf,OAAOe,MAAP,CAAclB,GAAd,EAAmBG,MAAnB,EAA2BD,IAA3B,CAA9B,GAAiEV,EAAEmB,MAAF,CAAuBR,OAAOe,MAA9B,EAAsC;AAAA,2BAAK1B,EAAEa,UAAF,CAAaO,CAAb,KAAoBA,EAAEb,IAAF,IAAUa,EAAEb,IAAF,KAAWE,KAAKF,IAAnD;AAAA,iBAAtC,CAA5E;AACA,oBAAIc,QAAQA,KAAKC,MAAL,GAAc,CAA1B,EAA6B;AACzBJ,4BAAQA,QAAQA,MAAMK,MAAN,CAAaF,IAAb,CAAR,GAA6BA,IAArC;AACH;AACJ,aALD,MAKO,IAAIV,OAAOe,MAAP,KAAkB,IAAtB,EAA4B;AAC/B,uBAAO,CAAC,UAACC,MAAD;AAAA,2BAAYA,MAAZ;AAAA,iBAAD,CAAP;AACH;AAED,mBAAOT,SAAS,CAAC,UAACS,MAAD;AAAA,uBAAYA,OAAOC,IAAP,CAAYlB,KAAKmB,IAAL,CAAUrB,IAAIsB,OAAJ,CAAYrB,IAAZ,CAAV,CAAZ,CAAZ;AAAA,aAAD,CAAhB;AACH;AAED;;;;;;;;;;;;;;;mCAYqBG,M,EAAoBJ,G,EAAmBC,I,EAAmBC,I,EAAU;AAAA;;AACrF,gBAAIqB,SAASvB,IAAIG,MAAjB;AACA,gBAAIG,SAAsBiB,OAAO,QAAP,CAA1B;AACA,gBAAIC,cAAJ;AACA,gBAAIC,OAAO,KAAKC,mBAAL,CAAyBtB,MAAzB,CAAX;AACA,gBAAImB,OAAOH,IAAX,EAAiB;AACbI,wBAAQ,KAAKG,aAAL,CAAmBvB,MAAnB,EAA2BmB,MAA3B,EAAmCvB,GAAnC,EAAwCC,IAAxC,EAA8CC,IAA9C,CAAR;AACH;AACD,gBAAII,UAAU,CAACd,EAAEwB,QAAF,CAAWV,MAAX,CAAX,IAAiC,CAACd,EAAEyB,OAAF,CAAUX,MAAV,CAAlC,IAAuDA,OAAOc,IAAlE,EAAwE;AACpEI,wBAAQA,QACJA,MAAMI,IAAN,CAAW,kBAAM;AACb,0BAAKC,mBAAL,CAAyBV,MAAzB,EAAiCM,IAAjC;AACA,2BAAO,MAAKE,aAAL,CAAmBR,MAAnB,EAA2Bb,MAA3B,EAAmCN,GAAnC,EAAwCC,IAAxC,EAA8CC,IAA9C,CAAP;AACH,iBAHD,CADI,GAKF,KAAKyB,aAAL,CAAmBvB,MAAnB,EAA2BE,MAA3B,EAAmCN,GAAnC,EAAwCC,IAAxC,EAA8CC,IAA9C,CALN;AAMH;AAED,gBAAIsB,KAAJ,EAAW;AACP,uBAAOA,MAAMI,IAAN,CAAW,kBAAM;AACpB,0BAAKC,mBAAL,CAAyBV,MAAzB,EAAiCM,IAAjC;AACA,2BAAON,MAAP;AACH,iBAHM,CAAP;AAIH;AAED,mBAAOf,MAAP;AACH;AAED;;;;;;;;;;;;kCASoB0B,O,EAAqB;AACrC,mBAAOA,QAAQ3B,MAAf;AACH;AAED;;;;;;;;;;;;;;;;8BAagBS,C,EAAab,I,EAAcC,G,EAAmB+B,U,EAAuC;AAAA,gBAAhBC,QAAgB,uEAAL,KAAK;;AACjG,gBAAI,CAACpB,CAAL,EAAQ;AACJ,uBAAO,KAAP;AACH;AACD,gBAAIA,EAAEb,IAAF,IAAU,CAACA,KAAKkC,QAAL,CAAcjC,IAAIkC,KAAJ,CAAUtB,EAAEb,IAAZ,CAAd,CAAf,EAAiD;AAC7C,uBAAO,KAAP;AACH;AAED,gBAAIa,EAAEa,IAAF,IAAU,CAACb,EAAEa,IAAF,GAASzB,IAAIyB,IAAd,KAAuB,CAArC,EAAwC;AACpC,uBAAO,KAAP;AACH;AAED,gBAAIO,YAAYpB,EAAEuB,UAAlB,EAA8B;AAC1B,uBAAO,KAAP;AACH,aAFD,MAEO,IAAI,CAACH,QAAD,IAAapB,EAAEwB,QAAnB,EAA6B;AAChC,uBAAO,KAAP;AACH;AAED,gBAAIL,UAAJ,EAAgB;AACZ,oBAAIA,WAAWhC,IAAX,IAAmB,CAACA,KAAKkC,QAAL,CAAcjC,IAAIkC,KAAJ,CAAUH,WAAWhC,IAArB,CAAd,CAAxB,EAAmE;AAC/D,2BAAO,KAAP;AACH;AACD,oBAAIgC,WAAWN,IAAX,IAAmB,CAACM,WAAWN,IAAX,GAAkBzB,IAAIyB,IAAvB,KAAgC,CAAvD,EAA0D;AACtD,2BAAO,KAAP;AACH;AAED,oBAAIO,YAAYD,WAAWI,UAA3B,EAAuC;AACnC,2BAAO,KAAP;AACH,iBAFD,MAEO,IAAI,CAACH,QAAD,IAAaD,WAAWK,QAA5B,EAAsC;AACzC,2BAAO,KAAP;AACH;AACJ;AAED,mBAAO,IAAP;AACH;AAED;;;;;;;;;;;;;;;;sCAawBhC,M,EAAoBiC,G,EAAkBP,O,EAAuB7B,I,EAAmBC,I,EAAU;AAC9G,mBAAO,IAAIoC,OAAJ,CAAwB,UAACC,OAAD,EAAUC,MAAV,EAAgB;AAC3C,oBAAIC,KAAKJ,IAAIjB,IAAJ,CAAShB,MAAT,EAAiB0B,OAAjB,EAA0B7B,IAA1B,EAAgCC,IAAhC,EAAsC,UAACwC,GAAD,EAAI;AAC/C,wBAAIA,GAAJ,EAAS;AACLF,+BAAOE,GAAP;AACH,qBAFD,MAEO;AACHH;AACH;AACJ,iBANQ,CAAT;AAOA,oBAAIE,EAAJ,EAAQ;AACJH,4BAAQC,OAAR,CAAgBE,EAAhB,EAAoBb,IAApB,CAAyBW,OAAzB,EAAkCC,MAAlC;AACH;AACJ,aAXM,CAAP;AAYH;AAID;;;;;;;;;;;;4CAS8BpC,M,EAAkB;AAC5C,mBAAOZ,EAAEmD,IAAF,CAAOvC,MAAP,EAAe,KAAKN,aAApB,CAAP;AACH;AAED;;;;;;;;;;;;;4CAU8BM,M,EAAoBwC,O,EAAiB;AAC/D,gBAAI,CAACxC,MAAL,EAAa;AACT;AACH;AACDZ,cAAEqD,IAAF,CAAO,KAAK/C,aAAZ,EAA2B,aAAC;AACxB,oBAAI,CAACN,EAAEsD,WAAF,CAAcF,QAAQG,CAAR,CAAd,CAAL,EAAgC;AAC5B3C,2BAAO2C,CAAP,IAAYH,QAAQG,CAAR,CAAZ;AACH;AACJ,aAJD;AAKH;AAED;;;;;;;;;;;;;;;;sCAawB3C,M,EAAoBJ,G,EAAmBC,I,EAAmBC,I,EAAYQ,K,EAAc;AAAA;;AACxG,gBAAIX,OAAOC,IAAIgD,WAAJ,CAAgB/C,IAAhB,EAAsB,KAAKF,IAA3B,CAAX;AACA,gBAAI0B,OAAO,KAAKC,mBAAL,CAAyBtB,MAAzB,CAAX;AACA,mBAAOkC,QAAQW,GAAR,CAAYzD,EAAE0D,GAAF,CAAMxC,SAAS,KAAKA,KAAL,CAAWV,GAAX,EAAgBC,IAAhB,EAAsBC,IAAtB,CAAf,EAA4C,UAACU,CAAD,EAAQ;AACnE,oBAAIpB,EAAEa,UAAF,CAAaO,CAAb,CAAJ,EAAqB;AACjB,2BAAOA,EAAEZ,GAAF,EAAOC,IAAP,EAAaC,IAAb,CAAP;AACH,iBAFD,MAEO;AACH,wBAAI,CAAC,OAAKiD,KAAL,CAAWvC,CAAX,EAAcb,IAAd,EAAoBC,GAApB,EAAyByB,IAAzB,CAAL,EAAqC;AACjC,+BAAO,IAAP;AACH,qBAFD,MAEO;AACH,+BAAOa,QAAQC,OAAR,CAAgB3B,EAAEwC,WAAF,CAAcpD,GAAd,EAAmBC,IAAnB,EAAyBC,IAAzB,CAAhB,EACF0B,IADE,CACG,eAAG;AACLyB,gCAAIC,KAAJ,GAAY1C,EAAE0C,KAAd;AACA,mCAAOD,GAAP;AACH,yBAJE,CAAP;AAKH;AACJ;AACJ,aAdkB,CAAZ,EAeFzB,IAfE,CAeG,kBAAM;AAER,oBAAI2B,OAAOlE,QAAAmE,SAAA,CAAsBC,MAAtB,EAA8B;AAAA,2BAAMC,GAAGJ,KAAT;AAAA,iBAA9B,EAA8CtD,GAA9C,EAAmD,IAAnD,CAAX;AAEAR,kBAAEqD,IAAF,CAAOU,IAAP,EAAa,UAACpC,MAAD,EAAmB;AAC5B,wBAAI,CAAC,OAAKgC,KAAL,CAAWhC,MAAX,EAAmBpB,IAAnB,EAAyBC,GAAzB,EAA8ByB,IAA9B,CAAL,EAA0C;AACtC;AACH;AAED,wBAAIjC,EAAEa,UAAF,CAAac,OAAOwC,mBAApB,CAAJ,EAA8C;AAC1CvD,iCAASe,OAAOwC,mBAAP,CAA2BvD,MAA3B,CAAT;AACH,qBAFD,MAEO,IAAIZ,EAAEa,UAAF,CAAaD,OAAOwD,aAApB,CAAJ,EAAwC;AAC3CxD,iCAASA,OAAOwD,aAAP,CAAqBzC,MAArB,CAAT;AACH,qBAFM,MAEA;AACHf,iCAASA,OAAOgB,IAAP,CAAYD,MAAZ,CAAT;AACH;AACJ,iBAZD;AAaA,uBAAKU,mBAAL,CAAyBzB,MAAzB,EAAiCqB,IAAjC;AACA,uBAAOrB,MAAP;AACH,aAlCE,CAAP;AAmCH;AAED;;;;;;;;;;;;;;;;uCAayBA,M,EAAoB0B,O,EAAuB7B,I,EAAmBC,I,EAAYgB,M,EAAqB;AAAA;;AACpH,gBAAInB,OAAO+B,QAAQkB,WAAR,CAAoB/C,IAApB,EAA0B,KAAKF,IAA/B,CAAX;AACA,gBAAI0B,OAAO,KAAKC,mBAAL,CAAyBtB,MAAzB,CAAX;AACA,gBAAIyD,UAAU3C,UAAU,KAAKA,MAAL,CAAYY,OAAZ,EAAqB7B,IAArB,EAA2BC,IAA3B,CAAxB;AACA,mBAAOoC,QAAQW,GAAR,CAAYzD,EAAE0D,GAAF,CAAMW,OAAN,EAAe,kBAAM;AACpC,oBAAIrE,EAAEa,UAAF,CAAaa,MAAb,CAAJ,EAA0B;AACtB,2BAAOA,OAAOd,MAAP,EAAe0B,OAAf,EAAwB7B,IAAxB,EAA8BC,IAA9B,CAAP;AACH,iBAFD,MAEO;AACH,wBAAI,CAAC,OAAKiD,KAAL,CAAWjC,MAAX,EAAmBnB,IAAnB,EAAyB+B,OAAzB,EAAkCL,IAAlC,EAAwC,IAAxC,CAAL,EAAoD;AAChD,+BAAO,IAAP;AACH,qBAFD,MAEO;AACH,+BAAOP,OAAOkC,WAAP,CAAmBhD,MAAnB,EAA2B0B,OAA3B,EAAoC7B,IAApC,EAA0CC,IAA1C,CAAP;AACH;AACJ;AACJ,aAVkB,CAAZ,EAWF0B,IAXE,CAWG,mBAAO;AACT,uBAAOU,QAAQW,GAAR,CAAYzD,EAAE0D,GAAF,CAAMW,OAAN,EAAe,kBAAM;AACpC,2BAAO,IAAIvB,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAgB;AAC/B,4BAAItB,MAAJ,EAAY;AACRA,mCACK4C,IADL,CACU,KADV,EACiB,YAAA;AACTvB,wCAAQrB,MAAR;AACH,6BAHL,EAIK4C,IAJL,CAIU,OAJV,EAImBtB,MAJnB;AAKH,yBAND,MAMO;AACHD;AACH;AACJ,qBAVM,EAUJX,IAVI,CAUC,kBAAM;AACVV,+BAAO6C,kBAAP,CAA0B,OAA1B;AACA7C,+BAAO6C,kBAAP,CAA0B,KAA1B;AACA,+BAAOC,MAAP;AACH,qBAdM,CAAP;AAeH,iBAhBkB,CAAZ,CAAP;AAiBH,aA7BE,CAAP;AA8BH;AAED;;;;;;;;;;;;;;;;;gCAckB5D,M,EAAoBJ,G,EAAmBG,M,EAAqBD,I,EAAYQ,K,EAAgBQ,M,EAAqB;AAAA;;AAC3H,mBAAOoB,QAAQC,OAAR,CAAgBnC,MAAhB,EACFwB,IADE,CACG;AAAA,uBAAQ,OAAKqC,UAAL,CAAgBC,IAAhB,EAAsBlE,GAAtB,EAA2BG,MAA3B,EAAmCD,IAAnC,CAAR;AAAA,aADH,EAEF0B,IAFE,CAEG;AAAA,uBAAQ,OAAKuC,aAAL,CAAmBD,IAAnB,EAAyBlE,GAAzB,EAA8BG,MAA9B,EAAsCD,IAAtC,EAA4CQ,KAA5C,CAAR;AAAA,aAFH,EAGFkB,IAHE,CAGG;AAAA,uBAAQ,OAAKwC,cAAL,CAAoBF,IAApB,EAA0BlE,GAA1B,EAA+BG,MAA/B,EAAuCD,IAAvC,EAA6CgB,MAA7C,CAAR;AAAA,aAHH,EAIFmD,KAJE,CAII,eAAG;AACNC,wBAAQC,GAAR,CAAYhF,MAAMiF,GAAN,CAAU9B,GAAV,CAAZ;AACA+B,wBAAQC,IAAR,CAAa,CAAb;AACH,aAPE,CAAP;AAQH;AAED;;;;;;;;;;;;gCASQ5C,O,EAAuB5B,I,EAAU;AAAA;;AACrC,gBAAIC,SAAS,KAAKwE,SAAL,CAAe7C,OAAf,CAAb;AACA,mBAAOQ,QAAQC,OAAR,CAAgB,KAAKnC,MAAL,CAAY0B,OAAZ,EAAqB3B,MAArB,EAA6BD,IAA7B,CAAhB,EACF0B,IADE,CACG,kBAAM;AACR,oBAAIpC,EAAEyB,OAAF,CAAUE,MAAV,CAAJ,EAAuB;AACnB,wBAAI,OAAKxB,MAAL,KAAgBR,aAAAS,MAAA,CAAOC,QAA3B,EAAqC;AACjC,+BAAOyC,QAAQW,GAAR,CAAYzD,EAAE0D,GAAF,CAAM/B,MAAN,EAAc;AAAA,mCAAM,OAAKyD,OAAL,CAAaC,EAAb,EAAiB/C,OAAjB,EAA0B3B,MAA1B,EAAkCD,IAAlC,CAAN;AAAA,yBAAd,CAAZ,CAAP;AACH,qBAFD,MAEO,IAAI,OAAKP,MAAL,KAAgBR,aAAAS,MAAA,CAAOkF,QAA3B,EAAqC;AAAA;AACxC,gCAAIC,cAAJ;AACAvF,8BAAEqD,IAAF,CAAO1B,MAAP,EAAe,cAAE;AACb,oCAAI,CAAC4D,KAAL,EAAY;AACRA,4CAAQ,OAAKH,OAAL,CAAaC,EAAb,EAAiB/C,OAAjB,EAA0B3B,MAA1B,EAAkCD,IAAlC,CAAR;AACH,iCAFD,MAEO;AACH6E,4CAAQA,MAAMnD,IAAN,CAAW,YAAA;AACf,+CAAO,OAAKgD,OAAL,CAAaC,EAAb,EAAiB/C,OAAjB,EAA0B3B,MAA1B,EAAkCD,IAAlC,CAAP;AACH,qCAFO,CAAR;AAGH;AACJ,6BARD;AASA;AAAA,mCAAO6E;AAAP;AAXwC;;AAAA;AAY3C,qBAZM,MAYA;AACH,+BAAOzC,QAAQE,MAAR,CAAe,uBAAf,CAAP;AACH;AACJ,iBAlBD,MAkBO;AACH,2BAAO,OAAKoC,OAAL,CAAazD,MAAb,EAAqBW,OAArB,EAA8B3B,MAA9B,EAAsCD,IAAtC,CAAP;AACH;AACJ,aAvBE,CAAP;AAwBH;AAED;;;;;;;;;;;;8BASM4B,O,EAAuB5B,I,EAAW;AAAA;;AACpCA,mBAAOA,QAAQZ,QAAf;AACA;AACA,gBAAI0F,KAAKlD,QAAQkB,WAAR,CAAoB,KAAKvC,OAAL,EAApB,CAAT;AACA6D,oBAAQC,GAAR,gBAAwB,KAAKxE,IAAL,IAAa,EAArC,cAAiDR,MAAM0F,IAAN,CAAWD,EAAX,CAAjD;AAEA9E,iBAAKgF,IAAL,CAAUF,EAAV,EAAc,YAAA;AACV,uBAAO,OAAKG,OAAL,CAAarD,OAAb,EAAsB5B,IAAtB,CAAP;AACH,aAFD;AAIA,iBAAKR,IAAL,CAAU0F,QAAV,GAAqBJ,EAArB;AAEA,mBAAOA,EAAP;AACH;;;;;;AAxdiBK,QAAA5F,QAAA,GAAQA,QAAR","file":"../PipeTask.js","sourcesContent":["\"use strict\";\nconst TaskConfig_1 = require('./TaskConfig');\nconst utils_1 = require('./utils');\nconst coregulp = require('gulp');\nconst chalk = require('chalk');\nconst _ = require('lodash');\n/**\n * Task base class.\n *\n * @export\n * @class Task\n * @implements {ITask}\n */\nclass PipeTask {\n    constructor(info) {\n        /**\n         * run mutil source stream way. default parallel.\n         *\n         *\n         * @memberOf PipeTask\n         */\n        this.runWay = TaskConfig_1.RunWay.parallel;\n        this.operateFileds = ['name', 'oper', 'order', 'nonePipe', 'noneOutput'];\n        this.info = info || {};\n        this.info.name = this.info.name || this.name;\n    }\n    /**\n     * get task info.\n     *\n     * @type {ITaskInfo}\n     * @memberOf PipeTask\n     */\n    getInfo() {\n        if (!this.info.name) {\n            this.info.name = this.name;\n        }\n        return this.info;\n    }\n    /**\n     * source streams.\n     *\n     * @param {ITaskContext} context\n     * @param {IAssertDist} option\n     * @param {Gulp} gulp\n     * @returns {(TransformSource | Promise<TransformSource>)}\n     *\n     * @memberOf PipeTask\n     */\n    source(ctx, dist, gulp) {\n        let option = ctx.option;\n        if (option.source) {\n            return _.isFunction(option.source) ? option.source(ctx, dist, gulp) : option.source;\n        }\n        let loader = option['loader'];\n        if (loader && option.source) {\n            return _.isFunction(loader.source) ? loader.source(ctx, dist, gulp) : loader.source;\n        }\n        return gulp.src(ctx.getSrc(this.getInfo()));\n    }\n    /**\n     * task pipe works.\n     *\n     * @param {ITaskContext} context\n     * @param {IAssertDist} dist\n     * @param {Gulp} [gulp]\n     * @returns {Pipe[]}\n     *\n     * @memberOf PipeTask\n     */\n    pipes(ctx, dist, gulp) {\n        let option = ctx.option;\n        let pipes = null;\n        let loader = option['loader'];\n        if (loader && _.isFunction(loader.pipes)) {\n            pipes = _.isFunction(loader.pipes) ? loader.pipes(ctx, option, gulp) : _.filter(loader.pipes, p => _.isFunction(p) || (p.name && p.name === dist.name));\n        }\n        if (option.pipes) {\n            let opps = _.isFunction(option.pipes) ? option.pipes(ctx, option, gulp) : _.filter(option.pipes, p => _.isFunction(p) || (p.name && p.name === dist.name));\n            if (opps && opps.length > 0) {\n                pipes = pipes ? pipes.concat(opps) : opps;\n            }\n        }\n        return pipes || [];\n    }\n    /**\n     * output pipes.\n     *\n     * @param {ITaskContext} context\n     * @param {IAssertDist} dist\n     * @param {Gulp} [gulp]\n     * @returns {OutputPipe[]}\n     *\n     * @memberOf PipeTask\n     */\n    output(ctx, dist, gulp) {\n        let option = ctx.option;\n        let pipes = null;\n        let loader = option['loader'];\n        if (loader && !_.isString(loader) && !_.isArray(loader)) {\n            if (loader.output) {\n                pipes = _.isFunction(loader.output) ? loader.output(ctx, option, gulp) : _.filter(loader.pipes, p => _.isFunction(p) || (p.name && p.name === dist.name));\n            }\n            else if (loader.output === null) {\n                return [(stream) => stream];\n            }\n        }\n        if (option.output) {\n            let opps = _.isFunction(option.output) ? option.output(ctx, option, gulp) : _.filter(option.output, p => _.isFunction(p) || (p.name && p.name === dist.name));\n            if (opps && opps.length > 0) {\n                pipes = pipes ? pipes.concat(opps) : opps;\n            }\n        }\n        else if (option.output === null) {\n            return [(stream) => stream];\n        }\n        return pipes || [(stream) => stream.pipe(gulp.dest(ctx.getDist(dist)))];\n    }\n    /**\n     *  custom pipe Promise.\n     *\n     * @protected\n     * @param {ITransform} source\n     * @param {ITaskContext} ctx\n     * @param {IAssertDist} dist\n     * @param {Gulp} gulp\n     * @returns\n     *\n     * @memberOf PipeTask\n     */\n    customPipe(source, ctx, dist, gulp) {\n        let cfgopt = ctx.option;\n        let loader = cfgopt['loader'];\n        let prsrc;\n        let oper = this.getTransformOperate(source);\n        if (cfgopt.pipe) {\n            prsrc = this.cpipe2Promise(source, cfgopt, ctx, dist, gulp);\n        }\n        if (loader && !_.isString(loader) && !_.isArray(loader) && loader.pipe) {\n            prsrc = prsrc ?\n                prsrc.then(stream => {\n                    this.setTransformOperate(stream, oper);\n                    return this.cpipe2Promise(stream, loader, ctx, dist, gulp);\n                })\n                : this.cpipe2Promise(source, loader, ctx, dist, gulp);\n        }\n        if (prsrc) {\n            return prsrc.then(stream => {\n                this.setTransformOperate(stream, oper);\n                return stream;\n            });\n        }\n        return source;\n    }\n    /**\n     * get option.\n     *\n     * @protected\n     * @param {ITaskContext} context\n     * @returns {IAssertDist}\n     *\n     * @memberOf PipeTask\n     */\n    getOption(context) {\n        return context.option;\n    }\n    /**\n     * match pipe Operate\n     *\n     * @protected\n     * @param {IOperate} p\n     * @param {string} name\n     * @param {ITaskContext} ctx\n     * @param {IOperate} [trsOperate]\n     * @param {boolean} [isOutput=false]\n     * @returns\n     *\n     * @memberOf PipeTask\n     */\n    match(p, name, ctx, trsOperate, isOutput = false) {\n        if (!p) {\n            return false;\n        }\n        if (p.name && !name.endsWith(ctx.toStr(p.name))) {\n            return false;\n        }\n        if (p.oper && (p.oper & ctx.oper) <= 0) {\n            return false;\n        }\n        if (isOutput && p.noneOutput) {\n            return false;\n        }\n        else if (!isOutput && p.nonePipe) {\n            return false;\n        }\n        if (trsOperate) {\n            if (trsOperate.name && !name.endsWith(ctx.toStr(trsOperate.name))) {\n                return false;\n            }\n            if (trsOperate.oper && (trsOperate.oper & ctx.oper) <= 0) {\n                return false;\n            }\n            if (isOutput && trsOperate.noneOutput) {\n                return false;\n            }\n            else if (!isOutput && trsOperate.nonePipe) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * convert custom pipe result to Promise.\n     *\n     * @protected\n     * @param {ITransform} source\n     * @param {ICustomPipe} opt\n     * @param {ITaskContext} context\n     * @param {IAssertDist} dist\n     * @param {Gulp} gulp\n     * @returns\n     *\n     * @memberOf PipeTask\n     */\n    cpipe2Promise(source, opt, context, dist, gulp) {\n        return new Promise((resolve, reject) => {\n            let ps = opt.pipe(source, context, dist, gulp, (err) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve();\n                }\n            });\n            if (ps) {\n                Promise.resolve(ps).then(resolve, reject);\n            }\n        });\n    }\n    /**\n     * get transform Operate.\n     *\n     * @protected\n     * @param {ITransform} source\n     * @returns {IOperate}\n     *\n     * @memberOf PipeTask\n     */\n    getTransformOperate(source) {\n        return _.pick(source, this.operateFileds);\n    }\n    /**\n     * set transform Operate.\n     *\n     * @protected\n     * @param {ITransform} source\n     * @param {IOperate} operate\n     * @returns\n     *\n     * @memberOf PipeTask\n     */\n    setTransformOperate(source, operate) {\n        if (!source) {\n            return;\n        }\n        _.each(this.operateFileds, n => {\n            if (!_.isUndefined(operate[n])) {\n                source[n] = operate[n];\n            }\n        });\n    }\n    /**\n     * covert pipes transform to Promise.\n     *\n     * @protected\n     * @param {ITransform} source\n     * @param {ITaskContext} context\n     * @param {IAssertDist} dist\n     * @param {Gulp} gulp\n     * @param {Pipe[]} [pipes]\n     * @returns\n     *\n     * @memberOf PipeTask\n     */\n    pipes2Promise(source, ctx, dist, gulp, pipes) {\n        let name = ctx.subTaskName(dist, this.name);\n        let oper = this.getTransformOperate(source);\n        return Promise.all(_.map(pipes || this.pipes(ctx, dist, gulp), (p) => {\n            if (_.isFunction(p)) {\n                return p(ctx, dist, gulp);\n            }\n            else {\n                if (!this.match(p, name, ctx, oper)) {\n                    return null;\n                }\n                else {\n                    return Promise.resolve(p.toTransform(ctx, dist, gulp))\n                        .then(trs => {\n                        trs.order = p.order;\n                        return trs;\n                    });\n                }\n            }\n        }))\n            .then(tanseq => {\n            let tans = utils_1.sortOrder(tanseq, it => it.order, ctx, true);\n            _.each(tans, (stream) => {\n                if (!this.match(stream, name, ctx, oper)) {\n                    return;\n                }\n                if (_.isFunction(stream.transformSourcePipe)) {\n                    source = stream.transformSourcePipe(source);\n                }\n                else if (_.isFunction(source.transformPipe)) {\n                    source = source.transformPipe(stream);\n                }\n                else {\n                    source = source.pipe(stream);\n                }\n            });\n            this.setTransformOperate(source, oper);\n            return source;\n        });\n    }\n    /**\n     * output pipes transform to Promise.\n     *\n     * @protected\n     * @param {ITransform} source\n     * @param {ITaskContext} context\n     * @param {IAssertDist} dist\n     * @param {Gulp} gulp\n     * @param {OutputPipe[]} [output]\n     * @returns\n     *\n     * @memberOf PipeTask\n     */\n    output2Promise(source, context, dist, gulp, output) {\n        let name = context.subTaskName(dist, this.name);\n        let oper = this.getTransformOperate(source);\n        let outputs = output || this.output(context, dist, gulp);\n        return Promise.all(_.map(outputs, output => {\n            if (_.isFunction(output)) {\n                return output(source, context, dist, gulp);\n            }\n            else {\n                if (!this.match(output, name, context, oper, true)) {\n                    return null;\n                }\n                else {\n                    return output.toTransform(source, context, dist, gulp);\n                }\n            }\n        }))\n            .then(outputs => {\n            return Promise.all(_.map(outputs, output => {\n                return new Promise((resolve, reject) => {\n                    if (output) {\n                        output\n                            .once('end', () => {\n                            resolve(output);\n                        })\n                            .once('error', reject);\n                    }\n                    else {\n                        resolve();\n                    }\n                }).then(result => {\n                    output.removeAllListeners('error');\n                    output.removeAllListeners('end');\n                    return result;\n                });\n            }));\n        });\n    }\n    /**\n     * each one source stream works.\n     *\n     * @protected\n     * @param {ITransform} source\n     * @param {ITaskContext} ctx\n     * @param {IAssertDist} option\n     * @param {Gulp} gulp\n     * @param {Pipe[]} [pipes]\n     * @param {OutputPipe[]} [output]\n     * @returns\n     *\n     * @memberOf PipeTask\n     */\n    working(source, ctx, option, gulp, pipes, output) {\n        return Promise.resolve(source)\n            .then(psrc => this.customPipe(psrc, ctx, option, gulp))\n            .then(psrc => this.pipes2Promise(psrc, ctx, option, gulp, pipes))\n            .then(psrc => this.output2Promise(psrc, ctx, option, gulp, output))\n            .catch(err => {\n            console.log(chalk.red(err));\n            process.exit(0);\n        });\n    }\n    /**\n     * execute task working\n     *\n     * @param {ITaskContext} context\n     * @param {Gulp} gulp\n     * @returns {Promise<any>}\n     *\n     * @memberOf PipeTask\n     */\n    execute(context, gulp) {\n        let option = this.getOption(context);\n        return Promise.resolve(this.source(context, option, gulp))\n            .then(stream => {\n            if (_.isArray(stream)) {\n                if (this.runWay === TaskConfig_1.RunWay.parallel) {\n                    return Promise.all(_.map(stream, st => this.working(st, context, option, gulp)));\n                }\n                else if (this.runWay === TaskConfig_1.RunWay.sequence) {\n                    let pthen;\n                    _.each(stream, st => {\n                        if (!pthen) {\n                            pthen = this.working(st, context, option, gulp);\n                        }\n                        else {\n                            pthen = pthen.then(() => {\n                                return this.working(st, context, option, gulp);\n                            });\n                        }\n                    });\n                    return pthen;\n                }\n                else {\n                    return Promise.reject('runWay setting error.');\n                }\n            }\n            else {\n                return this.working(stream, context, option, gulp);\n            }\n        });\n    }\n    /**\n     * setup task works.\n     *\n     * @param {ITaskContext} context\n     * @param {Gulp} [gulp]\n     * @returns {TaskResult}\n     *\n     * @memberOf PipeTask\n     */\n    setup(context, gulp) {\n        gulp = gulp || coregulp;\n        // let option = this.getOption(context);\n        let tk = context.subTaskName(this.getInfo());\n        console.log(`register ${this.name || ''} task:`, chalk.cyan(tk));\n        gulp.task(tk, () => {\n            return this.execute(context, gulp);\n        });\n        this.info.taskName = tk;\n        return tk;\n    }\n}\nexports.PipeTask = PipeTask;\n","import { Gulp } from 'gulp';\r\nimport { TransformSource, RunWay, IAssertDist, ITaskInfo, TaskResult, ITaskContext, IOperate, ICustomPipe, Pipe, OutputPipe, ITask, ITransform, IPipeOption } from './TaskConfig';\r\nimport { sortOrder } from './utils';\r\nimport * as coregulp from 'gulp';\r\nimport * as chalk from 'chalk';\r\nimport * as _ from 'lodash';\r\n\r\n/**\r\n * pipe task.\r\n * \r\n * @export\r\n * @interface IPipeWork\r\n */\r\nexport interface IPipeTask extends ITask {\r\n    /**\r\n     * task default name.\r\n     * \r\n     * @type {string}\r\n     * @memberOf IPipeTask\r\n     */\r\n    name: string;\r\n    /**\r\n     * gulp src stream.\r\n     * \r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} gulp\r\n     * @returns {(TransformSource | Promise<TransformSource>)}\r\n     * \r\n     * @memberOf IPipeTask\r\n     */\r\n    source(context: ITaskContext, dist: IAssertDist, gulp: Gulp): TransformSource | Promise<TransformSource>;\r\n    /**\r\n     * task pipe works.\r\n     * \r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} [gulp]\r\n     * @returns {Pipe[]}\r\n     * \r\n     * @memberOf IPipeTask\r\n     */\r\n    pipes(context: ITaskContext, dist: IAssertDist, gulp?: Gulp): Pipe[];\r\n\r\n    /**\r\n     * output pipes.\r\n     * \r\n     * @param {ITaskContext} [context]\r\n     * @param {Gulp} [gulp]\r\n     * @returns {OutputPipe[]}\r\n     * \r\n     * @memberOf IPipeTask\r\n     */\r\n    output(context: ITaskContext, dist: IAssertDist, gulp?: Gulp): OutputPipe[];\r\n    /**\r\n     * execute task works.\r\n     * \r\n     * @param {ITaskContext} context\r\n     * @param {Gulp} gulp\r\n     * @returns {Promise<any>}\r\n     * \r\n     * @memberOf IPipeTask\r\n     */\r\n    execute(context: ITaskContext, gulp: Gulp): Promise<any>;\r\n}\r\n\r\n/**\r\n * Task base class.\r\n * \r\n * @export\r\n * @class Task\r\n * @implements {ITask}\r\n */\r\nexport abstract class PipeTask implements IPipeTask {\r\n    /**\r\n     * run mutil source stream way. default parallel.\r\n     * \r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    public runWay = RunWay.parallel;\r\n    /**\r\n     * task default name.\r\n     * \r\n     * @type {string}\r\n     * @memberOf PipeTask\r\n     */\r\n    name: string;\r\n\r\n\r\n    constructor(info?: ITaskInfo) {\r\n        this.info = info || {};\r\n        this.info.name = this.info.name || this.name;\r\n    }\r\n\r\n    protected info: ITaskInfo;\r\n\r\n    /**\r\n     * get task info.\r\n     * \r\n     * @type {ITaskInfo}\r\n     * @memberOf PipeTask\r\n     */\r\n    public getInfo(): ITaskInfo {\r\n        if (!this.info.name) {\r\n            this.info.name = this.name;\r\n        }\r\n        return this.info;\r\n    }\r\n\r\n    /**\r\n     * source streams.\r\n     * \r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} option\r\n     * @param {Gulp} gulp\r\n     * @returns {(TransformSource | Promise<TransformSource>)}\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    source(ctx: ITaskContext, dist: IAssertDist, gulp: Gulp): TransformSource | Promise<TransformSource> {\r\n        let option = ctx.option;\r\n        if (option.source) {\r\n            return _.isFunction(option.source) ? option.source(ctx, dist, gulp) : option.source;\r\n        }\r\n        let loader = <IPipeOption>option['loader'];\r\n        if (loader && option.source) {\r\n            return _.isFunction(loader.source) ? loader.source(ctx, dist, gulp) : loader.source;\r\n        }\r\n        return gulp.src(ctx.getSrc(this.getInfo()));\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * task pipe works.\r\n     * \r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} [gulp]\r\n     * @returns {Pipe[]}\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    pipes(ctx: ITaskContext, dist: IAssertDist, gulp?: Gulp): Pipe[] {\r\n        let option = ctx.option;\r\n        let pipes: Pipe[] = null;\r\n        let loader = <IPipeOption>option['loader'];\r\n        if (loader && _.isFunction(loader.pipes)) {\r\n            pipes = _.isFunction(loader.pipes) ? loader.pipes(ctx, option, gulp) : _.filter(<Pipe[]>loader.pipes, p => _.isFunction(p) || (p.name && p.name === dist.name));\r\n        }\r\n\r\n        if (option.pipes) {\r\n            let opps = _.isFunction(option.pipes) ? option.pipes(ctx, option, gulp) : _.filter(<Pipe[]>option.pipes, p => _.isFunction(p) || (p.name && p.name === dist.name));\r\n            if (opps && opps.length > 0) {\r\n                pipes = pipes ? pipes.concat(opps) : opps;\r\n            }\r\n        }\r\n        return pipes || [];\r\n    }\r\n\r\n    /**\r\n     * output pipes.\r\n     * \r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} [gulp]\r\n     * @returns {OutputPipe[]}\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    output(ctx: ITaskContext, dist: IAssertDist, gulp?: Gulp): OutputPipe[] {\r\n        let option = ctx.option;\r\n        let pipes: OutputPipe[] = null;\r\n        let loader = <IPipeOption>option['loader'];\r\n        if (loader && !_.isString(loader) && !_.isArray(loader)) {\r\n            if (loader.output) {\r\n                pipes = _.isFunction(loader.output) ? loader.output(ctx, option, gulp) : _.filter(<OutputPipe[]>loader.pipes, p => _.isFunction(p) || (p.name && p.name === dist.name));\r\n            } else if (loader.output === null) {\r\n                return [(stream) => stream];\r\n            }\r\n        }\r\n        if (option.output) {\r\n            let opps = _.isFunction(option.output) ? option.output(ctx, option, gulp) : _.filter(<OutputPipe[]>option.output, p => _.isFunction(p) || (p.name && p.name === dist.name));\r\n            if (opps && opps.length > 0) {\r\n                pipes = pipes ? pipes.concat(opps) : opps;\r\n            }\r\n        } else if (option.output === null) {\r\n            return [(stream) => stream];\r\n        }\r\n\r\n        return pipes || [(stream) => stream.pipe(gulp.dest(ctx.getDist(dist)))]\r\n    }\r\n\r\n    /**\r\n     *  custom pipe Promise.\r\n     * \r\n     * @protected\r\n     * @param {ITransform} source\r\n     * @param {ITaskContext} ctx\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} gulp\r\n     * @returns\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    protected customPipe(source: ITransform, ctx: ITaskContext, dist: IAssertDist, gulp: Gulp): ITransform | Promise<ITransform> {\r\n        let cfgopt = ctx.option;\r\n        let loader = <IPipeOption>cfgopt['loader'];\r\n        let prsrc: Promise<ITransform>;\r\n        let oper = this.getTransformOperate(source);\r\n        if (cfgopt.pipe) {\r\n            prsrc = this.cpipe2Promise(source, cfgopt, ctx, dist, gulp);\r\n        }\r\n        if (loader && !_.isString(loader) && !_.isArray(loader) && loader.pipe) {\r\n            prsrc = prsrc ?\r\n                prsrc.then(stream => {\r\n                    this.setTransformOperate(stream, oper);\r\n                    return this.cpipe2Promise(stream, loader, ctx, dist, gulp)\r\n                })\r\n                : this.cpipe2Promise(source, loader, ctx, dist, gulp);\r\n        }\r\n\r\n        if (prsrc) {\r\n            return prsrc.then(stream => {\r\n                this.setTransformOperate(stream, oper);\r\n                return stream;\r\n            });\r\n        }\r\n\r\n        return source;\r\n    }\r\n\r\n    /**\r\n     * get option.\r\n     * \r\n     * @protected\r\n     * @param {ITaskContext} context\r\n     * @returns {IAssertDist}\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    protected getOption(context: ITaskContext): IAssertDist {\r\n        return context.option;\r\n    }\r\n\r\n    /**\r\n     * match pipe Operate\r\n     * \r\n     * @protected\r\n     * @param {IOperate} p\r\n     * @param {string} name\r\n     * @param {ITaskContext} ctx\r\n     * @param {IOperate} [trsOperate]\r\n     * @param {boolean} [isOutput=false]\r\n     * @returns\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    protected match(p: IOperate, name: string, ctx: ITaskContext, trsOperate?: IOperate, isOutput = false) {\r\n        if (!p) {\r\n            return false;\r\n        }\r\n        if (p.name && !name.endsWith(ctx.toStr(p.name))) {\r\n            return false;\r\n        }\r\n\r\n        if (p.oper && (p.oper & ctx.oper) <= 0) {\r\n            return false;\r\n        }\r\n\r\n        if (isOutput && p.noneOutput) {\r\n            return false;\r\n        } else if (!isOutput && p.nonePipe) {\r\n            return false;\r\n        }\r\n\r\n        if (trsOperate) {\r\n            if (trsOperate.name && !name.endsWith(ctx.toStr(trsOperate.name))) {\r\n                return false;\r\n            }\r\n            if (trsOperate.oper && (trsOperate.oper & ctx.oper) <= 0) {\r\n                return false;\r\n            }\r\n\r\n            if (isOutput && trsOperate.noneOutput) {\r\n                return false;\r\n            } else if (!isOutput && trsOperate.nonePipe) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * convert custom pipe result to Promise.\r\n     * \r\n     * @protected\r\n     * @param {ITransform} source\r\n     * @param {ICustomPipe} opt\r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} gulp\r\n     * @returns\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    protected cpipe2Promise(source: ITransform, opt: ICustomPipe, context: ITaskContext, dist: IAssertDist, gulp: Gulp) {\r\n        return new Promise<ITransform>((resolve, reject) => {\r\n            let ps = opt.pipe(source, context, dist, gulp, (err) => {\r\n                if (err) {\r\n                    reject(err);\r\n                } else {\r\n                    resolve();\r\n                }\r\n            });\r\n            if (ps) {\r\n                Promise.resolve(ps).then(resolve, reject);\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n    protected operateFileds = ['name', 'oper', 'order', 'nonePipe', 'noneOutput'];\r\n    /**\r\n     * get transform Operate.\r\n     * \r\n     * @protected\r\n     * @param {ITransform} source\r\n     * @returns {IOperate}\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    protected getTransformOperate(source: ITransform): IOperate {\r\n        return _.pick(source, this.operateFileds);\r\n    }\r\n\r\n    /**\r\n     * set transform Operate.\r\n     * \r\n     * @protected\r\n     * @param {ITransform} source\r\n     * @param {IOperate} operate\r\n     * @returns\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    protected setTransformOperate(source: ITransform, operate: IOperate) {\r\n        if (!source) {\r\n            return;\r\n        }\r\n        _.each(this.operateFileds, n => {\r\n            if (!_.isUndefined(operate[n])) {\r\n                source[n] = operate[n];\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * covert pipes transform to Promise.\r\n     * \r\n     * @protected\r\n     * @param {ITransform} source\r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} gulp\r\n     * @param {Pipe[]} [pipes]\r\n     * @returns\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    protected pipes2Promise(source: ITransform, ctx: ITaskContext, dist: IAssertDist, gulp: Gulp, pipes?: Pipe[]) {\r\n        let name = ctx.subTaskName(dist, this.name);\r\n        let oper = this.getTransformOperate(source);\r\n        return Promise.all(_.map(pipes || this.pipes(ctx, dist, gulp), (p: Pipe) => {\r\n            if (_.isFunction(p)) {\r\n                return p(ctx, dist, gulp);\r\n            } else {\r\n                if (!this.match(p, name, ctx, oper)) {\r\n                    return null;\r\n                } else {\r\n                    return Promise.resolve(p.toTransform(ctx, dist, gulp))\r\n                        .then(trs => {\r\n                            trs.order = p.order;\r\n                            return trs;\r\n                        });\r\n                }\r\n            }\r\n        }))\r\n            .then(tanseq => {\r\n\r\n                let tans = sortOrder<ITransform>(tanseq, it => it.order, ctx, true);\r\n\r\n                _.each(tans, (stream: ITransform) => {\r\n                    if (!this.match(stream, name, ctx, oper)) {\r\n                        return;\r\n                    }\r\n\r\n                    if (_.isFunction(stream.transformSourcePipe)) {\r\n                        source = stream.transformSourcePipe(source);\r\n                    } else if (_.isFunction(source.transformPipe)) {\r\n                        source = source.transformPipe(stream);\r\n                    } else {\r\n                        source = source.pipe(stream);\r\n                    }\r\n                });\r\n                this.setTransformOperate(source, oper);\r\n                return source;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * output pipes transform to Promise.\r\n     * \r\n     * @protected\r\n     * @param {ITransform} source\r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} gulp\r\n     * @param {OutputPipe[]} [output]\r\n     * @returns\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    protected output2Promise(source: ITransform, context: ITaskContext, dist: IAssertDist, gulp: Gulp, output?: OutputPipe[]) {\r\n        let name = context.subTaskName(dist, this.name);\r\n        let oper = this.getTransformOperate(source);\r\n        let outputs = output || this.output(context, dist, gulp);\r\n        return Promise.all(_.map(outputs, output => {\r\n            if (_.isFunction(output)) {\r\n                return output(source, context, dist, gulp);\r\n            } else {\r\n                if (!this.match(output, name, context, oper, true)) {\r\n                    return null;\r\n                } else {\r\n                    return output.toTransform(source, context, dist, gulp);\r\n                }\r\n            }\r\n        }))\r\n            .then(outputs => {\r\n                return Promise.all(_.map(outputs, output => {\r\n                    return new Promise((resolve, reject) => {\r\n                        if (output) {\r\n                            output\r\n                                .once('end', () => {\r\n                                    resolve(output);\r\n                                })\r\n                                .once('error', reject);\r\n                        } else {\r\n                            resolve();\r\n                        }\r\n                    }).then(result => {\r\n                        output.removeAllListeners('error');\r\n                        output.removeAllListeners('end');\r\n                        return result;\r\n                    });\r\n                }));\r\n            })\r\n    }\r\n\r\n    /**\r\n     * each one source stream works.\r\n     * \r\n     * @protected\r\n     * @param {ITransform} source\r\n     * @param {ITaskContext} ctx\r\n     * @param {IAssertDist} option\r\n     * @param {Gulp} gulp\r\n     * @param {Pipe[]} [pipes]\r\n     * @param {OutputPipe[]} [output]\r\n     * @returns\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    protected working(source: ITransform, ctx: ITaskContext, option: IAssertDist, gulp: Gulp, pipes?: Pipe[], output?: OutputPipe[]) {\r\n        return Promise.resolve(source)\r\n            .then(psrc => this.customPipe(psrc, ctx, option, gulp))\r\n            .then(psrc => this.pipes2Promise(psrc, ctx, option, gulp, pipes))\r\n            .then(psrc => this.output2Promise(psrc, ctx, option, gulp, output))\r\n            .catch(err => {\r\n                console.log(chalk.red(err));\r\n                process.exit(0);\r\n            });\r\n    }\r\n\r\n    /**\r\n     * execute task working\r\n     * \r\n     * @param {ITaskContext} context\r\n     * @param {Gulp} gulp\r\n     * @returns {Promise<any>}\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    execute(context: ITaskContext, gulp: Gulp): Promise<any> {\r\n        let option = this.getOption(context);\r\n        return Promise.resolve(this.source(context, option, gulp))\r\n            .then(stream => {\r\n                if (_.isArray(stream)) {\r\n                    if (this.runWay === RunWay.parallel) {\r\n                        return Promise.all(_.map(stream, st => this.working(st, context, option, gulp)));\r\n                    } else if (this.runWay === RunWay.sequence) {\r\n                        let pthen: Promise<any>;\r\n                        _.each(stream, st => {\r\n                            if (!pthen) {\r\n                                pthen = this.working(st, context, option, gulp);\r\n                            } else {\r\n                                pthen = pthen.then(() => {\r\n                                    return this.working(st, context, option, gulp);\r\n                                });\r\n                            }\r\n                        });\r\n                        return pthen;\r\n                    } else {\r\n                        return Promise.reject('runWay setting error.');\r\n                    }\r\n                } else {\r\n                    return this.working(stream, context, option, gulp);\r\n                }\r\n            });\r\n    }\r\n\r\n    /**\r\n     * setup task works.\r\n     * \r\n     * @param {ITaskContext} context\r\n     * @param {Gulp} [gulp]\r\n     * @returns {TaskResult}\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    setup(context: ITaskContext, gulp?: Gulp): TaskResult {\r\n        gulp = gulp || coregulp;\r\n        // let option = this.getOption(context);\r\n        let tk = context.subTaskName(this.getInfo());\r\n        console.log(`register ${this.name || ''} task:`, chalk.cyan(tk));\r\n\r\n        gulp.task(tk, () => {\r\n            return this.execute(context, gulp);\r\n        });\r\n\r\n        this.info.taskName = tk;\r\n\r\n        return tk;\r\n    }\r\n}\r\n"]}