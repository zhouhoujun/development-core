{"version":3,"sources":["PipeTask.js","PipeTask.ts"],"names":["TaskConfig_1","require","utils_1","coregulp","chalk","_","PipeTask","info","_classCallCheck","this","runWay","RunWay","parallel","name","ctx","dist","gulp","option","source","isFunction","loader","src","getSrc","getInfo","pipes","filter","p","opps","length","concat","isString","isArray","output","stream","pipe","dest","getDist","_this","cfgopt","prsrc","cpipe2Promise","then","context","endsWith","taskStringVal","oper","opt","Promise","resolve","reject","ps","err","_this2","subTaskName","all","map","match","toTransform","trs","order","tanseq","tans","sortOrder","it","each","transformSourcePipe","transformPipe","_this3","outputs","once","result","removeAllListeners","_this4","psrc","customPipe","pipes2Promise","output2Promise","catch","console","log","red","process","exit","_this5","getOption","working","st","sequence","_ret","pthen","v","_typeof","_this6","tk","cyan","task","execute","taskName","exports"],"mappings":"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","file":"../PipeTask.js","sourcesContent":["\"use strict\";\nconst TaskConfig_1 = require('./TaskConfig');\nconst utils_1 = require('./utils');\nconst coregulp = require('gulp');\nconst chalk = require('chalk');\nconst _ = require('lodash');\n/**\n * Task base class.\n *\n * @export\n * @class Task\n * @implements {ITask}\n */\nclass PipeTask {\n    constructor(info) {\n        /**\n         * run mutil source stream way. default parallel.\n         *\n         *\n         * @memberOf PipeTask\n         */\n        this.runWay = TaskConfig_1.RunWay.parallel;\n        this.info = info || {};\n        this.info.name = this.info.name || this.name;\n    }\n    /**\n     * get task info.\n     *\n     * @type {ITaskInfo}\n     * @memberOf PipeTask\n     */\n    getInfo() {\n        if (!this.info.name) {\n            this.info.name = this.name;\n        }\n        return this.info;\n    }\n    /**\n     * source streams.\n     *\n     * @param {ITaskContext} context\n     * @param {IAssertDist} option\n     * @param {Gulp} gulp\n     * @returns {(TransformSource | Promise<TransformSource>)}\n     *\n     * @memberOf PipeTask\n     */\n    source(ctx, dist, gulp) {\n        // let source: TransformSource | Promise<TransformSource> = null;\n        // ctx.pipeOption((op) => {\n        //     if (!source && op.source) {\n        //         source = _.isFunction(op.source) ? op.source(ctx, dist, gulp) : op.source;\n        //     }\n        // });\n        // if (source) {\n        //     return source;\n        // }\n        // return gulp.src(ctx.getSrc(this.getInfo()));\n        let option = ctx.option;\n        if (option.source) {\n            return _.isFunction(option.source) ? option.source(ctx, dist, gulp) : option.source;\n        }\n        let loader = option['loader'];\n        if (loader && option.source) {\n            return _.isFunction(loader.source) ? loader.source(ctx, dist, gulp) : loader.source;\n        }\n        return gulp.src(ctx.getSrc(this.getInfo()));\n    }\n    /**\n     * task pipe works.\n     *\n     * @param {ITaskContext} context\n     * @param {IAssertDist} dist\n     * @param {Gulp} [gulp]\n     * @returns {Pipe[]}\n     *\n     * @memberOf PipeTask\n     */\n    pipes(ctx, dist, gulp) {\n        // let pipes: Pipe[] = [];\n        // ctx.pipeOption((op) => {\n        //     let opps = _.isFunction(op.pipes) ? op.pipes(ctx, dist, gulp) : _.filter(<Pipe[]>op.pipes, p => _.isFunction(p) || (p.name && p.name === dist.name));\n        //     if (opps && opps.length > 0) {\n        //         pipes = pipes.concat(opps)\n        //     }\n        // });\n        // return pipes;\n        let option = ctx.option;\n        let pipes = null;\n        let loader = option['loader'];\n        if (loader && _.isFunction(loader.pipes)) {\n            pipes = _.isFunction(loader.pipes) ? loader.pipes(ctx, option, gulp) : _.filter(loader.pipes, p => _.isFunction(p) || (p.name && p.name === dist.name));\n        }\n        if (option.pipes) {\n            let opps = _.isFunction(option.pipes) ? option.pipes(ctx, option, gulp) : _.filter(option.pipes, p => _.isFunction(p) || (p.name && p.name === dist.name));\n            if (opps && opps.length > 0) {\n                pipes = pipes ? pipes.concat(opps) : opps;\n            }\n        }\n        return pipes || [];\n    }\n    /**\n     * output pipes.\n     *\n     * @param {ITaskContext} context\n     * @param {IAssertDist} dist\n     * @param {Gulp} [gulp]\n     * @returns {OutputPipe[]}\n     *\n     * @memberOf PipeTask\n     */\n    output(ctx, dist, gulp) {\n        // let pipes: OutputPipe[] = [];\n        // ctx.pipeOption((op) => {\n        //     if (pipes === null) {\n        //         return;\n        //     }\n        //     if (op.output === null) {\n        //         pipes = null;\n        //     } else {\n        //         let outs = _.isFunction(op.output) ? op.output(ctx, dist, gulp) : _.filter(<OutputPipe[]>op.pipes, p => _.isFunction(p) || (p.name && p.name === dist.name));\n        //         if (outs && outs.length > 0) {\n        //             pipes = pipes.concat(outs);\n        //         }\n        //     }\n        // });\n        // if (pipes === null) {\n        //     return [(stream) => stream];\n        // }\n        // if (pipes.length > 0) {\n        //     return pipes;\n        // }\n        // return [(stream) => stream.pipe(gulp.dest(ctx.getDist(dist)))]\n        let option = ctx.option;\n        let pipes = null;\n        let loader = option['loader'];\n        if (loader && !_.isString(loader) && !_.isArray(loader)) {\n            if (loader.output) {\n                pipes = _.isFunction(loader.output) ? loader.output(ctx, option, gulp) : _.filter(loader.pipes, p => _.isFunction(p) || (p.name && p.name === dist.name));\n            }\n            else if (loader.output === null) {\n                return [(stream) => stream];\n            }\n        }\n        if (option.output) {\n            let opps = _.isFunction(option.output) ? option.output(ctx, option, gulp) : _.filter(option.output, p => _.isFunction(p) || (p.name && p.name === dist.name));\n            if (opps && opps.length > 0) {\n                pipes = pipes ? pipes.concat(opps) : opps;\n            }\n        }\n        else if (option.output === null) {\n            return [(stream) => stream];\n        }\n        return pipes || [(stream) => stream.pipe(gulp.dest(ctx.getDist(dist)))];\n    }\n    /**\n     *  custom pipe Promise.\n     *\n     * @protected\n     * @param {ITransform} source\n     * @param {ITaskContext} ctx\n     * @param {IAssertDist} dist\n     * @param {Gulp} gulp\n     * @returns\n     *\n     * @memberOf PipeTask\n     */\n    customPipe(source, ctx, dist, gulp) {\n        // let prsrc: Promise<ITransform> = null;\n        // ctx.pipeOption((op) => {\n        //     if (op.pipe) {\n        //         prsrc = prsrc ? prsrc.then(stream => this.cpipe2Promise(stream, op, ctx, dist, gulp))\n        //             : this.cpipe2Promise(source, op, ctx, dist, gulp);\n        //     }\n        // }, false);\n        // return prsrc || source;\n        let cfgopt = ctx.option;\n        let loader = cfgopt['loader'];\n        let prsrc;\n        if (cfgopt.pipe) {\n            prsrc = this.cpipe2Promise(source, cfgopt, ctx, dist, gulp);\n        }\n        if (loader && !_.isString(loader) && !_.isArray(loader) && loader.pipe) {\n            prsrc = prsrc ?\n                prsrc.then(stream => this.cpipe2Promise(stream, loader, ctx, dist, gulp))\n                : this.cpipe2Promise(source, loader, ctx, dist, gulp);\n        }\n        return prsrc || source;\n    }\n    /**\n     * get option.\n     *\n     * @protected\n     * @param {ITaskContext} context\n     * @returns {IAssertDist}\n     *\n     * @memberOf PipeTask\n     */\n    getOption(context) {\n        return context.option;\n    }\n    /**\n     * match pipe Operate\n     *\n     * @param {IPipeOperate} p\n     * @param {string} name\n     * @param {ITaskContext} context\n     * @returns\n     *\n     * @memberOf PipeTask\n     */\n    match(p, name, context) {\n        if (!p) {\n            return false;\n        }\n        if (p.name && !name.endsWith(utils_1.taskStringVal(p.name, context))) {\n            return false;\n        }\n        if (p.oper && (p.oper & context.oper) <= 0) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * convert custom pipe result to Promise.\n     *\n     * @protected\n     * @param {ITransform} source\n     * @param {ICustomPipe} opt\n     * @param {ITaskContext} context\n     * @param {IAssertDist} dist\n     * @param {Gulp} gulp\n     * @returns\n     *\n     * @memberOf PipeTask\n     */\n    cpipe2Promise(source, opt, context, dist, gulp) {\n        return new Promise((resolve, reject) => {\n            let ps = opt.pipe(source, context, dist, gulp, (err) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve();\n                }\n            });\n            if (ps) {\n                Promise.resolve(ps).then(resolve, reject);\n            }\n        });\n    }\n    /**\n     * covert pipes transform to Promise.\n     *\n     * @protected\n     * @param {ITransform} source\n     * @param {ITaskContext} context\n     * @param {IAssertDist} dist\n     * @param {Gulp} gulp\n     * @param {Pipe[]} [pipes]\n     * @returns\n     *\n     * @memberOf PipeTask\n     */\n    pipes2Promise(source, ctx, dist, gulp, pipes) {\n        let name = ctx.subTaskName(dist, this.name);\n        return Promise.all(_.map(pipes || this.pipes(ctx, dist, gulp), (p) => {\n            if (_.isFunction(p)) {\n                return p(ctx, dist, gulp);\n            }\n            else {\n                if (!this.match(p, name, ctx)) {\n                    return null;\n                }\n                else {\n                    return Promise.resolve(p.toTransform(ctx, dist, gulp))\n                        .then(trs => {\n                        trs.order = p.order;\n                        return trs;\n                    });\n                }\n            }\n        }))\n            .then(tanseq => {\n            let tans = utils_1.sortOrder(tanseq, it => it.order, ctx, true);\n            _.each(tans, (stream) => {\n                if (!this.match(stream, name, ctx)) {\n                    return;\n                }\n                if (_.isFunction(stream.transformSourcePipe)) {\n                    source = stream.transformSourcePipe(source);\n                }\n                else if (_.isFunction(source.transformPipe)) {\n                    source = source.transformPipe(stream);\n                }\n                else {\n                    source = source.pipe(stream);\n                }\n            });\n            return source;\n        });\n    }\n    /**\n     * output pipes transform to Promise.\n     *\n     * @protected\n     * @param {ITransform} source\n     * @param {ITaskContext} context\n     * @param {IAssertDist} dist\n     * @param {Gulp} gulp\n     * @param {OutputPipe[]} [output]\n     * @returns\n     *\n     * @memberOf PipeTask\n     */\n    output2Promise(source, context, dist, gulp, output) {\n        let name = context.subTaskName(dist, this.name);\n        let outputs = output || this.output(context, dist, gulp);\n        return Promise.all(_.map(outputs, output => {\n            if (_.isFunction(output)) {\n                return output(source, context, dist, gulp);\n            }\n            else {\n                if (!this.match(output, name, context)) {\n                    return null;\n                }\n                else {\n                    return output.toTransform(source, context, dist, gulp);\n                }\n            }\n        }))\n            .then(outputs => {\n            return Promise.all(_.map(outputs, output => {\n                return new Promise((resolve, reject) => {\n                    if (output) {\n                        output\n                            .once('end', () => {\n                            resolve(output);\n                        })\n                            .once('error', reject);\n                    }\n                    else {\n                        resolve();\n                    }\n                }).then(result => {\n                    output.removeAllListeners('error');\n                    output.removeAllListeners('end');\n                    return result;\n                });\n            }));\n        });\n    }\n    /**\n     * each one source stream works.\n     *\n     * @protected\n     * @param {ITransform} source\n     * @param {ITaskContext} ctx\n     * @param {IAssertDist} option\n     * @param {Gulp} gulp\n     * @param {Pipe[]} [pipes]\n     * @param {OutputPipe[]} [output]\n     * @returns\n     *\n     * @memberOf PipeTask\n     */\n    working(source, ctx, option, gulp, pipes, output) {\n        return Promise.resolve(source)\n            .then(psrc => this.customPipe(psrc, ctx, option, gulp))\n            .then(psrc => this.pipes2Promise(psrc, ctx, option, gulp, pipes))\n            .then(psrc => this.output2Promise(psrc, ctx, option, gulp, output))\n            .catch(err => {\n            console.log(chalk.red(err));\n            process.exit(0);\n        });\n    }\n    /**\n     * execute task working\n     *\n     * @param {ITaskContext} context\n     * @param {Gulp} gulp\n     * @returns {Promise<any>}\n     *\n     * @memberOf PipeTask\n     */\n    execute(context, gulp) {\n        let option = this.getOption(context);\n        return Promise.resolve(this.source(context, option, gulp))\n            .then(stream => {\n            if (_.isArray(stream)) {\n                if (this.runWay === TaskConfig_1.RunWay.parallel) {\n                    return Promise.all(_.map(stream, st => this.working(st, context, option, gulp)));\n                }\n                else if (this.runWay === TaskConfig_1.RunWay.sequence) {\n                    let pthen;\n                    _.each(stream, st => {\n                        if (!pthen) {\n                            pthen = this.working(st, context, option, gulp);\n                        }\n                        else {\n                            pthen = pthen.then(() => {\n                                return this.working(st, context, option, gulp);\n                            });\n                        }\n                    });\n                    return pthen;\n                }\n                else {\n                    return Promise.reject('runWay setting error.');\n                }\n            }\n            else {\n                return this.working(stream, context, option, gulp);\n            }\n        });\n    }\n    /**\n     * setup task works.\n     *\n     * @param {ITaskContext} context\n     * @param {Gulp} [gulp]\n     * @returns {TaskResult}\n     *\n     * @memberOf PipeTask\n     */\n    setup(context, gulp) {\n        gulp = gulp || coregulp;\n        // let option = this.getOption(context);\n        let tk = context.subTaskName(this.getInfo());\n        console.log(`register ${this.name || ''} task:`, chalk.cyan(tk));\n        gulp.task(tk, () => {\n            return this.execute(context, gulp);\n        });\n        this.info.taskName = tk;\n        return tk;\n    }\n}\nexports.PipeTask = PipeTask;\n","import { Gulp } from 'gulp';\r\nimport { TransformSource, RunWay, IAssertDist, ITaskInfo, TaskResult, ITaskContext, IOperate, ICustomPipe, Pipe, OutputPipe, ITask, ITransform, IPipeOption } from './TaskConfig';\r\nimport { taskStringVal, sortOrder } from './utils';\r\nimport * as coregulp from 'gulp';\r\nimport * as chalk from 'chalk';\r\nimport * as _ from 'lodash';\r\n\r\n/**\r\n * pipe task.\r\n * \r\n * @export\r\n * @interface IPipeWork\r\n */\r\nexport interface IPipeTask extends ITask {\r\n    /**\r\n     * task default name.\r\n     * \r\n     * @type {string}\r\n     * @memberOf IPipeTask\r\n     */\r\n    name: string;\r\n    /**\r\n     * gulp src stream.\r\n     * \r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} gulp\r\n     * @returns {(TransformSource | Promise<TransformSource>)}\r\n     * \r\n     * @memberOf IPipeTask\r\n     */\r\n    source(context: ITaskContext, dist: IAssertDist, gulp: Gulp): TransformSource | Promise<TransformSource>;\r\n    /**\r\n     * task pipe works.\r\n     * \r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} [gulp]\r\n     * @returns {Pipe[]}\r\n     * \r\n     * @memberOf IPipeTask\r\n     */\r\n    pipes(context: ITaskContext, dist: IAssertDist, gulp?: Gulp): Pipe[];\r\n\r\n    /**\r\n     * output pipes.\r\n     * \r\n     * @param {ITaskContext} [context]\r\n     * @param {Gulp} [gulp]\r\n     * @returns {OutputPipe[]}\r\n     * \r\n     * @memberOf IPipeTask\r\n     */\r\n    output(context: ITaskContext, dist: IAssertDist, gulp?: Gulp): OutputPipe[];\r\n    /**\r\n     * execute task works.\r\n     * \r\n     * @param {ITaskContext} context\r\n     * @param {Gulp} gulp\r\n     * @returns {Promise<any>}\r\n     * \r\n     * @memberOf IPipeTask\r\n     */\r\n    execute(context: ITaskContext, gulp: Gulp): Promise<any>;\r\n}\r\n\r\n/**\r\n * Task base class.\r\n * \r\n * @export\r\n * @class Task\r\n * @implements {ITask}\r\n */\r\nexport abstract class PipeTask implements IPipeTask {\r\n    /**\r\n     * run mutil source stream way. default parallel.\r\n     * \r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    public runWay = RunWay.parallel;\r\n    /**\r\n     * task default name.\r\n     * \r\n     * @type {string}\r\n     * @memberOf PipeTask\r\n     */\r\n    name: string;\r\n\r\n\r\n    constructor(info?: ITaskInfo) {\r\n        this.info = info || {};\r\n        this.info.name = this.info.name || this.name;\r\n    }\r\n\r\n    protected info: ITaskInfo;\r\n\r\n    /**\r\n     * get task info.\r\n     * \r\n     * @type {ITaskInfo}\r\n     * @memberOf PipeTask\r\n     */\r\n    public getInfo(): ITaskInfo {\r\n        if (!this.info.name) {\r\n            this.info.name = this.name;\r\n        }\r\n        return this.info;\r\n    }\r\n\r\n    /**\r\n     * source streams.\r\n     * \r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} option\r\n     * @param {Gulp} gulp\r\n     * @returns {(TransformSource | Promise<TransformSource>)}\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    source(ctx: ITaskContext, dist: IAssertDist, gulp: Gulp): TransformSource | Promise<TransformSource> {\r\n        // let source: TransformSource | Promise<TransformSource> = null;\r\n        // ctx.pipeOption((op) => {\r\n        //     if (!source && op.source) {\r\n        //         source = _.isFunction(op.source) ? op.source(ctx, dist, gulp) : op.source;\r\n        //     }\r\n        // });\r\n\r\n        // if (source) {\r\n        //     return source;\r\n        // }\r\n        // return gulp.src(ctx.getSrc(this.getInfo()));\r\n\r\n        let option = ctx.option;\r\n        if (option.source) {\r\n            return _.isFunction(option.source) ? option.source(ctx, dist, gulp) : option.source;\r\n        }\r\n        let loader = <IPipeOption>option['loader'];\r\n        if (loader && option.source) {\r\n            return _.isFunction(loader.source) ? loader.source(ctx, dist, gulp) : loader.source;\r\n        }\r\n        return gulp.src(ctx.getSrc(this.getInfo()));\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * task pipe works.\r\n     * \r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} [gulp]\r\n     * @returns {Pipe[]}\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    pipes(ctx: ITaskContext, dist: IAssertDist, gulp?: Gulp): Pipe[] {\r\n        // let pipes: Pipe[] = [];\r\n        // ctx.pipeOption((op) => {\r\n        //     let opps = _.isFunction(op.pipes) ? op.pipes(ctx, dist, gulp) : _.filter(<Pipe[]>op.pipes, p => _.isFunction(p) || (p.name && p.name === dist.name));\r\n        //     if (opps && opps.length > 0) {\r\n        //         pipes = pipes.concat(opps)\r\n        //     }\r\n        // });\r\n        // return pipes;\r\n\r\n        let option = ctx.option;\r\n        let pipes: Pipe[] = null;\r\n        let loader = <IPipeOption>option['loader'];\r\n        if (loader && _.isFunction(loader.pipes)) {\r\n            pipes = _.isFunction(loader.pipes) ? loader.pipes(ctx, option, gulp) : _.filter(<Pipe[]>loader.pipes, p => _.isFunction(p) || (p.name && p.name === dist.name));\r\n        }\r\n\r\n        if (option.pipes) {\r\n            let opps = _.isFunction(option.pipes) ? option.pipes(ctx, option, gulp) : _.filter(<Pipe[]>option.pipes, p => _.isFunction(p) || (p.name && p.name === dist.name));\r\n            if (opps && opps.length > 0) {\r\n                pipes = pipes ? pipes.concat(opps) : opps;\r\n            }\r\n        }\r\n        return pipes || [];\r\n    }\r\n\r\n    /**\r\n     * output pipes.\r\n     * \r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} [gulp]\r\n     * @returns {OutputPipe[]}\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    output(ctx: ITaskContext, dist: IAssertDist, gulp?: Gulp): OutputPipe[] {\r\n        // let pipes: OutputPipe[] = [];\r\n        // ctx.pipeOption((op) => {\r\n        //     if (pipes === null) {\r\n        //         return;\r\n        //     }\r\n        //     if (op.output === null) {\r\n        //         pipes = null;\r\n        //     } else {\r\n        //         let outs = _.isFunction(op.output) ? op.output(ctx, dist, gulp) : _.filter(<OutputPipe[]>op.pipes, p => _.isFunction(p) || (p.name && p.name === dist.name));\r\n        //         if (outs && outs.length > 0) {\r\n        //             pipes = pipes.concat(outs);\r\n        //         }\r\n        //     }\r\n        // });\r\n\r\n        // if (pipes === null) {\r\n        //     return [(stream) => stream];\r\n        // }\r\n\r\n        // if (pipes.length > 0) {\r\n        //     return pipes;\r\n        // }\r\n\r\n        // return [(stream) => stream.pipe(gulp.dest(ctx.getDist(dist)))]\r\n\r\n\r\n        let option = ctx.option;\r\n        let pipes: OutputPipe[] = null;\r\n        let loader = <IPipeOption>option['loader'];\r\n        if (loader && !_.isString(loader) && !_.isArray(loader)) {\r\n            if (loader.output) {\r\n                pipes = _.isFunction(loader.output) ? loader.output(ctx, option, gulp) : _.filter(<OutputPipe[]>loader.pipes, p => _.isFunction(p) || (p.name && p.name === dist.name));\r\n            } else if (loader.output === null) {\r\n                return [(stream) => stream];\r\n            }\r\n        }\r\n        if (option.output) {\r\n            let opps = _.isFunction(option.output) ? option.output(ctx, option, gulp) : _.filter(<OutputPipe[]>option.output, p => _.isFunction(p) || (p.name && p.name === dist.name));\r\n            if (opps && opps.length > 0) {\r\n                pipes = pipes ? pipes.concat(opps) : opps;\r\n            }\r\n        } else if (option.output === null) {\r\n            return [(stream) => stream];\r\n        }\r\n\r\n        return pipes || [(stream) => stream.pipe(gulp.dest(ctx.getDist(dist)))]\r\n    }\r\n\r\n    /**\r\n     *  custom pipe Promise.\r\n     * \r\n     * @protected\r\n     * @param {ITransform} source\r\n     * @param {ITaskContext} ctx\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} gulp\r\n     * @returns\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    protected customPipe(source: ITransform, ctx: ITaskContext, dist: IAssertDist, gulp: Gulp) {\r\n        // let prsrc: Promise<ITransform> = null;\r\n        // ctx.pipeOption((op) => {\r\n        //     if (op.pipe) {\r\n        //         prsrc = prsrc ? prsrc.then(stream => this.cpipe2Promise(stream, op, ctx, dist, gulp))\r\n        //             : this.cpipe2Promise(source, op, ctx, dist, gulp);\r\n        //     }\r\n        // }, false);\r\n\r\n        // return prsrc || source;\r\n\r\n        let cfgopt = ctx.option;\r\n        let loader = <IPipeOption>cfgopt['loader'];\r\n        let prsrc: Promise<ITransform>;\r\n        if (cfgopt.pipe) {\r\n            prsrc = this.cpipe2Promise(source, cfgopt, ctx, dist, gulp);\r\n        }\r\n        if (loader && !_.isString(loader) && !_.isArray(loader) && loader.pipe) {\r\n            prsrc = prsrc ?\r\n                prsrc.then(stream => this.cpipe2Promise(stream, loader, ctx, dist, gulp))\r\n                : this.cpipe2Promise(source, loader, ctx, dist, gulp);\r\n        }\r\n\r\n        return prsrc || source;\r\n    }\r\n\r\n    /**\r\n     * get option.\r\n     * \r\n     * @protected\r\n     * @param {ITaskContext} context\r\n     * @returns {IAssertDist}\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    protected getOption(context: ITaskContext): IAssertDist {\r\n        return context.option;\r\n    }\r\n\r\n    /**\r\n     * match pipe Operate\r\n     * \r\n     * @param {IPipeOperate} p\r\n     * @param {string} name\r\n     * @param {ITaskContext} context\r\n     * @returns\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    protected match(p: IOperate, name: string, context: ITaskContext) {\r\n        if (!p) {\r\n            return false;\r\n        }\r\n        if (p.name && !name.endsWith(taskStringVal(p.name, context))) {\r\n            return false;\r\n        }\r\n\r\n        if (p.oper && (p.oper & context.oper) <= 0) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * convert custom pipe result to Promise.\r\n     * \r\n     * @protected\r\n     * @param {ITransform} source\r\n     * @param {ICustomPipe} opt\r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} gulp\r\n     * @returns\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    protected cpipe2Promise(source: ITransform, opt: ICustomPipe, context: ITaskContext, dist: IAssertDist, gulp: Gulp) {\r\n        return new Promise<ITransform>((resolve, reject) => {\r\n            let ps = opt.pipe(source, context, dist, gulp, (err) => {\r\n                if (err) {\r\n                    reject(err);\r\n                } else {\r\n                    resolve();\r\n                }\r\n            });\r\n            if (ps) {\r\n                Promise.resolve(ps).then(resolve, reject);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * covert pipes transform to Promise.\r\n     * \r\n     * @protected\r\n     * @param {ITransform} source\r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} gulp\r\n     * @param {Pipe[]} [pipes]\r\n     * @returns\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    protected pipes2Promise(source: ITransform, ctx: ITaskContext, dist: IAssertDist, gulp: Gulp, pipes?: Pipe[]) {\r\n        let name = ctx.subTaskName(dist, this.name);\r\n        return Promise.all(_.map(pipes || this.pipes(ctx, dist, gulp), (p: Pipe) => {\r\n            if (_.isFunction(p)) {\r\n                return p(ctx, dist, gulp);\r\n            } else {\r\n                if (!this.match(p, name, ctx)) {\r\n                    return null;\r\n                } else {\r\n                    return Promise.resolve(p.toTransform(ctx, dist, gulp))\r\n                        .then(trs => {\r\n                            trs.order = p.order;\r\n                            return trs;\r\n                        });\r\n                }\r\n            }\r\n        }))\r\n            .then(tanseq => {\r\n\r\n                let tans = sortOrder<ITransform>(tanseq, it => it.order, ctx, true);\r\n\r\n                _.each(tans, (stream: ITransform) => {\r\n                    if (!this.match(stream, name, ctx)) {\r\n                        return;\r\n                    }\r\n\r\n                    if (_.isFunction(stream.transformSourcePipe)) {\r\n                        source = stream.transformSourcePipe(source);\r\n                    } else if (_.isFunction(source.transformPipe)) {\r\n                        source = source.transformPipe(stream);\r\n                    } else {\r\n                        source = source.pipe(stream);\r\n                    }\r\n                });\r\n                return source;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * output pipes transform to Promise.\r\n     * \r\n     * @protected\r\n     * @param {ITransform} source\r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} gulp\r\n     * @param {OutputPipe[]} [output]\r\n     * @returns\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    protected output2Promise(source: ITransform, context: ITaskContext, dist: IAssertDist, gulp: Gulp, output?: OutputPipe[]) {\r\n        let name = context.subTaskName(dist, this.name);\r\n        let outputs = output || this.output(context, dist, gulp);\r\n        return Promise.all(_.map(outputs, output => {\r\n            if (_.isFunction(output)) {\r\n                return output(source, context, dist, gulp);\r\n            } else {\r\n                if (!this.match(output, name, context)) {\r\n                    return null;\r\n                } else {\r\n                    return output.toTransform(source, context, dist, gulp);\r\n                }\r\n            }\r\n        }))\r\n            .then(outputs => {\r\n                return Promise.all(_.map(outputs, output => {\r\n                    return new Promise((resolve, reject) => {\r\n                        if (output) {\r\n                            output\r\n                                .once('end', () => {\r\n                                    resolve(output);\r\n                                })\r\n                                .once('error', reject);\r\n                        } else {\r\n                            resolve();\r\n                        }\r\n                    }).then(result => {\r\n                        output.removeAllListeners('error');\r\n                        output.removeAllListeners('end');\r\n                        return result;\r\n                    });\r\n                }));\r\n            })\r\n    }\r\n\r\n    /**\r\n     * each one source stream works.\r\n     * \r\n     * @protected\r\n     * @param {ITransform} source\r\n     * @param {ITaskContext} ctx\r\n     * @param {IAssertDist} option\r\n     * @param {Gulp} gulp\r\n     * @param {Pipe[]} [pipes]\r\n     * @param {OutputPipe[]} [output]\r\n     * @returns\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    protected working(source: ITransform, ctx: ITaskContext, option: IAssertDist, gulp: Gulp, pipes?: Pipe[], output?: OutputPipe[]) {\r\n        return Promise.resolve(source)\r\n            .then(psrc => this.customPipe(psrc, ctx, option, gulp))\r\n            .then(psrc => this.pipes2Promise(psrc, ctx, option, gulp, pipes))\r\n            .then(psrc => this.output2Promise(psrc, ctx, option, gulp, output))\r\n            .catch(err => {\r\n                console.log(chalk.red(err));\r\n                process.exit(0);\r\n            });\r\n    }\r\n\r\n    /**\r\n     * execute task working\r\n     * \r\n     * @param {ITaskContext} context\r\n     * @param {Gulp} gulp\r\n     * @returns {Promise<any>}\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    execute(context: ITaskContext, gulp: Gulp): Promise<any> {\r\n        let option = this.getOption(context);\r\n        return Promise.resolve(this.source(context, option, gulp))\r\n            .then(stream => {\r\n                if (_.isArray(stream)) {\r\n                    if (this.runWay === RunWay.parallel) {\r\n                        return Promise.all(_.map(stream, st => this.working(st, context, option, gulp)));\r\n                    } else if (this.runWay === RunWay.sequence) {\r\n                        let pthen: Promise<any>;\r\n                        _.each(stream, st => {\r\n                            if (!pthen) {\r\n                                pthen = this.working(st, context, option, gulp);\r\n                            } else {\r\n                                pthen = pthen.then(() => {\r\n                                    return this.working(st, context, option, gulp);\r\n                                });\r\n                            }\r\n                        });\r\n                        return pthen;\r\n                    } else {\r\n                        return Promise.reject('runWay setting error.');\r\n                    }\r\n                } else {\r\n                    return this.working(stream, context, option, gulp);\r\n                }\r\n            });\r\n    }\r\n\r\n    /**\r\n     * setup task works.\r\n     * \r\n     * @param {ITaskContext} context\r\n     * @param {Gulp} [gulp]\r\n     * @returns {TaskResult}\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    setup(context: ITaskContext, gulp?: Gulp): TaskResult {\r\n        gulp = gulp || coregulp;\r\n        // let option = this.getOption(context);\r\n        let tk = context.subTaskName(this.getInfo());\r\n        console.log(`register ${this.name || ''} task:`, chalk.cyan(tk));\r\n\r\n        gulp.task(tk, () => {\r\n            return this.execute(context, gulp);\r\n        });\r\n\r\n        this.info.taskName = tk;\r\n\r\n        return tk;\r\n    }\r\n}\r\n"]}