{"version":3,"sources":["PipeTask.ts"],"names":["TaskConfig_1","require","utils_1","coregulp","chalk","_","PipeTask","info","this","runWay","RunWay","parallel","operateFileds","name","prototype","getInfo","source","ctx","dist","gulp","option","isFunction","loader","src","getSrc","pipes","filter","p","opps","length","concat","output","isString","isArray","stream","pipe","dest","getDist","customPipe","prsrc","oper","_this","cfgopt","getTransformOperate","cpipe2Promise","then","setTransformOperate","getOption","context","match","trsOperate","isOutput","matchOperate","endsWith","toStr","to","noneOutput","nonePipe","opt","Promise","resolve","reject","ps","err","pick","operate","each","n","isUndefined","pipes2Promise","taskName","all","map","toTransform","trs","tanseq","tans","sortOrder","it","order","transformSourcePipe","transformPipe","output2Promise","outputs","once","result","removeAllListeners","working","psrc","catch","console","log","red","process","exit","execute","st","sequence","pthen_1","setup","tk","cyan","task","exports"],"mappings":"mEACA,IAAAA,cAAAC,QAAA,gBACAC,QAAAD,QAAA,WACAE,SAAAF,QAAA,QACAG,MAAAH,QAAA,SACAI,EAAAJ,QAAA,UAoEAK,SAAA,WAgBI,QAAAA,GAAYC,GAVLC,KAAAC,OAAST,aAAAU,OAAOC,SAmPbH,KAAAI,eAAiB,OAAQ,OAAQ,QAAS,WAAY,cAxO5DJ,KAAKD,KAAOA,MACZC,KAAKD,KAAKM,KAAOL,KAAKD,KAAKM,MAAQL,KAAKK,KA0chD,MA/bWP,GAAAQ,UAAAC,QAAP,WAII,MAHKP,MAAKD,KAAKM,OACXL,KAAKD,KAAKM,KAAOL,KAAKK,MAEnBL,KAAKD,MAahBD,EAAAQ,UAAAE,OAAA,SAAOC,EAAmBC,EAAmBC,GACzC,GAAIC,GAASH,EAAIG,MACjB,IAAIA,EAAOJ,OACP,MAAOX,GAAEgB,WAAWD,EAAOJ,QAAUI,EAAOJ,OAAOC,EAAKC,EAAMC,GAAQC,EAAOJ,MAEjF,IAAIM,GAAsBF,EAAe,MACzC,OAAIE,IAAUF,EAAOJ,OACVX,EAAEgB,WAAWC,EAAON,QAAUM,EAAON,OAAOC,EAAKC,EAAMC,GAAQG,EAAON,OAE1EG,EAAKI,IAAIN,EAAIO,OAAOhB,KAAKO,aAepCT,EAAAQ,UAAAW,MAAA,SAAMR,EAAmBC,EAAmBC,GACxC,GAAIC,GAASH,EAAIG,OACbK,EAAgB,KAChBH,EAAsBF,EAAe,MAKzC,IAJIE,GAAUjB,EAAEgB,WAAWC,EAAOG,SAC9BA,EAAQpB,EAAEgB,WAAWC,EAAOG,OAASH,EAAOG,MAAMR,EAAKG,EAAQD,GAAQd,EAAEqB,OAAeJ,EAAOG,MAAO,SAAAE,GAAK,MAAAA,MAG3GP,EAAOK,MAAO,CACd,GAAIG,GAAOvB,EAAEgB,WAAWD,EAAOK,OAASL,EAAOK,MAAMR,EAAKG,EAAQD,GAAQd,EAAEqB,OAAeN,EAAOK,MAAO,SAAAE,GAAK,MAAAA,IAC1GC,IAAQA,EAAKC,OAAS,IACtBJ,EAAQA,EAAQA,EAAMK,OAAOF,GAAQA,GAG7C,MAAOH,QAaXnB,EAAAQ,UAAAiB,OAAA,SAAOd,EAAmBC,EAAmBC,GACzC,GAAIC,GAASH,EAAIG,OACbK,EAAsB,KACtBH,EAAsBF,EAAe,MACzC,IAAIE,IAAWjB,EAAE2B,SAASV,KAAYjB,EAAE4B,QAAQX,GAC5C,GAAIA,EAAOS,OACPN,EAAQpB,EAAEgB,WAAWC,EAAOS,QAAUT,EAAOS,OAAOd,EAAKG,EAAQD,GAAQd,EAAEqB,OAAqBJ,EAAOG,MAAO,SAAAE,GAAK,MAAAA,SAChH,IAAsB,OAAlBL,EAAOS,OACd,OAAQ,SAACG,GAAW,MAAAA,IAG5B,IAAId,EAAOW,OAAQ,CACf,GAAIH,GAAOvB,EAAEgB,WAAWD,EAAOW,QAAUX,EAAOW,OAAOd,EAAKG,EAAQD,GAAQd,EAAEqB,OAAqBN,EAAOW,OAAQ,SAAAJ,GAAK,MAAAA,IACnHC,IAAQA,EAAKC,OAAS,IACtBJ,EAAQA,EAAQA,EAAMK,OAAOF,GAAQA,OAEtC,IAAsB,OAAlBR,EAAOW,OACd,OAAQ,SAACG,GAAW,MAAAA,IAGxB,OAAOT,KAAU,SAACS,GAAW,MAAAA,GAAOC,KAAKhB,EAAKiB,KAAKnB,EAAIoB,QAAQnB,QAezDZ,EAAAQ,UAAAwB,WAAV,SAAqBtB,EAAoBC,EAAmBC,EAAmBC,GAA/E,GAGQoB,GACAC,EAJRC,EAAAjC,KACQkC,EAASzB,EAAIG,OACbE,EAAsBoB,EAAe,MAiBzC,OAdIA,GAAOP,OACPK,EAAOhC,KAAKmC,oBAAoB3B,GAChCuB,EAAQ/B,KAAKoC,cAAc5B,EAAQ0B,EAAQzB,EAAKC,EAAMC,IAEtDG,IAAWjB,EAAE2B,SAASV,KAAYjB,EAAE4B,QAAQX,IAAWA,EAAOa,OAC9DK,EAAOhC,KAAKmC,oBAAoB3B,GAChCuB,EAAQA,EACJA,EAAMM,KAAK,SAAAX,GAEP,MADAO,GAAKK,oBAAoBZ,EAAQM,GAC1BC,EAAKG,cAAcV,EAAQZ,EAAQL,EAAKC,EAAMC,KAEvDX,KAAKoC,cAAc5B,EAAQM,EAAQL,EAAKC,EAAMC,IAGpDoB,EACOA,EAAMM,KAAK,SAAAX,GAEd,MADAO,GAAKK,oBAAoBZ,EAAQM,GAC1BN,IAIRlB,GAYDV,EAAAQ,UAAAiC,UAAV,SAAoBC,GAChB,MAAOA,GAAQ5B,QAgBTd,EAAAQ,UAAAmC,MAAV,SAAgBtB,EAAad,EAAcI,EAAmBiC,EAAuBC,GAEjF,MAFiF,UAAAA,IAAAA,GAAA,GAE1E3C,KAAK4C,aAAazB,EAAGd,EAAMI,EAAKkC,IAAcD,GAAc1C,KAAK4C,aAAaF,EAAYrC,EAAMI,EAAKkC,IAUtG7C,EAAAQ,UAAAsC,aAAV,SAAuBzB,EAAad,EAAcI,EAAmBkC,GACjE,MADiE,UAAAA,IAAAA,GAAA,KAC5DxB,MAGDA,EAAEd,OAASA,EAAKwC,SAASpC,EAAIqC,MAAM3B,EAAEd,YAIrCc,EAAEa,OAASvB,EAAIsC,GAAG5B,EAAEa,MAAQvB,EAAIuB,OAAS,OAIzCW,GAAYxB,EAAE6B,cAAe,OAErBL,GAAYxB,EAAE8B,YAAa,OAoBjCnD,EAAAQ,UAAA8B,cAAV,SAAwB5B,EAAoB0C,EAAkBV,EAAuB9B,EAAmBC,GACpG,MAAO,IAAIwC,SAAoB,SAACC,EAASC,GACrC,GAAIC,GAAKJ,EAAIvB,KAAKnB,EAAQgC,EAAS9B,EAAMC,EAAM,SAAC4C,GACxCA,EACAF,EAAOE,GAEPH,KAGJE,IACAH,QAAQC,QAAQE,GAAIjB,KAAKe,EAASC,MAgBpCvD,EAAAQ,UAAA6B,oBAAV,SAA8B3B,GAC1B,MAAOX,GAAE2D,KAAKhD,EAAQR,KAAKI,gBAarBN,EAAAQ,UAAAgC,oBAAV,SAA8B9B,EAAoBiD,GACzCjD,GAILX,EAAE6D,KAAK1D,KAAKI,cAAe,SAAAuD,GAClB9D,EAAE+D,YAAYH,EAAQE,MACvBnD,EAAOmD,GAAKF,EAAQE,OAkBtB7D,EAAAQ,UAAAuD,cAAV,SAAwBrD,EAAoBC,EAAmBC,EAAmBC,EAAYM,GAA9F,GAAAgB,GAAAjC,KACQK,EAAOI,EAAIqD,SAASpD,EAAMV,KAAKK,MAC/B2B,EAAOhC,KAAKmC,oBAAoB3B,EACpC,OAAKR,MAAKyC,MAAMT,EAAM3B,EAAMI,GAGrB0C,QAAQY,IAAIlE,EAAEmE,IAAI/C,GAASjB,KAAKiB,MAAMR,EAAKC,EAAMC,GAAO,SAACQ,GAC5D,MAAItB,GAAEgB,WAAWM,GACNA,EAAEV,EAAKC,EAAMC,GAEfsB,EAAKQ,MAAMtB,EAAGd,EAAMI,GAGd0C,QAAQC,QAAQjC,EAAE8C,YAAYxD,EAAKC,EAAMC,IAC3C0B,KAAK,SAAA6B,GAGF,MAFAjC,GAAKK,oBAAoB4B,EAAK/C,GAEvB+C,IANR,QAWd7B,KAAK,SAAA8B,GAEF,GAAIC,GAAO1E,QAAA2E,UAAsBF,EAAQ,SAAAG,GAAM,MAAAA,GAAGC,OAAO9D,GAAK,EAgB9D,OAdAZ,GAAE6D,KAAKU,EAAM,SAAC1C,GACLO,EAAKQ,MAAMf,EAAQrB,EAAMI,EAAKuB,KAK/BxB,EADAX,EAAEgB,WAAWa,EAAO8C,qBACX9C,EAAO8C,oBAAoBhE,GAC7BX,EAAEgB,WAAWL,EAAOiE,eAClBjE,EAAOiE,cAAc/C,GAErBlB,EAAOmB,KAAKD,MAG7BO,EAAKK,oBAAoB9B,EAAQwB,GAC1BxB,IApCJ2C,QAAQC,QAAQ5C,IAqDrBV,EAAAQ,UAAAoE,eAAV,SAAyBlE,EAAoBgC,EAAuB9B,EAAmBC,EAAYY,GAAnG,GAAAU,GAAAjC,KACQK,EAAOmC,EAAQsB,SAASpD,EAAMV,KAAKK,MACnC2B,EAAOhC,KAAKmC,oBAAoB3B,GAChCmE,EAAUpD,GAAUvB,KAAKuB,OAAOiB,EAAS9B,EAAMC,EACnD,OAAOwC,SAAQY,IAAIlE,EAAEmE,IAAIW,EAAS,SAAApD,GAC9B,MAAI1B,GAAEgB,WAAWU,GACNA,EAAOf,EAAQgC,EAAS9B,EAAMC,GAEhCsB,EAAKQ,MAAMlB,EAAQlB,EAAMmC,EAASR,GAAM,GAGlCT,EAAO0C,YAAYzD,EAAQgC,EAAS9B,EAAMC,GAF1C,QAMd0B,KAAK,SAAAsC,GACF,MAAOxB,SAAQY,IAAIlE,EAAEmE,IAAIW,EAAS,SAAApD,GAC9B,MAAO,IAAI4B,SAAQ,SAACC,EAASC,GACrB9B,EACAA,EACKqD,KAAK,MAAO,WACTxB,EAAQ7B,KAEXqD,KAAK,QAASvB,GAEnBD,MAELf,KAAK,SAAAwC,GAGJ,MAFAtD,GAAOuD,mBAAmB,SAC1BvD,EAAOuD,mBAAmB,OACnBD,UAoBjB/E,EAAAQ,UAAAyE,QAAV,SAAkBvE,EAAoBC,EAAmBG,EAAqBD,EAAYM,EAAgBM,GAA1G,GAAAU,GAAAjC,IACI,OAAOmD,SAAQC,QAAQ5C,GAClB6B,KAAK,SAAA2C,GAAQ,MAAA/C,GAAKH,WAAWkD,EAAMvE,EAAKG,EAAQD,KAChD0B,KAAK,SAAA2C,GAAQ,MAAA/C,GAAK4B,cAAcmB,EAAMvE,EAAKG,EAAQD,EAAMM,KACzDoB,KAAK,SAAA2C,GAAQ,MAAA/C,GAAKyC,eAAeM,EAAMvE,EAAKG,EAAQD,EAAMY,KAC1D0D,MAAM,SAAA1B,GACH2B,QAAQC,IAAIvF,MAAMwF,IAAI7B,IACtB8B,QAAQC,KAAK,MAazBxF,EAAAQ,UAAAiF,QAAA,SAAQ/C,EAAuB7B,GAA/B,GAAAsB,GAAAjC,KACQY,EAASZ,KAAKuC,UAAUC,EAC5B,OAAOW,SAAQC,QAAQpD,KAAKQ,OAAOgC,EAAS5B,EAAQD,IAC/C0B,KAAK,SAAAX,GACF,GAAI7B,EAAE4B,QAAQC,GAAS,CACnB,GAAIO,EAAKhC,SAAWT,aAAAU,OAAOC,SACvB,MAAOgD,SAAQY,IAAIlE,EAAEmE,IAAItC,EAAQ,SAAA8D,GAAM,MAAAvD,GAAK8C,QAAQS,EAAIhD,EAAS5B,EAAQD,KACtE,IAAIsB,EAAKhC,SAAWT,aAAAU,OAAOuF,SAAU,CACxC,GAAIC,EAUJ,OATA7F,GAAE6D,KAAKhC,EAAQ,SAAA8D,GAIPE,EAHCA,EAGOA,EAAMrD,KAAK,WACf,MAAOJ,GAAK8C,QAAQS,EAAIhD,EAAS5B,EAAQD,KAHrCsB,EAAK8C,QAAQS,EAAIhD,EAAS5B,EAAQD,KAO3C+E,EAEP,MAAOvC,SAAQE,OAAO,yBAG1B,MAAOpB,GAAK8C,QAAQrD,EAAQc,EAAS5B,EAAQD,MAc7Db,EAAAQ,UAAAqF,MAAA,SAAMnD,EAAuB7B,GAA7B,GAAAsB,GAAAjC,IACIW,GAAOA,GAAQhB,QAEf,IAAIiG,GAAKpD,EAAQsB,SAAS9D,KAAKO,UAS/B,OARA2E,SAAQC,IAAI,aAAYnF,KAAKK,MAAQ,IAAE,SAAUT,MAAMiG,KAAKD,IAE5DjF,EAAKmF,KAAKF,EAAI,WACV,MAAO3D,GAAKsD,QAAQ/C,EAAS7B,KAGjCX,KAAKD,KAAK+D,SAAW8B,EAEdA,GAEf9F,IA5dsBiG,SAAAjG,SAAAA","file":"../PipeTask.js","sourcesContent":["import { Gulp } from 'gulp';\r\nimport { TransformSource, RunWay, IAssertDist, ITaskInfo, TaskResult, ITaskContext, IOperate, ICustomPipe, Pipe, OutputPipe, ITask, ITransform, IPipeOption } from './TaskConfig';\r\nimport { sortOrder } from './utils';\r\nimport * as coregulp from 'gulp';\r\nimport * as chalk from 'chalk';\r\nimport * as _ from 'lodash';\r\n\r\n/**\r\n * pipe task.\r\n *\r\n * @export\r\n * @interface IPipeWork\r\n */\r\nexport interface IPipeTask extends ITask {\r\n    /**\r\n     * task default name.\r\n     *\r\n     * @type {string}\r\n     * @memberOf IPipeTask\r\n     */\r\n    name: string;\r\n    /**\r\n     * gulp src stream.\r\n     *\r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} gulp\r\n     * @returns {(TransformSource | Promise<TransformSource>)}\r\n     *\r\n     * @memberOf IPipeTask\r\n     */\r\n    source(context: ITaskContext, dist: IAssertDist, gulp: Gulp): TransformSource | Promise<TransformSource>;\r\n    /**\r\n     * task pipe works.\r\n     *\r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} [gulp]\r\n     * @returns {Pipe[]}\r\n     *\r\n     * @memberOf IPipeTask\r\n     */\r\n    pipes(context: ITaskContext, dist: IAssertDist, gulp?: Gulp): Pipe[];\r\n\r\n    /**\r\n     * output pipes.\r\n     *\r\n     * @param {ITaskContext} [context]\r\n     * @param {Gulp} [gulp]\r\n     * @returns {OutputPipe[]}\r\n     *\r\n     * @memberOf IPipeTask\r\n     */\r\n    output(context: ITaskContext, dist: IAssertDist, gulp?: Gulp): OutputPipe[];\r\n    /**\r\n     * execute task works.\r\n     *\r\n     * @param {ITaskContext} context\r\n     * @param {Gulp} gulp\r\n     * @returns {Promise<any>}\r\n     *\r\n     * @memberOf IPipeTask\r\n     */\r\n    execute(context: ITaskContext, gulp: Gulp): Promise<any>;\r\n}\r\n\r\n/**\r\n * Task base class.\r\n *\r\n * @export\r\n * @class Task\r\n * @implements {ITask}\r\n */\r\nexport abstract class PipeTask implements IPipeTask {\r\n    /**\r\n     * run mutil source stream way. default parallel.\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    public runWay = RunWay.parallel;\r\n    /**\r\n     * task default name.\r\n     *\r\n     * @type {string}\r\n     * @memberOf PipeTask\r\n     */\r\n    name: string;\r\n\r\n\r\n    constructor(info?: ITaskInfo) {\r\n        this.info = info || {};\r\n        this.info.name = this.info.name || this.name;\r\n    }\r\n\r\n    protected info: ITaskInfo;\r\n\r\n    /**\r\n     * get task info.\r\n     *\r\n     * @type {ITaskInfo}\r\n     * @memberOf PipeTask\r\n     */\r\n    public getInfo(): ITaskInfo {\r\n        if (!this.info.name) {\r\n            this.info.name = this.name;\r\n        }\r\n        return this.info;\r\n    }\r\n\r\n    /**\r\n     * source streams.\r\n     *\r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} option\r\n     * @param {Gulp} gulp\r\n     * @returns {(TransformSource | Promise<TransformSource>)}\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    source(ctx: ITaskContext, dist: IAssertDist, gulp: Gulp): TransformSource | Promise<TransformSource> {\r\n        let option = ctx.option;\r\n        if (option.source) {\r\n            return _.isFunction(option.source) ? option.source(ctx, dist, gulp) : option.source;\r\n        }\r\n        let loader = <IPipeOption>option['loader'];\r\n        if (loader && option.source) {\r\n            return _.isFunction(loader.source) ? loader.source(ctx, dist, gulp) : loader.source;\r\n        }\r\n        return gulp.src(ctx.getSrc(this.getInfo()));\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * task pipe works.\r\n     *\r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} [gulp]\r\n     * @returns {Pipe[]}\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    pipes(ctx: ITaskContext, dist: IAssertDist, gulp?: Gulp): Pipe[] {\r\n        let option = ctx.option;\r\n        let pipes: Pipe[] = null;\r\n        let loader = <IPipeOption>option['loader'];\r\n        if (loader && _.isFunction(loader.pipes)) {\r\n            pipes = _.isFunction(loader.pipes) ? loader.pipes(ctx, option, gulp) : _.filter(<Pipe[]>loader.pipes, p => p);\r\n        }\r\n\r\n        if (option.pipes) {\r\n            let opps = _.isFunction(option.pipes) ? option.pipes(ctx, option, gulp) : _.filter(<Pipe[]>option.pipes, p => p);\r\n            if (opps && opps.length > 0) {\r\n                pipes = pipes ? pipes.concat(opps) : opps;\r\n            }\r\n        }\r\n        return pipes || [];\r\n    }\r\n\r\n    /**\r\n     * output pipes.\r\n     *\r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} [gulp]\r\n     * @returns {OutputPipe[]}\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    output(ctx: ITaskContext, dist: IAssertDist, gulp?: Gulp): OutputPipe[] {\r\n        let option = ctx.option;\r\n        let pipes: OutputPipe[] = null;\r\n        let loader = <IPipeOption>option['loader'];\r\n        if (loader && !_.isString(loader) && !_.isArray(loader)) {\r\n            if (loader.output) {\r\n                pipes = _.isFunction(loader.output) ? loader.output(ctx, option, gulp) : _.filter(<OutputPipe[]>loader.pipes, p => p);\r\n            } else if (loader.output === null) {\r\n                return [(stream) => stream];\r\n            }\r\n        }\r\n        if (option.output) {\r\n            let opps = _.isFunction(option.output) ? option.output(ctx, option, gulp) : _.filter(<OutputPipe[]>option.output, p => p);\r\n            if (opps && opps.length > 0) {\r\n                pipes = pipes ? pipes.concat(opps) : opps;\r\n            }\r\n        } else if (option.output === null) {\r\n            return [(stream) => stream];\r\n        }\r\n\r\n        return pipes || [(stream) => stream.pipe(gulp.dest(ctx.getDist(dist)))]\r\n    }\r\n\r\n    /**\r\n     *  custom pipe Promise.\r\n     *\r\n     * @protected\r\n     * @param {ITransform} source\r\n     * @param {ITaskContext} ctx\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} gulp\r\n     * @returns\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    protected customPipe(source: ITransform, ctx: ITaskContext, dist: IAssertDist, gulp: Gulp): ITransform | Promise<ITransform> {\r\n        let cfgopt = ctx.option;\r\n        let loader = <IPipeOption>cfgopt['loader'];\r\n        let prsrc: Promise<ITransform>;\r\n        let oper;\r\n        if (cfgopt.pipe) {\r\n            oper = this.getTransformOperate(source);\r\n            prsrc = this.cpipe2Promise(source, cfgopt, ctx, dist, gulp);\r\n        }\r\n        if (loader && !_.isString(loader) && !_.isArray(loader) && loader.pipe) {\r\n            oper = this.getTransformOperate(source);\r\n            prsrc = prsrc ?\r\n                prsrc.then(stream => {\r\n                    this.setTransformOperate(stream, oper);\r\n                    return this.cpipe2Promise(stream, loader, ctx, dist, gulp)\r\n                })\r\n                : this.cpipe2Promise(source, loader, ctx, dist, gulp);\r\n        }\r\n\r\n        if (prsrc) {\r\n            return prsrc.then(stream => {\r\n                this.setTransformOperate(stream, oper);\r\n                return stream;\r\n            });\r\n        }\r\n\r\n        return source;\r\n    }\r\n\r\n    /**\r\n     * get option.\r\n     *\r\n     * @protected\r\n     * @param {ITaskContext} context\r\n     * @returns {IAssertDist}\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    protected getOption(context: ITaskContext): IAssertDist {\r\n        return context.option;\r\n    }\r\n\r\n    /**\r\n     * match pipe Operate\r\n     *\r\n     * @protected\r\n     * @param {IOperate} p\r\n     * @param {string} name\r\n     * @param {ITaskContext} ctx\r\n     * @param {IOperate} [trsOperate]\r\n     * @param {boolean} [isOutput=false]\r\n     * @returns\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    protected match(p: IOperate, name: string, ctx: ITaskContext, trsOperate?: IOperate, isOutput = false) {\r\n        // return this.matchOperate(p, name, ctx, isOutput) && (!trsOperate || (trsOperate && this.matchOperate(trsOperate, name, ctx, isOutput)));\r\n        return this.matchOperate(p, name, ctx, isOutput) || (trsOperate && this.matchOperate(trsOperate, name, ctx, isOutput));\r\n    }\r\n\r\n    /**\r\n     * match operate.\r\n     * @param p\r\n     * @param name\r\n     * @param ctx\r\n     * @param isOutput\r\n     */\r\n    protected matchOperate(p: IOperate, name: string, ctx: ITaskContext, isOutput = false) {\r\n        if (!p) {\r\n            return false;\r\n        }\r\n        if (p.name && !name.endsWith(ctx.toStr(p.name))) {\r\n            return false;\r\n        }\r\n\r\n        if (p.oper && (ctx.to(p.oper) & ctx.oper) <= 0) {\r\n            return false;\r\n        }\r\n\r\n        if (isOutput && p.noneOutput === true) {\r\n            return false;\r\n        } else if (!isOutput && p.nonePipe === true) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * convert custom pipe result to Promise.\r\n     *\r\n     * @protected\r\n     * @param {ITransform} source\r\n     * @param {ICustomPipe} opt\r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} gulp\r\n     * @returns\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    protected cpipe2Promise(source: ITransform, opt: ICustomPipe, context: ITaskContext, dist: IAssertDist, gulp: Gulp) {\r\n        return new Promise<ITransform>((resolve, reject) => {\r\n            let ps = opt.pipe(source, context, dist, gulp, (err) => {\r\n                if (err) {\r\n                    reject(err);\r\n                } else {\r\n                    resolve();\r\n                }\r\n            });\r\n            if (ps) {\r\n                Promise.resolve(ps).then(resolve, reject);\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n    protected operateFileds = ['name', 'oper', 'order', 'nonePipe', 'noneOutput'];\r\n    /**\r\n     * get transform Operate.\r\n     *\r\n     * @protected\r\n     * @param {ITransform} source\r\n     * @returns {IOperate}\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    protected getTransformOperate(source: ITransform): IOperate {\r\n        return _.pick(source, this.operateFileds) as IOperate;\r\n    }\r\n\r\n    /**\r\n     * set transform Operate.\r\n     *\r\n     * @protected\r\n     * @param {ITransform} source\r\n     * @param {IOperate} operate\r\n     * @returns\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    protected setTransformOperate(source: ITransform, operate: IOperate) {\r\n        if (!source) {\r\n            return;\r\n        }\r\n\r\n        _.each(this.operateFileds, n => {\r\n            if (!_.isUndefined(operate[n])) {\r\n                source[n] = operate[n];\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * covert pipes transform to Promise.\r\n     *\r\n     * @protected\r\n     * @param {ITransform} source\r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} gulp\r\n     * @param {Pipe[]} [pipes]\r\n     * @returns\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    protected pipes2Promise(source: ITransform, ctx: ITaskContext, dist: IAssertDist, gulp: Gulp, pipes?: Pipe[]) {\r\n        let name = ctx.taskName(dist, this.name);\r\n        let oper = this.getTransformOperate(source);\r\n        if (!this.match(oper, name, ctx)) {\r\n            return Promise.resolve(source);\r\n        }\r\n        return Promise.all(_.map(pipes || this.pipes(ctx, dist, gulp), (p: Pipe) => {\r\n            if (_.isFunction(p)) {\r\n                return p(ctx, dist, gulp);\r\n            } else {\r\n                if (!this.match(p, name, ctx)) {\r\n                    return null;\r\n                } else {\r\n                    return Promise.resolve(p.toTransform(ctx, dist, gulp))\r\n                        .then(trs => {\r\n                            this.setTransformOperate(trs, p);\r\n                            // trs.order = p.order;\r\n                            return trs;\r\n                        });\r\n                }\r\n            }\r\n        }))\r\n            .then(tanseq => {\r\n\r\n                let tans = sortOrder<ITransform>(tanseq, it => it.order, ctx, true);\r\n\r\n                _.each(tans, (stream: ITransform) => {\r\n                    if (!this.match(stream, name, ctx, oper)) {\r\n                        return;\r\n                    }\r\n\r\n                    if (_.isFunction(stream.transformSourcePipe)) {\r\n                        source = stream.transformSourcePipe(source);\r\n                    } else if (_.isFunction(source.transformPipe)) {\r\n                        source = source.transformPipe(stream);\r\n                    } else {\r\n                        source = source.pipe(stream);\r\n                    }\r\n                });\r\n                this.setTransformOperate(source, oper);\r\n                return source;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * output pipes transform to Promise.\r\n     *\r\n     * @protected\r\n     * @param {ITransform} source\r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} gulp\r\n     * @param {OutputPipe[]} [output]\r\n     * @returns\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    protected output2Promise(source: ITransform, context: ITaskContext, dist: IAssertDist, gulp: Gulp, output?: OutputPipe[]) {\r\n        let name = context.taskName(dist, this.name);\r\n        let oper = this.getTransformOperate(source);\r\n        let outputs = output || this.output(context, dist, gulp);\r\n        return Promise.all(_.map(outputs, output => {\r\n            if (_.isFunction(output)) {\r\n                return output(source, context, dist, gulp);\r\n            } else {\r\n                if (!this.match(output, name, context, oper, true)) {\r\n                    return null;\r\n                } else {\r\n                    return output.toTransform(source, context, dist, gulp);\r\n                }\r\n            }\r\n        }))\r\n            .then(outputs => {\r\n                return Promise.all(_.map(outputs, output => {\r\n                    return new Promise((resolve, reject) => {\r\n                        if (output) {\r\n                            output\r\n                                .once('end', () => {\r\n                                    resolve(output);\r\n                                })\r\n                                .once('error', reject);\r\n                        } else {\r\n                            resolve();\r\n                        }\r\n                    }).then(result => {\r\n                        output.removeAllListeners('error');\r\n                        output.removeAllListeners('end');\r\n                        return result;\r\n                    });\r\n                }));\r\n            })\r\n    }\r\n\r\n    /**\r\n     * each one source stream works.\r\n     *\r\n     * @protected\r\n     * @param {ITransform} source\r\n     * @param {ITaskContext} ctx\r\n     * @param {IAssertDist} option\r\n     * @param {Gulp} gulp\r\n     * @param {Pipe[]} [pipes]\r\n     * @param {OutputPipe[]} [output]\r\n     * @returns\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    protected working(source: ITransform, ctx: ITaskContext, option: IAssertDist, gulp: Gulp, pipes?: Pipe[], output?: OutputPipe[]) {\r\n        return Promise.resolve(source)\r\n            .then(psrc => this.customPipe(psrc, ctx, option, gulp))\r\n            .then(psrc => this.pipes2Promise(psrc, ctx, option, gulp, pipes))\r\n            .then(psrc => this.output2Promise(psrc, ctx, option, gulp, output))\r\n            .catch(err => {\r\n                console.log(chalk.red(err));\r\n                process.exit(0);\r\n            });\r\n    }\r\n\r\n    /**\r\n     * execute task working\r\n     *\r\n     * @param {ITaskContext} context\r\n     * @param {Gulp} gulp\r\n     * @returns {Promise<any>}\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    execute(context: ITaskContext, gulp: Gulp): Promise<any> {\r\n        let option = this.getOption(context);\r\n        return Promise.resolve(this.source(context, option, gulp))\r\n            .then(stream => {\r\n                if (_.isArray(stream)) {\r\n                    if (this.runWay === RunWay.parallel) {\r\n                        return Promise.all(_.map(stream, st => this.working(st, context, option, gulp)));\r\n                    } else if (this.runWay === RunWay.sequence) {\r\n                        let pthen: Promise<any>;\r\n                        _.each(stream, st => {\r\n                            if (!pthen) {\r\n                                pthen = this.working(st, context, option, gulp);\r\n                            } else {\r\n                                pthen = pthen.then(() => {\r\n                                    return this.working(st, context, option, gulp);\r\n                                });\r\n                            }\r\n                        });\r\n                        return pthen;\r\n                    } else {\r\n                        return Promise.reject('runWay setting error.');\r\n                    }\r\n                } else {\r\n                    return this.working(stream, context, option, gulp);\r\n                }\r\n            });\r\n    }\r\n\r\n    /**\r\n     * setup task works.\r\n     *\r\n     * @param {ITaskContext} context\r\n     * @param {Gulp} [gulp]\r\n     * @returns {TaskResult}\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    setup(context: ITaskContext, gulp?: Gulp): TaskResult {\r\n        gulp = gulp || coregulp;\r\n        // let option = this.getOption(context);\r\n        let tk = context.taskName(this.getInfo());\r\n        console.log(`register ${this.name || ''} task:`, chalk.cyan(tk));\r\n\r\n        gulp.task(tk, () => {\r\n            return this.execute(context, gulp);\r\n        });\r\n\r\n        this.info.taskName = tk;\r\n\r\n        return tk;\r\n    }\r\n}\r\n"]}