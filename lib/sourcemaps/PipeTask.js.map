{"version":3,"sources":["PipeTask.js","PipeTask.ts"],"names":["coregulp","require","chalk","_","PipeTask","info","_classCallCheck","this","decorator","config","dist","gulp","option","loader","isFunction","pipes","filter","p","name","isString","isArray","output","stream","pipe","dest","getDist","src","getSrc","endsWith","oper","source","_this","subTaskName","Promise","resolve","then","psrc","all","map","match","toTransform","trs","order","tans","len","length","orderBy","t","isNumber","each","transformSourcePipe","transformPipe","outputs","reject","once","catch","err","console","log","red","process","exit","_this2","getOption","tk","cyan","task","sourceStream","st","working","taskName","exports"],"mappings":"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","file":"../PipeTask.js","sourcesContent":["\"use strict\";\nconst coregulp = require('gulp');\nconst chalk = require('chalk');\nconst _ = require('lodash');\n/**\n * Task base class.\n *\n * @export\n * @class Task\n * @implements {ITask}\n */\nclass PipeTask {\n    constructor(info) {\n        this.decorator = info || {};\n    }\n    pipes(config, dist, gulp) {\n        let option = config.option;\n        let loader = option.loader;\n        if (loader && _.isFunction(loader.pipes)) {\n            return _.isFunction(loader.pipes) ? loader.pipes(config, option, gulp) : _.filter(loader.pipes, p => _.isFunction(p) || (p.name && p.name === dist.name));\n        }\n        else {\n            return [];\n        }\n    }\n    output(config, dist, gulp) {\n        let option = config.option;\n        let loader = option.loader;\n        if (loader && !_.isString(loader) && !_.isArray(loader)) {\n            if (loader.output) {\n                return _.isFunction(loader.output) ? loader.output(config, option, gulp) : _.filter(loader.pipes, p => _.isFunction(p) || (p.name && p.name === dist.name));\n            }\n            else if (loader.output === null) {\n                return [(stream) => stream];\n            }\n        }\n        return [(stream) => stream.pipe(gulp.dest(config.getDist(dist)))];\n    }\n    getOption(config) {\n        return config.option;\n    }\n    sourceStream(config, option, gulp) {\n        return gulp.src(config.getSrc(option, this.decorator));\n    }\n    /**\n     * match pipe Operate\n     *\n     * @param {IPipeOperate} p\n     * @param {string} name\n     * @param {ITaskConfig} config\n     * @returns\n     *\n     * @memberOf PipeTask\n     */\n    match(p, name, config) {\n        if (!p) {\n            return false;\n        }\n        if (p.name && !name.endsWith(name)) {\n            return false;\n        }\n        if (p.oper && (p.oper & config.oper) <= 0) {\n            return false;\n        }\n        return true;\n    }\n    working(source, config, option, gulp) {\n        let name = config.subTaskName(option, this.name);\n        return Promise.resolve(source)\n            .then(psrc => {\n            return Promise.all(_.map(this.pipes(config, option, gulp), (p) => {\n                if (_.isFunction(p)) {\n                    return p(config, option, gulp);\n                }\n                else {\n                    if (!this.match(p, name, config)) {\n                        return null;\n                    }\n                    else {\n                        return Promise.resolve(p.toTransform(config, option, gulp))\n                            .then(trs => {\n                            trs.order = p.order;\n                            // trs.oper = p.order;\n                            return trs;\n                        });\n                    }\n                }\n            }))\n                .then(tans => {\n                let len = tans.length;\n                tans = _.orderBy(_.filter(tans, t => t), t => {\n                    if (_.isArray(t)) {\n                        return len;\n                    }\n                    else {\n                        if (_.isNumber(t.order)) {\n                            return t.order;\n                        }\n                        return len;\n                    }\n                });\n                _.each(tans, stream => {\n                    if (!this.match(stream, name, config)) {\n                        return;\n                    }\n                    if (_.isFunction(stream.transformSourcePipe)) {\n                        psrc = stream.transformSourcePipe(psrc);\n                    }\n                    else if (_.isFunction(psrc.transformPipe)) {\n                        psrc = psrc.transformPipe(stream);\n                    }\n                    else {\n                        psrc = psrc.pipe(stream);\n                    }\n                });\n                return psrc;\n            });\n        })\n            .then(stream => {\n            let outputs = this.output(config, option, gulp);\n            return Promise.all(_.map(outputs, output => {\n                if (_.isFunction(output)) {\n                    return output(stream, config, option, gulp);\n                }\n                else {\n                    if (!this.match(output, name, config)) {\n                        return null;\n                    }\n                    else {\n                        return output.toTransform(stream, config, option, gulp);\n                    }\n                }\n            }));\n        }).then(outputs => {\n            return Promise.all(_.map(outputs, output => {\n                return new Promise((resolve, reject) => {\n                    if (output) {\n                        output\n                            .once('end', () => {\n                            resolve(output);\n                        })\n                            .once('error', reject);\n                    }\n                    else {\n                        resolve();\n                    }\n                });\n            }));\n        })\n            .catch(err => {\n            console.log(chalk.red(err));\n            process.exit(0);\n        });\n    }\n    setup(config, gulp) {\n        gulp = gulp || coregulp;\n        let option = this.getOption(config);\n        let tk = config.subTaskName(option, this.name);\n        console.log(`register ${this.name} task:`, chalk.cyan(tk));\n        gulp.task(tk, () => {\n            return Promise.resolve(this.sourceStream(config, option, gulp))\n                .then(stream => {\n                if (_.isArray(stream)) {\n                    return Promise.all(_.map(stream, st => this.working(st, config, option, gulp)));\n                }\n                else {\n                    return this.working(stream, config, option, gulp);\n                }\n            });\n        });\n        this.decorator.taskName = tk;\n        return tk;\n    }\n}\nexports.PipeTask = PipeTask;\n","import { Gulp } from 'gulp';\r\nimport { TransformSource, IAssertDist, ITaskInfo, TaskResult, ITaskConfig, IPipeOperate, Pipe, OutputPipe, ITask, ITransform, ILoaderOption } from './TaskConfig';\r\nimport * as coregulp from 'gulp';\r\nimport * as chalk from 'chalk';\r\nimport * as _ from 'lodash';\r\n\r\n/**\r\n * pipe task.\r\n * \r\n * @export\r\n * @interface IPipeWork\r\n */\r\nexport interface IPipeTask extends ITask {\r\n    /**\r\n     * task default name.\r\n     * \r\n     * @type {string}\r\n     * @memberOf IPipeTask\r\n     */\r\n    name: string;\r\n    /**\r\n     * gulp src stream.\r\n     * \r\n     * @param {ITaskConfig} config\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} gulp\r\n     * @returns {(TransformSource | Promise<TransformSource>)}\r\n     * \r\n     * @memberOf IPipeTask\r\n     */\r\n    sourceStream(config: ITaskConfig, dist: IAssertDist, gulp: Gulp): TransformSource | Promise<TransformSource>;\r\n    /**\r\n     * task pipe works.\r\n     * \r\n     * @param {ITaskConfig} config\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} [gulp]\r\n     * @returns {Pipe[]}\r\n     * \r\n     * @memberOf IPipeTask\r\n     */\r\n    pipes(config: ITaskConfig, dist: IAssertDist, gulp?: Gulp): Pipe[];\r\n\r\n    /**\r\n     * output pipes.\r\n     * \r\n     * @param {ITaskConfig} [config]\r\n     * @param {Gulp} [gulp]\r\n     * @returns {OutputPipe[]}\r\n     * \r\n     * @memberOf IPipeTask\r\n     */\r\n    output(config: ITaskConfig, dist: IAssertDist, gulp?: Gulp): OutputPipe[];\r\n    /**\r\n     * pipe task working.\r\n     * \r\n     * @param {ITransform} source\r\n     * @param {ITaskConfig} config\r\n     * @param {IAssertDist} option\r\n     * @param {Gulp} gulp\r\n     * @returns {Promise<any>}\r\n     * \r\n     * @memberOf IPipeTask\r\n     */\r\n    working(source: ITransform, config: ITaskConfig, option: IAssertDist, gulp: Gulp): Promise<any>;\r\n}\r\n\r\n/**\r\n * Task base class.\r\n * \r\n * @export\r\n * @class Task\r\n * @implements {ITask}\r\n */\r\nexport abstract class PipeTask implements IPipeTask {\r\n    /**\r\n     * task default name.\r\n     * \r\n     * @type {string}\r\n     * @memberOf PipeTask\r\n     */\r\n    name: string;\r\n    /**\r\n     * task info.\r\n     * \r\n     * @type {ITaskInfo}\r\n     * @memberOf PipeTask\r\n     */\r\n    public decorator: ITaskInfo;\r\n    constructor(info?: ITaskInfo) {\r\n        this.decorator = info || {};\r\n    }\r\n\r\n    pipes(config: ITaskConfig, dist: IAssertDist, gulp?: Gulp): Pipe[] {\r\n        let option = config.option;\r\n        let loader = <ILoaderOption>option.loader;\r\n        if (loader && _.isFunction(loader.pipes)) {\r\n            return _.isFunction(loader.pipes) ? loader.pipes(config, option, gulp) : _.filter(<Pipe[]>loader.pipes, p => _.isFunction(p) || (p.name && p.name === dist.name));\r\n        } else {\r\n            return [];\r\n        }\r\n    }\r\n\r\n    output(config: ITaskConfig, dist: IAssertDist, gulp?: Gulp): OutputPipe[] {\r\n        let option = config.option;\r\n        let loader = <ILoaderOption>option.loader;\r\n        if (loader && !_.isString(loader) && !_.isArray(loader)) {\r\n            if (loader.output) {\r\n                return _.isFunction(loader.output) ? loader.output(config, option, gulp) : _.filter(<OutputPipe[]>loader.pipes, p => _.isFunction(p) || (p.name && p.name === dist.name));\r\n            } else if (loader.output === null) {\r\n                return [(stream) => stream];\r\n            }\r\n        }\r\n\r\n        return [(stream) => stream.pipe(gulp.dest(config.getDist(dist)))]\r\n    }\r\n\r\n    protected getOption(config: ITaskConfig): IAssertDist {\r\n        return config.option;\r\n    }\r\n\r\n    sourceStream(config: ITaskConfig, option: IAssertDist, gulp: Gulp): TransformSource | Promise<TransformSource> {\r\n        return gulp.src(config.getSrc(option, this.decorator));\r\n    }\r\n\r\n    /**\r\n     * match pipe Operate\r\n     * \r\n     * @param {IPipeOperate} p\r\n     * @param {string} name\r\n     * @param {ITaskConfig} config\r\n     * @returns\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    protected match(p: IPipeOperate, name: string, config: ITaskConfig) {\r\n        if (!p) {\r\n            return false;\r\n        }\r\n        if (p.name && !name.endsWith(name)) {\r\n            return false;\r\n        }\r\n\r\n        if (p.oper && (p.oper & config.oper) <= 0) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    working(source: ITransform, config: ITaskConfig, option: IAssertDist, gulp: Gulp) {\r\n        let name = config.subTaskName(option, this.name);\r\n        return Promise.resolve(source)\r\n            .then(psrc => {\r\n                return Promise.all(_.map(this.pipes(config, option, gulp), (p: Pipe) => {\r\n                    if (_.isFunction(p)) {\r\n                        return p(config, option, gulp);\r\n                    } else {\r\n                        if (!this.match(p, name, config)) {\r\n                            return null;\r\n                        } else {\r\n                            return Promise.resolve(p.toTransform(config, option, gulp))\r\n                                .then(trs => {\r\n                                    trs.order = p.order;\r\n                                    // trs.oper = p.order;\r\n                                    return trs;\r\n                                });\r\n                        }\r\n                    }\r\n                }))\r\n                    .then(tans => {\r\n                        let len = tans.length;\r\n                        tans = _.orderBy(_.filter(tans, t => t), t => {\r\n                            if (_.isArray(t)) {\r\n                                return len;\r\n                            } else {\r\n                                if (_.isNumber(t.order)) {\r\n                                    return t.order;\r\n                                }\r\n                                return len;\r\n                            }\r\n                        });\r\n\r\n                        _.each(tans, stream => {\r\n                            if (!this.match(stream, name, config)) {\r\n                                return;\r\n                            }\r\n\r\n                            if (_.isFunction(stream.transformSourcePipe)) {\r\n                                psrc = stream.transformSourcePipe(psrc);\r\n                            } else if (_.isFunction(psrc.transformPipe)) {\r\n                                psrc = psrc.transformPipe(stream);\r\n                            } else {\r\n                                psrc = psrc.pipe(stream);\r\n                            }\r\n                        });\r\n                        return psrc;\r\n                    })\r\n            })\r\n            .then(stream => {\r\n                let outputs = this.output(config, option, gulp);\r\n                return Promise.all(_.map(outputs, output => {\r\n                    if (_.isFunction(output)) {\r\n                        return output(stream, config, option, gulp);\r\n                    } else {\r\n                        if (!this.match(output, name, config)) {\r\n                            return null;\r\n                        } else {\r\n                            return output.toTransform(stream, config, option, gulp);\r\n                        }\r\n                    }\r\n                }))\r\n            }).then(outputs => {\r\n                return Promise.all(_.map(outputs, output => {\r\n                    return new Promise((resolve, reject) => {\r\n                        if (output) {\r\n                            output\r\n                                .once('end', () => {\r\n                                    resolve(output);\r\n                                })\r\n                                .once('error', reject);\r\n                        } else {\r\n                            resolve();\r\n                        }\r\n                    });\r\n                }));\r\n            })\r\n            .catch(err => {\r\n                console.log(chalk.red(err));\r\n                process.exit(0);\r\n            });\r\n    }\r\n\r\n    setup(config: ITaskConfig, gulp?: Gulp): TaskResult {\r\n        gulp = gulp || coregulp;\r\n        let option = this.getOption(config);\r\n        let tk = config.subTaskName(option, this.name);\r\n\r\n        console.log(`register ${this.name} task:`, chalk.cyan(tk));\r\n\r\n        gulp.task(tk, () => {\r\n            return Promise.resolve(this.sourceStream(config, option, gulp))\r\n                .then(stream => {\r\n                    if (_.isArray(stream)) {\r\n                        return Promise.all(_.map(stream, st => this.working(st, config, option, gulp)));\r\n                    } else {\r\n                        return this.working(stream, config, option, gulp);\r\n                    }\r\n                })\r\n\r\n        });\r\n\r\n        this.decorator.taskName = tk;\r\n\r\n        return tk;\r\n    }\r\n}\r\n"]}