{"version":3,"sources":["PipeTask.ts"],"names":["TaskConfig_1","require","utils_1","coregulp","chalk","_","PipeTask","info","this","runWay","RunWay","parallel","operateFileds","name","prototype","getInfo","source","ctx","dist","gulp","option","isFunction","loader","src","getSrc","pipes","filter","p","opps","length","concat","output","isString","isArray","stream","pipe","dest","getDist","customPipe","prsrc","_this","cfgopt","oper","getTransformOperate","cpipe2Promise","then","setTransformOperate","getOption","context","match","trsOperate","isOutput","matchOperate","endsWith","toStr","noneOutput","nonePipe","opt","Promise","resolve","reject","ps","err","pick","operate","each","n","pipes2Promise","subTaskName","all","map","toTransform","trs","tanseq","tans","sortOrder","it","order","transformSourcePipe","transformPipe","output2Promise","outputs","once","result","removeAllListeners","working","psrc","catch","console","log","red","process","exit","execute","st","sequence","pthen_1","setup","tk","cyan","task","taskName","exports"],"mappings":"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","file":"../PipeTask.js","sourcesContent":["import { Gulp } from 'gulp';\r\nimport { TransformSource, RunWay, IAssertDist, ITaskInfo, TaskResult, ITaskContext, IOperate, ICustomPipe, Pipe, OutputPipe, ITask, ITransform, IPipeOption } from './TaskConfig';\r\nimport { sortOrder } from './utils';\r\nimport * as coregulp from 'gulp';\r\nimport * as chalk from 'chalk';\r\nimport * as _ from 'lodash';\r\n\r\n/**\r\n * pipe task.\r\n *\r\n * @export\r\n * @interface IPipeWork\r\n */\r\nexport interface IPipeTask extends ITask {\r\n    /**\r\n     * task default name.\r\n     *\r\n     * @type {string}\r\n     * @memberOf IPipeTask\r\n     */\r\n    name: string;\r\n    /**\r\n     * gulp src stream.\r\n     *\r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} gulp\r\n     * @returns {(TransformSource | Promise<TransformSource>)}\r\n     *\r\n     * @memberOf IPipeTask\r\n     */\r\n    source(context: ITaskContext, dist: IAssertDist, gulp: Gulp): TransformSource | Promise<TransformSource>;\r\n    /**\r\n     * task pipe works.\r\n     *\r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} [gulp]\r\n     * @returns {Pipe[]}\r\n     *\r\n     * @memberOf IPipeTask\r\n     */\r\n    pipes(context: ITaskContext, dist: IAssertDist, gulp?: Gulp): Pipe[];\r\n\r\n    /**\r\n     * output pipes.\r\n     *\r\n     * @param {ITaskContext} [context]\r\n     * @param {Gulp} [gulp]\r\n     * @returns {OutputPipe[]}\r\n     *\r\n     * @memberOf IPipeTask\r\n     */\r\n    output(context: ITaskContext, dist: IAssertDist, gulp?: Gulp): OutputPipe[];\r\n    /**\r\n     * execute task works.\r\n     *\r\n     * @param {ITaskContext} context\r\n     * @param {Gulp} gulp\r\n     * @returns {Promise<any>}\r\n     *\r\n     * @memberOf IPipeTask\r\n     */\r\n    execute(context: ITaskContext, gulp: Gulp): Promise<any>;\r\n}\r\n\r\n/**\r\n * Task base class.\r\n *\r\n * @export\r\n * @class Task\r\n * @implements {ITask}\r\n */\r\nexport abstract class PipeTask implements IPipeTask {\r\n    /**\r\n     * run mutil source stream way. default parallel.\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    public runWay = RunWay.parallel;\r\n    /**\r\n     * task default name.\r\n     *\r\n     * @type {string}\r\n     * @memberOf PipeTask\r\n     */\r\n    name: string;\r\n\r\n\r\n    constructor(info?: ITaskInfo) {\r\n        this.info = info || {};\r\n        this.info.name = this.info.name || this.name;\r\n    }\r\n\r\n    protected info: ITaskInfo;\r\n\r\n    /**\r\n     * get task info.\r\n     *\r\n     * @type {ITaskInfo}\r\n     * @memberOf PipeTask\r\n     */\r\n    public getInfo(): ITaskInfo {\r\n        if (!this.info.name) {\r\n            this.info.name = this.name;\r\n        }\r\n        return this.info;\r\n    }\r\n\r\n    /**\r\n     * source streams.\r\n     *\r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} option\r\n     * @param {Gulp} gulp\r\n     * @returns {(TransformSource | Promise<TransformSource>)}\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    source(ctx: ITaskContext, dist: IAssertDist, gulp: Gulp): TransformSource | Promise<TransformSource> {\r\n        let option = ctx.option;\r\n        if (option.source) {\r\n            return _.isFunction(option.source) ? option.source(ctx, dist, gulp) : option.source;\r\n        }\r\n        let loader = <IPipeOption>option['loader'];\r\n        if (loader && option.source) {\r\n            return _.isFunction(loader.source) ? loader.source(ctx, dist, gulp) : loader.source;\r\n        }\r\n        return gulp.src(ctx.getSrc(this.getInfo()));\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * task pipe works.\r\n     *\r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} [gulp]\r\n     * @returns {Pipe[]}\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    pipes(ctx: ITaskContext, dist: IAssertDist, gulp?: Gulp): Pipe[] {\r\n        let option = ctx.option;\r\n        let pipes: Pipe[] = null;\r\n        let loader = <IPipeOption>option['loader'];\r\n        if (loader && _.isFunction(loader.pipes)) {\r\n            pipes = _.isFunction(loader.pipes) ? loader.pipes(ctx, option, gulp) : _.filter(<Pipe[]>loader.pipes, p => p);\r\n        }\r\n\r\n        if (option.pipes) {\r\n            let opps = _.isFunction(option.pipes) ? option.pipes(ctx, option, gulp) : _.filter(<Pipe[]>option.pipes, p => p );\r\n            if (opps && opps.length > 0) {\r\n                pipes = pipes ? pipes.concat(opps) : opps;\r\n            }\r\n        }\r\n        return pipes || [];\r\n    }\r\n\r\n    /**\r\n     * output pipes.\r\n     *\r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} [gulp]\r\n     * @returns {OutputPipe[]}\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    output(ctx: ITaskContext, dist: IAssertDist, gulp?: Gulp): OutputPipe[] {\r\n        let option = ctx.option;\r\n        let pipes: OutputPipe[] = null;\r\n        let loader = <IPipeOption>option['loader'];\r\n        if (loader && !_.isString(loader) && !_.isArray(loader)) {\r\n            if (loader.output) {\r\n                pipes = _.isFunction(loader.output) ? loader.output(ctx, option, gulp) : _.filter(<OutputPipe[]>loader.pipes, p => p);\r\n            } else if (loader.output === null) {\r\n                return [(stream) => stream];\r\n            }\r\n        }\r\n        if (option.output) {\r\n            let opps = _.isFunction(option.output) ? option.output(ctx, option, gulp) : _.filter(<OutputPipe[]>option.output, p => p);\r\n            if (opps && opps.length > 0) {\r\n                pipes = pipes ? pipes.concat(opps) : opps;\r\n            }\r\n        } else if (option.output === null) {\r\n            return [(stream) => stream];\r\n        }\r\n\r\n        return pipes || [(stream) => stream.pipe(gulp.dest(ctx.getDist(dist)))]\r\n    }\r\n\r\n    /**\r\n     *  custom pipe Promise.\r\n     *\r\n     * @protected\r\n     * @param {ITransform} source\r\n     * @param {ITaskContext} ctx\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} gulp\r\n     * @returns\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    protected customPipe(source: ITransform, ctx: ITaskContext, dist: IAssertDist, gulp: Gulp): ITransform | Promise<ITransform> {\r\n        let cfgopt = ctx.option;\r\n        let loader = <IPipeOption>cfgopt['loader'];\r\n        let prsrc: Promise<ITransform>;\r\n        let oper = this.getTransformOperate(source);\r\n        if (cfgopt.pipe) {\r\n            prsrc = this.cpipe2Promise(source, cfgopt, ctx, dist, gulp);\r\n        }\r\n        if (loader && !_.isString(loader) && !_.isArray(loader) && loader.pipe) {\r\n            prsrc = prsrc ?\r\n                prsrc.then(stream => {\r\n                    this.setTransformOperate(stream, oper);\r\n                    return this.cpipe2Promise(stream, loader, ctx, dist, gulp)\r\n                })\r\n                : this.cpipe2Promise(source, loader, ctx, dist, gulp);\r\n        }\r\n\r\n        if (prsrc) {\r\n            return prsrc.then(stream => {\r\n                this.setTransformOperate(stream, oper);\r\n                return stream;\r\n            });\r\n        }\r\n\r\n        return source;\r\n    }\r\n\r\n    /**\r\n     * get option.\r\n     *\r\n     * @protected\r\n     * @param {ITaskContext} context\r\n     * @returns {IAssertDist}\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    protected getOption(context: ITaskContext): IAssertDist {\r\n        return context.option;\r\n    }\r\n\r\n    /**\r\n     * match pipe Operate\r\n     *\r\n     * @protected\r\n     * @param {IOperate} p\r\n     * @param {string} name\r\n     * @param {ITaskContext} ctx\r\n     * @param {IOperate} [trsOperate]\r\n     * @param {boolean} [isOutput=false]\r\n     * @returns\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    protected match(p: IOperate, name: string, ctx: ITaskContext, trsOperate?: IOperate, isOutput = false) {\r\n        // return this.matchOperate(p, name, ctx, isOutput) && (!trsOperate || (trsOperate && this.matchOperate(trsOperate, name, ctx, isOutput)));\r\n        return this.matchOperate(p, name, ctx, isOutput) || (trsOperate && this.matchOperate(trsOperate, name, ctx, isOutput));\r\n    }\r\n\r\n    /**\r\n     * match operate.\r\n     * @param p \r\n     * @param name \r\n     * @param ctx \r\n     * @param isOutput \r\n     */\r\n    protected matchOperate(p: IOperate, name: string, ctx: ITaskContext, isOutput = false) {\r\n        if (!p) {\r\n            return false;\r\n        }\r\n        if (p.name && !name.endsWith(ctx.toStr(p.name))) {\r\n            return false;\r\n        }\r\n\r\n        if (p.oper && (p.oper & ctx.oper) <= 0) {\r\n            return false;\r\n        }\r\n\r\n        if (isOutput && p.noneOutput === true) {\r\n            return false;\r\n        } else if (!isOutput && p.nonePipe === true) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * convert custom pipe result to Promise.\r\n     *\r\n     * @protected\r\n     * @param {ITransform} source\r\n     * @param {ICustomPipe} opt\r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} gulp\r\n     * @returns\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    protected cpipe2Promise(source: ITransform, opt: ICustomPipe, context: ITaskContext, dist: IAssertDist, gulp: Gulp) {\r\n        return new Promise<ITransform>((resolve, reject) => {\r\n            let ps = opt.pipe(source, context, dist, gulp, (err) => {\r\n                if (err) {\r\n                    reject(err);\r\n                } else {\r\n                    resolve();\r\n                }\r\n            });\r\n            if (ps) {\r\n                Promise.resolve(ps).then(resolve, reject);\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n    protected operateFileds = ['name', 'oper', 'order', 'nonePipe', 'noneOutput'];\r\n    /**\r\n     * get transform Operate.\r\n     *\r\n     * @protected\r\n     * @param {ITransform} source\r\n     * @returns {IOperate}\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    protected getTransformOperate(source: ITransform): IOperate {\r\n        return _.pick(source, this.operateFileds) as IOperate;\r\n    }\r\n\r\n    /**\r\n     * set transform Operate.\r\n     *\r\n     * @protected\r\n     * @param {ITransform} source\r\n     * @param {IOperate} operate\r\n     * @returns\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    protected setTransformOperate(source: ITransform, operate: IOperate) {\r\n        if (!source) {\r\n            return;\r\n        }\r\n\r\n        _.each(this.operateFileds, n => {\r\n            // if (!_.isUndefined(operate[n])) {\r\n            source[n] = operate[n];\r\n            // }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * covert pipes transform to Promise.\r\n     *\r\n     * @protected\r\n     * @param {ITransform} source\r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} gulp\r\n     * @param {Pipe[]} [pipes]\r\n     * @returns\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    protected pipes2Promise(source: ITransform, ctx: ITaskContext, dist: IAssertDist, gulp: Gulp, pipes?: Pipe[]) {\r\n        let name = ctx.subTaskName(dist, this.name);\r\n        let oper = this.getTransformOperate(source);\r\n        return Promise.all(_.map(pipes || this.pipes(ctx, dist, gulp), (p: Pipe) => {\r\n            if (_.isFunction(p)) {\r\n                return p(ctx, dist, gulp);\r\n            } else {\r\n                // if (!this.match(p, name, ctx)) {\r\n                //     return null;\r\n                // } else {\r\n                return Promise.resolve(p.toTransform(ctx, dist, gulp))\r\n                    .then(trs => {\r\n                        this.setTransformOperate(trs, p);\r\n                        // trs.order = p.order;\r\n                        return trs;\r\n                    });\r\n                // }\r\n            }\r\n        }))\r\n            .then(tanseq => {\r\n\r\n                let tans = sortOrder<ITransform>(tanseq, it => it.order, ctx, true);\r\n\r\n                _.each(tans, (stream: ITransform) => {\r\n                    if (!this.match(stream, name, ctx, oper)) {\r\n                        return;\r\n                    }\r\n\r\n                    if (_.isFunction(stream.transformSourcePipe)) {\r\n                        source = stream.transformSourcePipe(source);\r\n                    } else if (_.isFunction(source.transformPipe)) {\r\n                        source = source.transformPipe(stream);\r\n                    } else {\r\n                        source = source.pipe(stream);\r\n                    }\r\n                });\r\n                this.setTransformOperate(source, oper);\r\n                return source;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * output pipes transform to Promise.\r\n     *\r\n     * @protected\r\n     * @param {ITransform} source\r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} gulp\r\n     * @param {OutputPipe[]} [output]\r\n     * @returns\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    protected output2Promise(source: ITransform, context: ITaskContext, dist: IAssertDist, gulp: Gulp, output?: OutputPipe[]) {\r\n        let name = context.subTaskName(dist, this.name);\r\n        let oper = this.getTransformOperate(source);\r\n        let outputs = output || this.output(context, dist, gulp);\r\n        return Promise.all(_.map(outputs, output => {\r\n            if (_.isFunction(output)) {\r\n                return output(source, context, dist, gulp);\r\n            } else {\r\n                if (!this.match(output, name, context, oper, true)) {\r\n                    return null;\r\n                } else {\r\n                    return output.toTransform(source, context, dist, gulp);\r\n                }\r\n            }\r\n        }))\r\n            .then(outputs => {\r\n                return Promise.all(_.map(outputs, output => {\r\n                    return new Promise((resolve, reject) => {\r\n                        if (output) {\r\n                            output\r\n                                .once('end', () => {\r\n                                    resolve(output);\r\n                                })\r\n                                .once('error', reject);\r\n                        } else {\r\n                            resolve();\r\n                        }\r\n                    }).then(result => {\r\n                        output.removeAllListeners('error');\r\n                        output.removeAllListeners('end');\r\n                        return result;\r\n                    });\r\n                }));\r\n            })\r\n    }\r\n\r\n    /**\r\n     * each one source stream works.\r\n     *\r\n     * @protected\r\n     * @param {ITransform} source\r\n     * @param {ITaskContext} ctx\r\n     * @param {IAssertDist} option\r\n     * @param {Gulp} gulp\r\n     * @param {Pipe[]} [pipes]\r\n     * @param {OutputPipe[]} [output]\r\n     * @returns\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    protected working(source: ITransform, ctx: ITaskContext, option: IAssertDist, gulp: Gulp, pipes?: Pipe[], output?: OutputPipe[]) {\r\n        return Promise.resolve(source)\r\n            .then(psrc => this.customPipe(psrc, ctx, option, gulp))\r\n            .then(psrc => this.pipes2Promise(psrc, ctx, option, gulp, pipes))\r\n            .then(psrc => this.output2Promise(psrc, ctx, option, gulp, output))\r\n            .catch(err => {\r\n                console.log(chalk.red(err));\r\n                process.exit(0);\r\n            });\r\n    }\r\n\r\n    /**\r\n     * execute task working\r\n     *\r\n     * @param {ITaskContext} context\r\n     * @param {Gulp} gulp\r\n     * @returns {Promise<any>}\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    execute(context: ITaskContext, gulp: Gulp): Promise<any> {\r\n        let option = this.getOption(context);\r\n        return Promise.resolve(this.source(context, option, gulp))\r\n            .then(stream => {\r\n                if (_.isArray(stream)) {\r\n                    if (this.runWay === RunWay.parallel) {\r\n                        return Promise.all(_.map(stream, st => this.working(st, context, option, gulp)));\r\n                    } else if (this.runWay === RunWay.sequence) {\r\n                        let pthen: Promise<any>;\r\n                        _.each(stream, st => {\r\n                            if (!pthen) {\r\n                                pthen = this.working(st, context, option, gulp);\r\n                            } else {\r\n                                pthen = pthen.then(() => {\r\n                                    return this.working(st, context, option, gulp);\r\n                                });\r\n                            }\r\n                        });\r\n                        return pthen;\r\n                    } else {\r\n                        return Promise.reject('runWay setting error.');\r\n                    }\r\n                } else {\r\n                    return this.working(stream, context, option, gulp);\r\n                }\r\n            });\r\n    }\r\n\r\n    /**\r\n     * setup task works.\r\n     *\r\n     * @param {ITaskContext} context\r\n     * @param {Gulp} [gulp]\r\n     * @returns {TaskResult}\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    setup(context: ITaskContext, gulp?: Gulp): TaskResult {\r\n        gulp = gulp || coregulp;\r\n        // let option = this.getOption(context);\r\n        let tk = context.subTaskName(this.getInfo());\r\n        console.log(`register ${this.name || ''} task:`, chalk.cyan(tk));\r\n\r\n        gulp.task(tk, () => {\r\n            return this.execute(context, gulp);\r\n        });\r\n\r\n        this.info.taskName = tk;\r\n\r\n        return tk;\r\n    }\r\n}\r\n"]}