{"version":3,"sources":["PipeTask.js","PipeTask.ts"],"names":["coregulp","require","chalk","_","RunWay","exports","PipeTask","info","_classCallCheck","this","runWay","parallel","decorator","config","option","gulp","src","getSrc","source","dist","pipes","loader","isFunction","filter","p","name","opps","length","concat","isString","isArray","output","stream","pipe","dest","getDist","endsWith","oper","opt","Promise","resolve","reject","ps","err","then","_this","subTaskName","all","map","match","toTransform","trs","order","tans","len","orderBy","t","isNumber","each","transformSourcePipe","transformPipe","_this2","outputs","once","_this3","cfgopt","prsrc","cpipe2Promise","_this4","psrc","customPipe","pipes2Promise","output2Promise","catch","console","log","red","process","exit","_this5","getOption","sourceStream","working","st","sequence","_ret","pthen","v","_typeof","_this6","tk","cyan","task","execute","taskName"],"mappings":"AAAA,+kBCEYA,SAAQC,QAAM,QACdC,MAAKD,QAAM,SACXE,EAACF,QAAM,WAmEnB,SAAYG,GAIRA,EAAAA,EAAA,SAAA,GAAA,WAIAA,EAAAA,EAAA,SAAA,GAAA,YARQC,QAAAD,SAAAC,QAAAD,WAAZ,IAAYA,QAAAC,QAAAD,OAkBZE,oBAsBI,QAAAA,GAAYC,GAAgBC,gBAAAC,KAAAH,GAfrBG,KAAAC,OAASN,OAAOO,SAgBnBF,KAAKG,UAAYL,0DAadM,EAAqBC,EAAqBC,GAC7C,MAAOA,GAAKC,IAAIH,EAAOI,OAAOH,EAAQL,KAAKG,iDAalCC,EAAqBC,EAAqBC,GACnD,MAAON,MAAKS,OAAOL,EAAQC,EAAQC,mCAajCF,EAAqBM,EAAmBJ,GAC1C,GAAID,GAASD,EAAOC,OAChBM,EAAgB,KAChBC,EAAwBP,EAAOO,MAKnC,IAJIA,GAAUlB,EAAEmB,WAAWD,EAAOD,SAC9BA,EAAQjB,EAAEmB,WAAWD,EAAOD,OAASC,EAAOD,MAAMP,EAAQC,EAAQC,GAAQZ,EAAEoB,OAAeF,EAAOD,MAAO,SAAAI,GAAA,MAAKrB,GAAEmB,WAAWE,IAAOA,EAAEC,MAAQD,EAAEC,OAASN,EAAKM,QAG5JX,EAAOM,MAAO,CACd,GAAIM,GAAOvB,EAAEmB,WAAWR,EAAOM,OAASN,EAAOM,MAAMP,EAAQC,EAAQC,GAAQZ,EAAEoB,OAAeT,EAAOM,MAAO,SAAAI,GAAA,MAAKrB,GAAEmB,WAAWE,IAAOA,EAAEC,MAAQD,EAAEC,OAASN,EAAKM,MAC3JC,IAAQA,EAAKC,OAAS,IACtBP,EAAQA,EAAQA,EAAMQ,OAAOF,GAAQA,GAG7C,MAAON,sCAaJP,EAAqBM,EAAmBJ,GAC3C,GAAID,GAASD,EAAOC,OAChBM,EAAsB,KACtBC,EAAwBP,EAAOO,MACnC,IAAIA,IAAWlB,EAAE0B,SAASR,KAAYlB,EAAE2B,QAAQT,GAC5C,GAAIA,EAAOU,OACPX,EAAQjB,EAAEmB,WAAWD,EAAOU,QAAUV,EAAOU,OAAOlB,EAAQC,EAAQC,GAAQZ,EAAEoB,OAAqBF,EAAOD,MAAO,SAAAI,GAAA,MAAKrB,GAAEmB,WAAWE,IAAOA,EAAEC,MAAQD,EAAEC,OAASN,EAAKM,WACjK,IAAsB,OAAlBJ,EAAOU,OACd,OAAQ,SAACC,GAAD,MAAYA,IAG5B,IAAIlB,EAAOiB,OAAQ,CACf,GAAIL,GAAOvB,EAAEmB,WAAWR,EAAOiB,QAAUjB,EAAOiB,OAAOlB,EAAQC,EAAQC,GAAQZ,EAAEoB,OAAqBT,EAAOiB,OAAQ,SAAAP,GAAA,MAAKrB,GAAEmB,WAAWE,IAAOA,EAAEC,MAAQD,EAAEC,OAASN,EAAKM,MACpKC,IAAQA,EAAKC,OAAS,IACtBP,EAAQA,EAAQA,EAAMQ,OAAOF,GAAQA,OAEtC,IAAsB,OAAlBZ,EAAOiB,OACd,OAAQ,SAACC,GAAD,MAAYA,IAGxB,OAAOZ,KAAU,SAACY,GAAD,MAAYA,GAAOC,KAAKlB,EAAKmB,KAAKrB,EAAOsB,QAAQhB,yCAYlDN,GAChB,MAAOA,GAAOC,qCAaFU,EAAiBC,EAAcZ,GAC3C,QAAKW,MAGDA,EAAEC,OAASA,EAAKW,SAASZ,EAAEC,UAI3BD,EAAEa,OAASb,EAAEa,KAAOxB,EAAOwB,OAAS,0CAoBpBnB,EAAoBoB,EAAkBzB,EAAqBM,EAAmBJ,GAClG,MAAO,IAAIwB,SAAoB,SAACC,EAASC,GACrC,GAAIC,GAAKJ,EAAIL,KAAKf,EAAQL,EAAQM,EAAMJ,EAAM,SAAC4B,GACvCA,EACAF,EAAOE,GAEPH,KAGJE,IACAH,QAAQC,QAAQE,GAAIE,KAAKJ,EAASC,2CAkBtBvB,EAAoBL,EAAqBM,EAAmBJ,EAAYK,GAAc,GAAAyB,GAAApC,KACtGgB,EAAOZ,EAAOiC,YAAY3B,EAAMV,KAAKgB,KACzC,OAAOc,SAAQQ,IAAI5C,EAAE6C,IAAI5B,GAASX,KAAKW,MAAMP,EAAQM,EAAMJ,GAAO,SAACS,GAC/D,MAAIrB,GAAEmB,WAAWE,GACNA,EAAEX,EAAQM,EAAMJ,GAElB8B,EAAKI,MAAMzB,EAAGC,EAAMZ,GAGd0B,QAAQC,QAAQhB,EAAE0B,YAAYrC,EAAQM,EAAMJ,IAC9C6B,KAAK,SAAAO,GAGF,MAFAA,GAAIC,MAAQ5B,EAAE4B,MAEPD,IANR,QAWdP,KAAK,SAAAS,GACF,GAAIC,GAAMD,EAAK1B,MAyBf,OAxBA0B,GAAOlD,EAAEoD,QAAQpD,EAAEoB,OAAO8B,EAAM,SAAAG,GAAA,MAAKA,KAAI,SAAAA,GACrC,MAAIrD,GAAE2B,QAAQ0B,GACHF,EAEHnD,EAAEsD,SAASD,EAAEJ,OACNI,EAAEJ,MAENE,IAIfnD,EAAEuD,KAAKL,EAAM,SAAArB,GACJa,EAAKI,MAAMjB,EAAQP,EAAMZ,KAK1BK,EADAf,EAAEmB,WAAWU,EAAO2B,qBACX3B,EAAO2B,oBAAoBzC,GAC7Bf,EAAEmB,WAAWJ,EAAO0C,eAClB1C,EAAO0C,cAAc5B,GAErBd,EAAOe,KAAKD,MAGtBd,2CAiBMA,EAAoBL,EAAqBM,EAAmBJ,EAAYgB,GAAqB,GAAA8B,GAAApD,KAC9GgB,EAAOZ,EAAOiC,YAAY3B,EAAMV,KAAKgB,MACrCqC,EAAU/B,GAAUtB,KAAKsB,OAAOlB,EAAQM,EAAMJ,EAClD,OAAOwB,SAAQQ,IAAI5C,EAAE6C,IAAIc,EAAS,SAAA/B,GAC9B,MAAI5B,GAAEmB,WAAWS,GACNA,EAAOb,EAAQL,EAAQM,EAAMJ,GAE/B8C,EAAKZ,MAAMlB,EAAQN,EAAMZ,GAGnBkB,EAAOmB,YAAYhC,EAAQL,EAAQM,EAAMJ,GAFzC,QAMd6B,KAAK,SAAAkB,GACF,MAAOvB,SAAQQ,IAAI5C,EAAE6C,IAAIc,EAAS,SAAA/B,GAC9B,MAAO,IAAIQ,SAAQ,SAACC,EAASC,GACrBV,EACAA,EACKgC,KAAK,MAAO,WACTvB,EAAQT,KAEXgC,KAAK,QAAStB,GAEnBD,8CAoBHtB,EAAoBL,EAAqBM,EAAmBJ,GAAU,GAAAiD,GAAAvD,KACnFwD,EAASpD,EAAOC,OAChBO,EAAwB4C,EAAO5C,OAC/B6C,EAAAA,MAUJ,OATID,GAAOhC,OACPiC,EAAQzD,KAAK0D,cAAcjD,EAAQ+C,EAAQpD,EAAQM,EAAMJ,IAEzDM,IAAWlB,EAAE0B,SAASR,KAAYlB,EAAE2B,QAAQT,IAAWA,EAAOY,OAC9DiC,EAAQA,EACJA,EAAMtB,KAAK,SAAAZ,GAAA,MAAUgC,GAAKG,cAAcnC,EAAQX,EAAQR,EAAQM,EAAMJ,KACpEN,KAAK0D,cAAcjD,EAAQG,EAAQR,EAAQM,EAAMJ,IAGpDmD,GAAShD,kCAiBFA,EAAoBL,EAAqBC,EAAqBC,EAAYK,EAAgBW,GAAqB,GAAAqC,GAAA3D,IAC7H,OAAO8B,SAAQC,QAAQtB,GAClB0B,KAAK,SAAAyB,GAAA,MAAQD,GAAKE,WAAWD,EAAMxD,EAAQC,EAAQC,KACnD6B,KAAK,SAAAyB,GAAA,MAAQD,GAAKG,cAAcF,EAAMxD,EAAQC,EAAQC,EAAMK,KAC5DwB,KAAK,SAAAyB,GAAA,MAAQD,GAAKI,eAAeH,EAAMxD,EAAQC,EAAQC,EAAMgB,KAC7D0C,MAAM,SAAA9B,GACH+B,QAAQC,IAAIzE,MAAM0E,IAAIjC,IACtBkC,QAAQC,KAAK,qCAajBjE,EAAqBE,GAAU,GAAAgE,GAAAtE,KAC/BK,EAASL,KAAKuE,UAAUnE,EAC5B,OAAO0B,SAAQC,QAAQ/B,KAAKwE,aAAapE,EAAQC,EAAQC,IACpD6B,KAAK,SAAAZ,GACF,IAAI7B,EAAE2B,QAAQE,GAmBV,MAAO+C,GAAKG,QAAQlD,EAAQnB,EAAQC,EAAQC,EAlB5C,IAAIgE,EAAKrE,SAAWN,OAAOO,SACvB,MAAO4B,SAAQQ,IAAI5C,EAAE6C,IAAIhB,EAAQ,SAAAmD,GAAA,MAAMJ,GAAKG,QAAQC,EAAItE,EAAQC,EAAQC,KACrE,IAAIgE,EAAKrE,SAAWN,OAAOgF,SAa9B,MAAO7C,SAAQE,OAAO,wBAbkB,IAAA4C,GAAA,WACxC,GAAIC,GAAAA,MAUJ,OATAnF,GAAEuD,KAAK1B,EAAQ,SAAAmD,GAIPG,EAHCA,EAGOA,EAAM1C,KAAK,WACf,MAAOmC,GAAKG,QAAQC,EAAItE,EAAQC,EAAQC,KAHpCgE,EAAKG,QAAQC,EAAItE,EAAQC,EAAQC,MAOjDwE,EAAOD,KAXiC,OAAA,YAAA,mBAAAD,GAAA,YAAAG,QAAAH,IAAAA,EAAAE,EAAA,uCA8BtD1E,EAAqBE,GAAW,GAAA0E,GAAAhF,IAClCM,GAAOA,GAAQf,QACf,IAAIc,GAASL,KAAKuE,UAAUnE,GACxB6E,EAAK7E,EAAOiC,YAAYhC,EAAQL,KAAKgB,KASzC,OARAiD,SAAQC,IAAR,aAAwBlE,KAAKgB,MAAQ,IAArC,SAAiDvB,MAAMyF,KAAKD,IAE5D3E,EAAK6E,KAAKF,EAAI,WACV,MAAOD,GAAKI,QAAQhF,EAAQE,KAGhCN,KAAKG,UAAUkF,SAAWJ,EAEnBA,UA7YOrF,SAAAC,SAAQA","file":"../PipeTask.js","sourcesContent":["\"use strict\";\nconst coregulp = require('gulp');\nconst chalk = require('chalk');\nconst _ = require('lodash');\n/**\n * mutil source stream pipe task run way.\n *\n * @export\n * @enum {number}\n */\n(function (RunWay) {\n    /**\n     * run mutil source stream by sequence.\n     */\n    RunWay[RunWay[\"sequence\"] = 1] = \"sequence\";\n    /**\n     * run mutil source stream by parallel.\n     */\n    RunWay[RunWay[\"parallel\"] = 2] = \"parallel\";\n})(exports.RunWay || (exports.RunWay = {}));\nvar RunWay = exports.RunWay;\n/**\n * Task base class.\n *\n * @export\n * @class Task\n * @implements {ITask}\n */\nclass PipeTask {\n    constructor(info) {\n        /**\n         * run mutil source stream way. default parallel.\n         *\n         *\n         * @memberOf PipeTask\n         */\n        this.runWay = RunWay.parallel;\n        this.decorator = info || {};\n    }\n    /**\n     * source streams.\n     *\n     * @param {ITaskConfig} config\n     * @param {IAssertDist} option\n     * @param {Gulp} gulp\n     * @returns {(TransformSource | Promise<TransformSource>)}\n     *\n     * @memberOf PipeTask\n     */\n    source(config, option, gulp) {\n        return gulp.src(config.getSrc(option, this.decorator));\n    }\n    /**\n     * pelease use source method.\n     *\n     * @param {ITaskConfig} config\n     * @param {IAssertDist} option\n     * @param {Gulp} gulp\n     * @returns {(TransformSource | Promise<TransformSource>)}\n     *\n     * @memberOf PipeTask\n     */\n    sourceStream(config, option, gulp) {\n        return this.source(config, option, gulp);\n    }\n    /**\n     * task pipe works.\n     *\n     * @param {ITaskConfig} config\n     * @param {IAssertDist} dist\n     * @param {Gulp} [gulp]\n     * @returns {Pipe[]}\n     *\n     * @memberOf PipeTask\n     */\n    pipes(config, dist, gulp) {\n        let option = config.option;\n        let pipes = null;\n        let loader = option.loader;\n        if (loader && _.isFunction(loader.pipes)) {\n            pipes = _.isFunction(loader.pipes) ? loader.pipes(config, option, gulp) : _.filter(loader.pipes, p => _.isFunction(p) || (p.name && p.name === dist.name));\n        }\n        if (option.pipes) {\n            let opps = _.isFunction(option.pipes) ? option.pipes(config, option, gulp) : _.filter(option.pipes, p => _.isFunction(p) || (p.name && p.name === dist.name));\n            if (opps && opps.length > 0) {\n                pipes = pipes ? pipes.concat(opps) : opps;\n            }\n        }\n        return pipes || [];\n    }\n    /**\n     * output pipes.\n     *\n     * @param {ITaskConfig} config\n     * @param {IAssertDist} dist\n     * @param {Gulp} [gulp]\n     * @returns {OutputPipe[]}\n     *\n     * @memberOf PipeTask\n     */\n    output(config, dist, gulp) {\n        let option = config.option;\n        let pipes = null;\n        let loader = option.loader;\n        if (loader && !_.isString(loader) && !_.isArray(loader)) {\n            if (loader.output) {\n                pipes = _.isFunction(loader.output) ? loader.output(config, option, gulp) : _.filter(loader.pipes, p => _.isFunction(p) || (p.name && p.name === dist.name));\n            }\n            else if (loader.output === null) {\n                return [(stream) => stream];\n            }\n        }\n        if (option.output) {\n            let opps = _.isFunction(option.output) ? option.output(config, option, gulp) : _.filter(option.output, p => _.isFunction(p) || (p.name && p.name === dist.name));\n            if (opps && opps.length > 0) {\n                pipes = pipes ? pipes.concat(opps) : opps;\n            }\n        }\n        else if (option.output === null) {\n            return [(stream) => stream];\n        }\n        return pipes || [(stream) => stream.pipe(gulp.dest(config.getDist(dist)))];\n    }\n    /**\n     * get option.\n     *\n     * @protected\n     * @param {ITaskConfig} config\n     * @returns {IAssertDist}\n     *\n     * @memberOf PipeTask\n     */\n    getOption(config) {\n        return config.option;\n    }\n    /**\n     * match pipe Operate\n     *\n     * @param {IPipeOperate} p\n     * @param {string} name\n     * @param {ITaskConfig} config\n     * @returns\n     *\n     * @memberOf PipeTask\n     */\n    match(p, name, config) {\n        if (!p) {\n            return false;\n        }\n        if (p.name && !name.endsWith(p.name)) {\n            return false;\n        }\n        if (p.oper && (p.oper & config.oper) <= 0) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * convert custom pipe result to Promise.\n     *\n     * @protected\n     * @param {ITransform} source\n     * @param {ICustomPipe} opt\n     * @param {ITaskConfig} config\n     * @param {IAssertDist} dist\n     * @param {Gulp} gulp\n     * @returns\n     *\n     * @memberOf PipeTask\n     */\n    cpipe2Promise(source, opt, config, dist, gulp) {\n        return new Promise((resolve, reject) => {\n            let ps = opt.pipe(source, config, dist, gulp, (err) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve();\n                }\n            });\n            if (ps) {\n                Promise.resolve(ps).then(resolve, reject);\n            }\n        });\n    }\n    /**\n     * covert pipes transform to Promise.\n     *\n     * @protected\n     * @param {ITransform} source\n     * @param {ITaskConfig} config\n     * @param {IAssertDist} dist\n     * @param {Gulp} gulp\n     * @param {Pipe[]} [pipes]\n     * @returns\n     *\n     * @memberOf PipeTask\n     */\n    pipes2Promise(source, config, dist, gulp, pipes) {\n        let name = config.subTaskName(dist, this.name);\n        return Promise.all(_.map(pipes || this.pipes(config, dist, gulp), (p) => {\n            if (_.isFunction(p)) {\n                return p(config, dist, gulp);\n            }\n            else {\n                if (!this.match(p, name, config)) {\n                    return null;\n                }\n                else {\n                    return Promise.resolve(p.toTransform(config, dist, gulp))\n                        .then(trs => {\n                        trs.order = p.order;\n                        // trs.oper = p.order;\n                        return trs;\n                    });\n                }\n            }\n        }))\n            .then(tans => {\n            let len = tans.length;\n            tans = _.orderBy(_.filter(tans, t => t), t => {\n                if (_.isArray(t)) {\n                    return len;\n                }\n                else {\n                    if (_.isNumber(t.order)) {\n                        return t.order;\n                    }\n                    return len;\n                }\n            });\n            _.each(tans, stream => {\n                if (!this.match(stream, name, config)) {\n                    return;\n                }\n                if (_.isFunction(stream.transformSourcePipe)) {\n                    source = stream.transformSourcePipe(source);\n                }\n                else if (_.isFunction(source.transformPipe)) {\n                    source = source.transformPipe(stream);\n                }\n                else {\n                    source = source.pipe(stream);\n                }\n            });\n            return source;\n        });\n    }\n    /**\n     * output pipes transform to Promise.\n     *\n     * @protected\n     * @param {ITransform} source\n     * @param {ITaskConfig} config\n     * @param {IAssertDist} dist\n     * @param {Gulp} gulp\n     * @param {OutputPipe[]} [output]\n     * @returns\n     *\n     * @memberOf PipeTask\n     */\n    output2Promise(source, config, dist, gulp, output) {\n        let name = config.subTaskName(dist, this.name);\n        let outputs = output || this.output(config, dist, gulp);\n        return Promise.all(_.map(outputs, output => {\n            if (_.isFunction(output)) {\n                return output(source, config, dist, gulp);\n            }\n            else {\n                if (!this.match(output, name, config)) {\n                    return null;\n                }\n                else {\n                    return output.toTransform(source, config, dist, gulp);\n                }\n            }\n        }))\n            .then(outputs => {\n            return Promise.all(_.map(outputs, output => {\n                return new Promise((resolve, reject) => {\n                    if (output) {\n                        output\n                            .once('end', () => {\n                            resolve(output);\n                        })\n                            .once('error', reject);\n                    }\n                    else {\n                        resolve();\n                    }\n                });\n            }));\n        });\n    }\n    /**\n     *  custom pipe Promise.\n     *\n     * @protected\n     * @param {ITransform} source\n     * @param {ITaskConfig} config\n     * @param {IAssertDist} dist\n     * @param {Gulp} gulp\n     * @returns\n     *\n     * @memberOf PipeTask\n     */\n    customPipe(source, config, dist, gulp) {\n        let cfgopt = config.option;\n        let loader = cfgopt.loader;\n        let prsrc;\n        if (cfgopt.pipe) {\n            prsrc = this.cpipe2Promise(source, cfgopt, config, dist, gulp);\n        }\n        if (loader && !_.isString(loader) && !_.isArray(loader) && loader.pipe) {\n            prsrc = prsrc ?\n                prsrc.then(stream => this.cpipe2Promise(stream, loader, config, dist, gulp))\n                : this.cpipe2Promise(source, loader, config, dist, gulp);\n        }\n        return prsrc || source;\n    }\n    /**\n     * each one source stream works.\n     *\n     * @protected\n     * @param {ITransform} source\n     * @param {ITaskConfig} config\n     * @param {IAssertDist} option\n     * @param {Gulp} gulp\n     * @param {Pipe[]} [pipes]\n     * @param {OutputPipe[]} [output]\n     * @returns\n     *\n     * @memberOf PipeTask\n     */\n    working(source, config, option, gulp, pipes, output) {\n        return Promise.resolve(source)\n            .then(psrc => this.customPipe(psrc, config, option, gulp))\n            .then(psrc => this.pipes2Promise(psrc, config, option, gulp, pipes))\n            .then(psrc => this.output2Promise(psrc, config, option, gulp, output))\n            .catch(err => {\n            console.log(chalk.red(err));\n            process.exit(0);\n        });\n    }\n    /**\n     * execute task working\n     *\n     * @param {ITaskConfig} config\n     * @param {Gulp} gulp\n     * @returns {Promise<any>}\n     *\n     * @memberOf PipeTask\n     */\n    execute(config, gulp) {\n        let option = this.getOption(config);\n        return Promise.resolve(this.sourceStream(config, option, gulp))\n            .then(stream => {\n            if (_.isArray(stream)) {\n                if (this.runWay === RunWay.parallel) {\n                    return Promise.all(_.map(stream, st => this.working(st, config, option, gulp)));\n                }\n                else if (this.runWay === RunWay.sequence) {\n                    let pthen;\n                    _.each(stream, st => {\n                        if (!pthen) {\n                            pthen = this.working(st, config, option, gulp);\n                        }\n                        else {\n                            pthen = pthen.then(() => {\n                                return this.working(st, config, option, gulp);\n                            });\n                        }\n                    });\n                    return pthen;\n                }\n                else {\n                    return Promise.reject('runWay setting error.');\n                }\n            }\n            else {\n                return this.working(stream, config, option, gulp);\n            }\n        });\n    }\n    /**\n     * setup task works.\n     *\n     * @param {ITaskConfig} config\n     * @param {Gulp} [gulp]\n     * @returns {TaskResult}\n     *\n     * @memberOf PipeTask\n     */\n    setup(config, gulp) {\n        gulp = gulp || coregulp;\n        let option = this.getOption(config);\n        let tk = config.subTaskName(option, this.name);\n        console.log(`register ${this.name || ''} task:`, chalk.cyan(tk));\n        gulp.task(tk, () => {\n            return this.execute(config, gulp);\n        });\n        this.decorator.taskName = tk;\n        return tk;\n    }\n}\nexports.PipeTask = PipeTask;\n","import { Gulp } from 'gulp';\r\nimport { TransformSource, IAssertDist, ITaskInfo, TaskResult, ITaskConfig, IPipeOperate, ICustomPipe, Pipe, OutputPipe, ITask, ITransform, ILoaderOption } from './TaskConfig';\r\nimport * as coregulp from 'gulp';\r\nimport * as chalk from 'chalk';\r\nimport * as _ from 'lodash';\r\n\r\n/**\r\n * pipe task.\r\n * \r\n * @export\r\n * @interface IPipeWork\r\n */\r\nexport interface IPipeTask extends ITask {\r\n    /**\r\n     * task default name.\r\n     * \r\n     * @type {string}\r\n     * @memberOf IPipeTask\r\n     */\r\n    name: string;\r\n    /**\r\n     * gulp src stream.\r\n     * \r\n     * @param {ITaskConfig} config\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} gulp\r\n     * @returns {(TransformSource | Promise<TransformSource>)}\r\n     * \r\n     * @memberOf IPipeTask\r\n     */\r\n    source(config: ITaskConfig, dist: IAssertDist, gulp: Gulp): TransformSource | Promise<TransformSource>;\r\n    /**\r\n     * task pipe works.\r\n     * \r\n     * @param {ITaskConfig} config\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} [gulp]\r\n     * @returns {Pipe[]}\r\n     * \r\n     * @memberOf IPipeTask\r\n     */\r\n    pipes(config: ITaskConfig, dist: IAssertDist, gulp?: Gulp): Pipe[];\r\n\r\n    /**\r\n     * output pipes.\r\n     * \r\n     * @param {ITaskConfig} [config]\r\n     * @param {Gulp} [gulp]\r\n     * @returns {OutputPipe[]}\r\n     * \r\n     * @memberOf IPipeTask\r\n     */\r\n    output(config: ITaskConfig, dist: IAssertDist, gulp?: Gulp): OutputPipe[];\r\n    /**\r\n     * execute task works.\r\n     * \r\n     * @param {ITaskConfig} config\r\n     * @param {Gulp} gulp\r\n     * @returns {Promise<any>}\r\n     * \r\n     * @memberOf IPipeTask\r\n     */\r\n    execute(config: ITaskConfig, gulp: Gulp): Promise<any>;\r\n}\r\n\r\n/**\r\n * mutil source stream pipe task run way.\r\n * \r\n * @export\r\n * @enum {number}\r\n */\r\nexport enum RunWay {\r\n    /**\r\n     * run mutil source stream by sequence.\r\n     */\r\n    sequence = 1,\r\n    /**\r\n     * run mutil source stream by parallel.\r\n     */\r\n    parallel = 2\r\n}\r\n\r\n/**\r\n * Task base class.\r\n * \r\n * @export\r\n * @class Task\r\n * @implements {ITask}\r\n */\r\nexport abstract class PipeTask implements IPipeTask {\r\n    /**\r\n     * run mutil source stream way. default parallel.\r\n     * \r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    public runWay = RunWay.parallel;\r\n    /**\r\n     * task default name.\r\n     * \r\n     * @type {string}\r\n     * @memberOf PipeTask\r\n     */\r\n    name: string;\r\n    /**\r\n     * task info.\r\n     * \r\n     * @type {ITaskInfo}\r\n     * @memberOf PipeTask\r\n     */\r\n    public decorator: ITaskInfo;\r\n    constructor(info?: ITaskInfo) {\r\n        this.decorator = info || {};\r\n    }\r\n\r\n    /**\r\n     * source streams.\r\n     * \r\n     * @param {ITaskConfig} config\r\n     * @param {IAssertDist} option\r\n     * @param {Gulp} gulp\r\n     * @returns {(TransformSource | Promise<TransformSource>)}\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    source(config: ITaskConfig, option: IAssertDist, gulp: Gulp): TransformSource | Promise<TransformSource> {\r\n        return gulp.src(config.getSrc(option, this.decorator));\r\n    }\r\n\r\n    /**\r\n     * pelease use source method.\r\n     * \r\n     * @param {ITaskConfig} config\r\n     * @param {IAssertDist} option\r\n     * @param {Gulp} gulp\r\n     * @returns {(TransformSource | Promise<TransformSource>)}\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    sourceStream(config: ITaskConfig, option: IAssertDist, gulp: Gulp): TransformSource | Promise<TransformSource> {\r\n        return this.source(config, option, gulp);\r\n    }\r\n\r\n    /**\r\n     * task pipe works.\r\n     * \r\n     * @param {ITaskConfig} config\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} [gulp]\r\n     * @returns {Pipe[]}\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    pipes(config: ITaskConfig, dist: IAssertDist, gulp?: Gulp): Pipe[] {\r\n        let option = config.option;\r\n        let pipes: Pipe[] = null;\r\n        let loader = <ILoaderOption>option.loader;\r\n        if (loader && _.isFunction(loader.pipes)) {\r\n            pipes = _.isFunction(loader.pipes) ? loader.pipes(config, option, gulp) : _.filter(<Pipe[]>loader.pipes, p => _.isFunction(p) || (p.name && p.name === dist.name));\r\n        }\r\n\r\n        if (option.pipes) {\r\n            let opps = _.isFunction(option.pipes) ? option.pipes(config, option, gulp) : _.filter(<Pipe[]>option.pipes, p => _.isFunction(p) || (p.name && p.name === dist.name));\r\n            if (opps && opps.length > 0) {\r\n                pipes = pipes ? pipes.concat(opps) : opps;\r\n            }\r\n        }\r\n        return pipes || [];\r\n    }\r\n\r\n    /**\r\n     * output pipes.\r\n     * \r\n     * @param {ITaskConfig} config\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} [gulp]\r\n     * @returns {OutputPipe[]}\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    output(config: ITaskConfig, dist: IAssertDist, gulp?: Gulp): OutputPipe[] {\r\n        let option = config.option;\r\n        let pipes: OutputPipe[] = null;\r\n        let loader = <ILoaderOption>option.loader;\r\n        if (loader && !_.isString(loader) && !_.isArray(loader)) {\r\n            if (loader.output) {\r\n                pipes = _.isFunction(loader.output) ? loader.output(config, option, gulp) : _.filter(<OutputPipe[]>loader.pipes, p => _.isFunction(p) || (p.name && p.name === dist.name));\r\n            } else if (loader.output === null) {\r\n                return [(stream) => stream];\r\n            }\r\n        }\r\n        if (option.output) {\r\n            let opps = _.isFunction(option.output) ? option.output(config, option, gulp) : _.filter(<OutputPipe[]>option.output, p => _.isFunction(p) || (p.name && p.name === dist.name));\r\n            if (opps && opps.length > 0) {\r\n                pipes = pipes ? pipes.concat(opps) : opps;\r\n            }\r\n        } else if (option.output === null) {\r\n            return [(stream) => stream];\r\n        }\r\n\r\n        return pipes || [(stream) => stream.pipe(gulp.dest(config.getDist(dist)))]\r\n    }\r\n\r\n    /**\r\n     * get option.\r\n     * \r\n     * @protected\r\n     * @param {ITaskConfig} config\r\n     * @returns {IAssertDist}\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    protected getOption(config: ITaskConfig): IAssertDist {\r\n        return config.option;\r\n    }\r\n\r\n    /**\r\n     * match pipe Operate\r\n     * \r\n     * @param {IPipeOperate} p\r\n     * @param {string} name\r\n     * @param {ITaskConfig} config\r\n     * @returns\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    protected match(p: IPipeOperate, name: string, config: ITaskConfig) {\r\n        if (!p) {\r\n            return false;\r\n        }\r\n        if (p.name && !name.endsWith(p.name)) {\r\n            return false;\r\n        }\r\n\r\n        if (p.oper && (p.oper & config.oper) <= 0) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * convert custom pipe result to Promise.\r\n     * \r\n     * @protected\r\n     * @param {ITransform} source\r\n     * @param {ICustomPipe} opt\r\n     * @param {ITaskConfig} config\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} gulp\r\n     * @returns\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    protected cpipe2Promise(source: ITransform, opt: ICustomPipe, config: ITaskConfig, dist: IAssertDist, gulp: Gulp) {\r\n        return new Promise<ITransform>((resolve, reject) => {\r\n            let ps = opt.pipe(source, config, dist, gulp, (err) => {\r\n                if (err) {\r\n                    reject(err);\r\n                } else {\r\n                    resolve();\r\n                }\r\n            });\r\n            if (ps) {\r\n                Promise.resolve(ps).then(resolve, reject);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * covert pipes transform to Promise.\r\n     * \r\n     * @protected\r\n     * @param {ITransform} source\r\n     * @param {ITaskConfig} config\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} gulp\r\n     * @param {Pipe[]} [pipes]\r\n     * @returns\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    protected pipes2Promise(source: ITransform, config: ITaskConfig, dist: IAssertDist, gulp: Gulp, pipes?: Pipe[]) {\r\n        let name = config.subTaskName(dist, this.name);\r\n        return Promise.all(_.map(pipes || this.pipes(config, dist, gulp), (p: Pipe) => {\r\n            if (_.isFunction(p)) {\r\n                return p(config, dist, gulp);\r\n            } else {\r\n                if (!this.match(p, name, config)) {\r\n                    return null;\r\n                } else {\r\n                    return Promise.resolve(p.toTransform(config, dist, gulp))\r\n                        .then(trs => {\r\n                            trs.order = p.order;\r\n                            // trs.oper = p.order;\r\n                            return trs;\r\n                        });\r\n                }\r\n            }\r\n        }))\r\n            .then(tans => {\r\n                let len = tans.length;\r\n                tans = _.orderBy(_.filter(tans, t => t), t => {\r\n                    if (_.isArray(t)) {\r\n                        return len;\r\n                    } else {\r\n                        if (_.isNumber(t.order)) {\r\n                            return t.order;\r\n                        }\r\n                        return len;\r\n                    }\r\n                });\r\n\r\n                _.each(tans, stream => {\r\n                    if (!this.match(stream, name, config)) {\r\n                        return;\r\n                    }\r\n\r\n                    if (_.isFunction(stream.transformSourcePipe)) {\r\n                        source = stream.transformSourcePipe(source);\r\n                    } else if (_.isFunction(source.transformPipe)) {\r\n                        source = source.transformPipe(stream);\r\n                    } else {\r\n                        source = source.pipe(stream);\r\n                    }\r\n                });\r\n                return source;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * output pipes transform to Promise.\r\n     * \r\n     * @protected\r\n     * @param {ITransform} source\r\n     * @param {ITaskConfig} config\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} gulp\r\n     * @param {OutputPipe[]} [output]\r\n     * @returns\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    protected output2Promise(source: ITransform, config: ITaskConfig, dist: IAssertDist, gulp: Gulp, output?: OutputPipe[]) {\r\n        let name = config.subTaskName(dist, this.name);\r\n        let outputs = output || this.output(config, dist, gulp);\r\n        return Promise.all(_.map(outputs, output => {\r\n            if (_.isFunction(output)) {\r\n                return output(source, config, dist, gulp);\r\n            } else {\r\n                if (!this.match(output, name, config)) {\r\n                    return null;\r\n                } else {\r\n                    return output.toTransform(source, config, dist, gulp);\r\n                }\r\n            }\r\n        }))\r\n            .then(outputs => {\r\n                return Promise.all(_.map(outputs, output => {\r\n                    return new Promise((resolve, reject) => {\r\n                        if (output) {\r\n                            output\r\n                                .once('end', () => {\r\n                                    resolve(output);\r\n                                })\r\n                                .once('error', reject);\r\n                        } else {\r\n                            resolve();\r\n                        }\r\n                    });\r\n                }));\r\n            })\r\n    }\r\n\r\n\r\n    /**\r\n     *  custom pipe Promise.\r\n     * \r\n     * @protected\r\n     * @param {ITransform} source\r\n     * @param {ITaskConfig} config\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} gulp\r\n     * @returns\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    protected customPipe(source: ITransform, config: ITaskConfig, dist: IAssertDist, gulp: Gulp) {\r\n        let cfgopt = config.option;\r\n        let loader = <ILoaderOption>cfgopt.loader;\r\n        let prsrc: Promise<ITransform>;\r\n        if (cfgopt.pipe) {\r\n            prsrc = this.cpipe2Promise(source, cfgopt, config, dist, gulp);\r\n        }\r\n        if (loader && !_.isString(loader) && !_.isArray(loader) && loader.pipe) {\r\n            prsrc = prsrc ?\r\n                prsrc.then(stream => this.cpipe2Promise(stream, loader, config, dist, gulp))\r\n                : this.cpipe2Promise(source, loader, config, dist, gulp);\r\n        }\r\n\r\n        return prsrc || source;\r\n    }\r\n\r\n    /**\r\n     * each one source stream works.\r\n     * \r\n     * @protected\r\n     * @param {ITransform} source\r\n     * @param {ITaskConfig} config\r\n     * @param {IAssertDist} option\r\n     * @param {Gulp} gulp\r\n     * @param {Pipe[]} [pipes]\r\n     * @param {OutputPipe[]} [output]\r\n     * @returns\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    protected working(source: ITransform, config: ITaskConfig, option: IAssertDist, gulp: Gulp, pipes?: Pipe[], output?: OutputPipe[]) {\r\n        return Promise.resolve(source)\r\n            .then(psrc => this.customPipe(psrc, config, option, gulp))\r\n            .then(psrc => this.pipes2Promise(psrc, config, option, gulp, pipes))\r\n            .then(psrc => this.output2Promise(psrc, config, option, gulp, output))\r\n            .catch(err => {\r\n                console.log(chalk.red(err));\r\n                process.exit(0);\r\n            });\r\n    }\r\n\r\n    /**\r\n     * execute task working\r\n     * \r\n     * @param {ITaskConfig} config\r\n     * @param {Gulp} gulp\r\n     * @returns {Promise<any>}\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    execute(config: ITaskConfig, gulp: Gulp): Promise<any> {\r\n        let option = this.getOption(config);\r\n        return Promise.resolve(this.sourceStream(config, option, gulp))\r\n            .then(stream => {\r\n                if (_.isArray(stream)) {\r\n                    if (this.runWay === RunWay.parallel) {\r\n                        return Promise.all(_.map(stream, st => this.working(st, config, option, gulp)));\r\n                    } else if (this.runWay === RunWay.sequence) {\r\n                        let pthen: Promise<any>;\r\n                        _.each(stream, st => {\r\n                            if (!pthen) {\r\n                                pthen = this.working(st, config, option, gulp);\r\n                            } else {\r\n                                pthen = pthen.then(() => {\r\n                                    return this.working(st, config, option, gulp);\r\n                                });\r\n                            }\r\n                        });\r\n                        return pthen;\r\n                    } else {\r\n                        return Promise.reject('runWay setting error.');\r\n                    }\r\n                } else {\r\n                    return this.working(stream, config, option, gulp);\r\n                }\r\n            });\r\n    }\r\n\r\n    /**\r\n     * setup task works.\r\n     * \r\n     * @param {ITaskConfig} config\r\n     * @param {Gulp} [gulp]\r\n     * @returns {TaskResult}\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    setup(config: ITaskConfig, gulp?: Gulp): TaskResult {\r\n        gulp = gulp || coregulp;\r\n        let option = this.getOption(config);\r\n        let tk = config.subTaskName(option, this.name);\r\n        console.log(`register ${this.name || ''} task:`, chalk.cyan(tk));\r\n\r\n        gulp.task(tk, () => {\r\n            return this.execute(config, gulp);\r\n        });\r\n\r\n        this.decorator.taskName = tk;\r\n\r\n        return tk;\r\n    }\r\n}\r\n"]}