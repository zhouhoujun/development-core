{"version":3,"sources":["PipeTask.ts"],"names":["TaskConfig_1","require","utils_1","coregulp","chalk","_","PipeTask","info","this","runWay","RunWay","parallel","operateFileds","name","prototype","getInfo","source","ctx","dist","gulp","option","isFunction","loader","src","getSrc","pipes","filter","p","opps","length","concat","output","isString","isArray","stream","pipe","dest","getDist","customPipe","prsrc","_this","cfgopt","oper","getTransformOperate","cpipe2Promise","then","setTransformOperate","getOption","context","match","trsOperate","isOutput","endsWith","toStr","noneOutput","nonePipe","opt","Promise","resolve","reject","ps","err","pick","operate","each","n","isUndefined","pipes2Promise","subTaskName","all","map","toTransform","trs","order","tanseq","tans","sortOrder","it","transformSourcePipe","transformPipe","output2Promise","outputs","once","result","removeAllListeners","working","psrc","catch","console","log","red","process","exit","execute","st","sequence","pthen_1","setup","tk","cyan","task","taskName","exports"],"mappings":"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","file":"../PipeTask.js","sourcesContent":["import { Gulp } from 'gulp';\r\nimport { TransformSource, RunWay, IAssertDist, ITaskInfo, TaskResult, ITaskContext, IOperate, ICustomPipe, Pipe, OutputPipe, ITask, ITransform, IPipeOption } from './TaskConfig';\r\nimport { sortOrder } from './utils';\r\nimport * as coregulp from 'gulp';\r\nimport * as chalk from 'chalk';\r\nimport * as _ from 'lodash';\r\n\r\n/**\r\n * pipe task.\r\n * \r\n * @export\r\n * @interface IPipeWork\r\n */\r\nexport interface IPipeTask extends ITask {\r\n    /**\r\n     * task default name.\r\n     * \r\n     * @type {string}\r\n     * @memberOf IPipeTask\r\n     */\r\n    name: string;\r\n    /**\r\n     * gulp src stream.\r\n     * \r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} gulp\r\n     * @returns {(TransformSource | Promise<TransformSource>)}\r\n     * \r\n     * @memberOf IPipeTask\r\n     */\r\n    source(context: ITaskContext, dist: IAssertDist, gulp: Gulp): TransformSource | Promise<TransformSource>;\r\n    /**\r\n     * task pipe works.\r\n     * \r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} [gulp]\r\n     * @returns {Pipe[]}\r\n     * \r\n     * @memberOf IPipeTask\r\n     */\r\n    pipes(context: ITaskContext, dist: IAssertDist, gulp?: Gulp): Pipe[];\r\n\r\n    /**\r\n     * output pipes.\r\n     * \r\n     * @param {ITaskContext} [context]\r\n     * @param {Gulp} [gulp]\r\n     * @returns {OutputPipe[]}\r\n     * \r\n     * @memberOf IPipeTask\r\n     */\r\n    output(context: ITaskContext, dist: IAssertDist, gulp?: Gulp): OutputPipe[];\r\n    /**\r\n     * execute task works.\r\n     * \r\n     * @param {ITaskContext} context\r\n     * @param {Gulp} gulp\r\n     * @returns {Promise<any>}\r\n     * \r\n     * @memberOf IPipeTask\r\n     */\r\n    execute(context: ITaskContext, gulp: Gulp): Promise<any>;\r\n}\r\n\r\n/**\r\n * Task base class.\r\n * \r\n * @export\r\n * @class Task\r\n * @implements {ITask}\r\n */\r\nexport abstract class PipeTask implements IPipeTask {\r\n    /**\r\n     * run mutil source stream way. default parallel.\r\n     * \r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    public runWay = RunWay.parallel;\r\n    /**\r\n     * task default name.\r\n     * \r\n     * @type {string}\r\n     * @memberOf PipeTask\r\n     */\r\n    name: string;\r\n\r\n\r\n    constructor(info?: ITaskInfo) {\r\n        this.info = info || {};\r\n        this.info.name = this.info.name || this.name;\r\n    }\r\n\r\n    protected info: ITaskInfo;\r\n\r\n    /**\r\n     * get task info.\r\n     * \r\n     * @type {ITaskInfo}\r\n     * @memberOf PipeTask\r\n     */\r\n    public getInfo(): ITaskInfo {\r\n        if (!this.info.name) {\r\n            this.info.name = this.name;\r\n        }\r\n        return this.info;\r\n    }\r\n\r\n    /**\r\n     * source streams.\r\n     * \r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} option\r\n     * @param {Gulp} gulp\r\n     * @returns {(TransformSource | Promise<TransformSource>)}\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    source(ctx: ITaskContext, dist: IAssertDist, gulp: Gulp): TransformSource | Promise<TransformSource> {\r\n        let option = ctx.option;\r\n        if (option.source) {\r\n            return _.isFunction(option.source) ? option.source(ctx, dist, gulp) : option.source;\r\n        }\r\n        let loader = <IPipeOption>option['loader'];\r\n        if (loader && option.source) {\r\n            return _.isFunction(loader.source) ? loader.source(ctx, dist, gulp) : loader.source;\r\n        }\r\n        return gulp.src(ctx.getSrc(this.getInfo()));\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * task pipe works.\r\n     * \r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} [gulp]\r\n     * @returns {Pipe[]}\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    pipes(ctx: ITaskContext, dist: IAssertDist, gulp?: Gulp): Pipe[] {\r\n        let option = ctx.option;\r\n        let pipes: Pipe[] = null;\r\n        let loader = <IPipeOption>option['loader'];\r\n        if (loader && _.isFunction(loader.pipes)) {\r\n            pipes = _.isFunction(loader.pipes) ? loader.pipes(ctx, option, gulp) : _.filter(<Pipe[]>loader.pipes, p => _.isFunction(p) || (p.name && p.name === dist.name));\r\n        }\r\n\r\n        if (option.pipes) {\r\n            let opps = _.isFunction(option.pipes) ? option.pipes(ctx, option, gulp) : _.filter(<Pipe[]>option.pipes, p => _.isFunction(p) || (p.name && p.name === dist.name));\r\n            if (opps && opps.length > 0) {\r\n                pipes = pipes ? pipes.concat(opps) : opps;\r\n            }\r\n        }\r\n        return pipes || [];\r\n    }\r\n\r\n    /**\r\n     * output pipes.\r\n     * \r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} [gulp]\r\n     * @returns {OutputPipe[]}\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    output(ctx: ITaskContext, dist: IAssertDist, gulp?: Gulp): OutputPipe[] {\r\n        let option = ctx.option;\r\n        let pipes: OutputPipe[] = null;\r\n        let loader = <IPipeOption>option['loader'];\r\n        if (loader && !_.isString(loader) && !_.isArray(loader)) {\r\n            if (loader.output) {\r\n                pipes = _.isFunction(loader.output) ? loader.output(ctx, option, gulp) : _.filter(<OutputPipe[]>loader.pipes, p => _.isFunction(p) || (p.name && p.name === dist.name));\r\n            } else if (loader.output === null) {\r\n                return [(stream) => stream];\r\n            }\r\n        }\r\n        if (option.output) {\r\n            let opps = _.isFunction(option.output) ? option.output(ctx, option, gulp) : _.filter(<OutputPipe[]>option.output, p => _.isFunction(p) || (p.name && p.name === dist.name));\r\n            if (opps && opps.length > 0) {\r\n                pipes = pipes ? pipes.concat(opps) : opps;\r\n            }\r\n        } else if (option.output === null) {\r\n            return [(stream) => stream];\r\n        }\r\n\r\n        return pipes || [(stream) => stream.pipe(gulp.dest(ctx.getDist(dist)))]\r\n    }\r\n\r\n    /**\r\n     *  custom pipe Promise.\r\n     * \r\n     * @protected\r\n     * @param {ITransform} source\r\n     * @param {ITaskContext} ctx\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} gulp\r\n     * @returns\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    protected customPipe(source: ITransform, ctx: ITaskContext, dist: IAssertDist, gulp: Gulp): ITransform | Promise<ITransform> {\r\n        let cfgopt = ctx.option;\r\n        let loader = <IPipeOption>cfgopt['loader'];\r\n        let prsrc: Promise<ITransform>;\r\n        let oper = this.getTransformOperate(source);\r\n        if (cfgopt.pipe) {\r\n            prsrc = this.cpipe2Promise(source, cfgopt, ctx, dist, gulp);\r\n        }\r\n        if (loader && !_.isString(loader) && !_.isArray(loader) && loader.pipe) {\r\n            prsrc = prsrc ?\r\n                prsrc.then(stream => {\r\n                    this.setTransformOperate(stream, oper);\r\n                    return this.cpipe2Promise(stream, loader, ctx, dist, gulp)\r\n                })\r\n                : this.cpipe2Promise(source, loader, ctx, dist, gulp);\r\n        }\r\n\r\n        if (prsrc) {\r\n            return prsrc.then(stream => {\r\n                this.setTransformOperate(stream, oper);\r\n                return stream;\r\n            });\r\n        }\r\n\r\n        return source;\r\n    }\r\n\r\n    /**\r\n     * get option.\r\n     * \r\n     * @protected\r\n     * @param {ITaskContext} context\r\n     * @returns {IAssertDist}\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    protected getOption(context: ITaskContext): IAssertDist {\r\n        return context.option;\r\n    }\r\n\r\n    /**\r\n     * match pipe Operate\r\n     * \r\n     * @protected\r\n     * @param {IOperate} p\r\n     * @param {string} name\r\n     * @param {ITaskContext} ctx\r\n     * @param {IOperate} [trsOperate]\r\n     * @param {boolean} [isOutput=false]\r\n     * @returns\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    protected match(p: IOperate, name: string, ctx: ITaskContext, trsOperate?: IOperate, isOutput = false) {\r\n        if (!p) {\r\n            return false;\r\n        }\r\n        if (p.name && !name.endsWith(ctx.toStr(p.name))) {\r\n            return false;\r\n        }\r\n\r\n        if (p.oper && (p.oper & ctx.oper) <= 0) {\r\n            return false;\r\n        }\r\n\r\n        if (isOutput && p.noneOutput) {\r\n            return false;\r\n        } else if (!isOutput && p.nonePipe) {\r\n            return false;\r\n        }\r\n\r\n        if (trsOperate) {\r\n            if (trsOperate.name && !name.endsWith(ctx.toStr(trsOperate.name))) {\r\n                return false;\r\n            }\r\n            if (trsOperate.oper && (trsOperate.oper & ctx.oper) <= 0) {\r\n                return false;\r\n            }\r\n\r\n            if (isOutput && trsOperate.noneOutput) {\r\n                return false;\r\n            } else if (!isOutput && trsOperate.nonePipe) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * convert custom pipe result to Promise.\r\n     * \r\n     * @protected\r\n     * @param {ITransform} source\r\n     * @param {ICustomPipe} opt\r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} gulp\r\n     * @returns\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    protected cpipe2Promise(source: ITransform, opt: ICustomPipe, context: ITaskContext, dist: IAssertDist, gulp: Gulp) {\r\n        return new Promise<ITransform>((resolve, reject) => {\r\n            let ps = opt.pipe(source, context, dist, gulp, (err) => {\r\n                if (err) {\r\n                    reject(err);\r\n                } else {\r\n                    resolve();\r\n                }\r\n            });\r\n            if (ps) {\r\n                Promise.resolve(ps).then(resolve, reject);\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n    protected operateFileds = ['name', 'oper', 'order', 'nonePipe', 'noneOutput'];\r\n    /**\r\n     * get transform Operate.\r\n     * \r\n     * @protected\r\n     * @param {ITransform} source\r\n     * @returns {IOperate}\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    protected getTransformOperate(source: ITransform): IOperate {\r\n        return _.pick(source, this.operateFileds);\r\n    }\r\n\r\n    /**\r\n     * set transform Operate.\r\n     * \r\n     * @protected\r\n     * @param {ITransform} source\r\n     * @param {IOperate} operate\r\n     * @returns\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    protected setTransformOperate(source: ITransform, operate: IOperate) {\r\n        if (!source) {\r\n            return;\r\n        }\r\n        _.each(this.operateFileds, n => {\r\n            if (!_.isUndefined(operate[n])) {\r\n                source[n] = operate[n];\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * covert pipes transform to Promise.\r\n     * \r\n     * @protected\r\n     * @param {ITransform} source\r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} gulp\r\n     * @param {Pipe[]} [pipes]\r\n     * @returns\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    protected pipes2Promise(source: ITransform, ctx: ITaskContext, dist: IAssertDist, gulp: Gulp, pipes?: Pipe[]) {\r\n        let name = ctx.subTaskName(dist, this.name);\r\n        let oper = this.getTransformOperate(source);\r\n        return Promise.all(_.map(pipes || this.pipes(ctx, dist, gulp), (p: Pipe) => {\r\n            if (_.isFunction(p)) {\r\n                return p(ctx, dist, gulp);\r\n            } else {\r\n                if (!this.match(p, name, ctx, oper)) {\r\n                    return null;\r\n                } else {\r\n                    return Promise.resolve(p.toTransform(ctx, dist, gulp))\r\n                        .then(trs => {\r\n                            trs.order = p.order;\r\n                            return trs;\r\n                        });\r\n                }\r\n            }\r\n        }))\r\n            .then(tanseq => {\r\n\r\n                let tans = sortOrder<ITransform>(tanseq, it => it.order, ctx, true);\r\n\r\n                _.each(tans, (stream: ITransform) => {\r\n                    if (!this.match(stream, name, ctx, oper)) {\r\n                        return;\r\n                    }\r\n\r\n                    if (_.isFunction(stream.transformSourcePipe)) {\r\n                        source = stream.transformSourcePipe(source);\r\n                    } else if (_.isFunction(source.transformPipe)) {\r\n                        source = source.transformPipe(stream);\r\n                    } else {\r\n                        source = source.pipe(stream);\r\n                    }\r\n                });\r\n                this.setTransformOperate(source, oper);\r\n                return source;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * output pipes transform to Promise.\r\n     * \r\n     * @protected\r\n     * @param {ITransform} source\r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} gulp\r\n     * @param {OutputPipe[]} [output]\r\n     * @returns\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    protected output2Promise(source: ITransform, context: ITaskContext, dist: IAssertDist, gulp: Gulp, output?: OutputPipe[]) {\r\n        let name = context.subTaskName(dist, this.name);\r\n        let oper = this.getTransformOperate(source);\r\n        let outputs = output || this.output(context, dist, gulp);\r\n        return Promise.all(_.map(outputs, output => {\r\n            if (_.isFunction(output)) {\r\n                return output(source, context, dist, gulp);\r\n            } else {\r\n                if (!this.match(output, name, context, oper, true)) {\r\n                    return null;\r\n                } else {\r\n                    return output.toTransform(source, context, dist, gulp);\r\n                }\r\n            }\r\n        }))\r\n            .then(outputs => {\r\n                return Promise.all(_.map(outputs, output => {\r\n                    return new Promise((resolve, reject) => {\r\n                        if (output) {\r\n                            output\r\n                                .once('end', () => {\r\n                                    resolve(output);\r\n                                })\r\n                                .once('error', reject);\r\n                        } else {\r\n                            resolve();\r\n                        }\r\n                    }).then(result => {\r\n                        output.removeAllListeners('error');\r\n                        output.removeAllListeners('end');\r\n                        return result;\r\n                    });\r\n                }));\r\n            })\r\n    }\r\n\r\n    /**\r\n     * each one source stream works.\r\n     * \r\n     * @protected\r\n     * @param {ITransform} source\r\n     * @param {ITaskContext} ctx\r\n     * @param {IAssertDist} option\r\n     * @param {Gulp} gulp\r\n     * @param {Pipe[]} [pipes]\r\n     * @param {OutputPipe[]} [output]\r\n     * @returns\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    protected working(source: ITransform, ctx: ITaskContext, option: IAssertDist, gulp: Gulp, pipes?: Pipe[], output?: OutputPipe[]) {\r\n        return Promise.resolve(source)\r\n            .then(psrc => this.customPipe(psrc, ctx, option, gulp))\r\n            .then(psrc => this.pipes2Promise(psrc, ctx, option, gulp, pipes))\r\n            .then(psrc => this.output2Promise(psrc, ctx, option, gulp, output))\r\n            .catch(err => {\r\n                console.log(chalk.red(err));\r\n                process.exit(0);\r\n            });\r\n    }\r\n\r\n    /**\r\n     * execute task working\r\n     * \r\n     * @param {ITaskContext} context\r\n     * @param {Gulp} gulp\r\n     * @returns {Promise<any>}\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    execute(context: ITaskContext, gulp: Gulp): Promise<any> {\r\n        let option = this.getOption(context);\r\n        return Promise.resolve(this.source(context, option, gulp))\r\n            .then(stream => {\r\n                if (_.isArray(stream)) {\r\n                    if (this.runWay === RunWay.parallel) {\r\n                        return Promise.all(_.map(stream, st => this.working(st, context, option, gulp)));\r\n                    } else if (this.runWay === RunWay.sequence) {\r\n                        let pthen: Promise<any>;\r\n                        _.each(stream, st => {\r\n                            if (!pthen) {\r\n                                pthen = this.working(st, context, option, gulp);\r\n                            } else {\r\n                                pthen = pthen.then(() => {\r\n                                    return this.working(st, context, option, gulp);\r\n                                });\r\n                            }\r\n                        });\r\n                        return pthen;\r\n                    } else {\r\n                        return Promise.reject('runWay setting error.');\r\n                    }\r\n                } else {\r\n                    return this.working(stream, context, option, gulp);\r\n                }\r\n            });\r\n    }\r\n\r\n    /**\r\n     * setup task works.\r\n     * \r\n     * @param {ITaskContext} context\r\n     * @param {Gulp} [gulp]\r\n     * @returns {TaskResult}\r\n     * \r\n     * @memberOf PipeTask\r\n     */\r\n    setup(context: ITaskContext, gulp?: Gulp): TaskResult {\r\n        gulp = gulp || coregulp;\r\n        // let option = this.getOption(context);\r\n        let tk = context.subTaskName(this.getInfo());\r\n        console.log(`register ${this.name || ''} task:`, chalk.cyan(tk));\r\n\r\n        gulp.task(tk, () => {\r\n            return this.execute(context, gulp);\r\n        });\r\n\r\n        this.info.taskName = tk;\r\n\r\n        return tk;\r\n    }\r\n}\r\n"]}