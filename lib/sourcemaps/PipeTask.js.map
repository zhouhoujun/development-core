{"version":3,"sources":["PipeTask.ts"],"names":["sortOrder_1","require","coregulp","chalk","_","RunWay_1","PipeTask","info","this","runWay","RunWay","parallel","operateKey","operateFileds","name","prototype","getInfo","source","ctx","dist","gulp","option","isFunction","loader","src","getSrc","pipes","filter","p","opps","length","concat","output","isString","isArray","stream","pipe","dest","getDist","customPipe","prsrc","oper","_this","cfgopt","getTransformOperate","cpipe2Promise","then","setTransformOperate","getOption","context","match","trsOperate","isOutput","matchOperate","endsWith","toStr","taskName","to","noneOutput","nonePipe","opt","Promise","resolve","reject","ps","err","pick","operate","soperate","each","n","isUndefined","pipes2Promise","all","map","toTransform","trs","tanseq","tans","sortOrder","it","order","transformSourcePipe","transformPipe","output2Promise","outputs","once","result","removeAllListeners","working","psrc","execute","st","sequence","pthen_1","setup","tk","console","log","cyan","task","exports"],"mappings":"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","file":"../PipeTask.js","sourcesContent":["import { Gulp } from 'gulp';\r\nimport { sortOrder } from './utils/sortOrder';\r\nimport * as coregulp from 'gulp';\r\nimport * as chalk from 'chalk';\r\nimport * as _ from 'lodash';\r\nimport { ITask, ITaskInfo } from './ITask';\r\nimport { ITaskContext } from './ITaskContext';\r\nimport { IAssertDist } from './IAssertDist';\r\nimport { TransformSource, Pipe, OutputPipe, TaskResult } from './types';\r\nimport { RunWay } from './RunWay';\r\nimport { IPipeOption } from './IPipeOption';\r\nimport { ITransform } from './ITransform';\r\nimport { IPipe } from './IPipe';\r\nimport { ICustomPipe } from './ICustomPipe';\r\n\r\n/**\r\n * pipe task.\r\n *\r\n * @export\r\n * @interface IPipeWork\r\n */\r\nexport interface IPipeTask extends ITask {\r\n    /**\r\n     * task default name.\r\n     *\r\n     * @type {string}\r\n     * @memberOf IPipeTask\r\n     */\r\n    name: string;\r\n    /**\r\n     * gulp src stream.\r\n     *\r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} gulp\r\n     * @returns {(TransformSource | Promise<TransformSource>)}\r\n     *\r\n     * @memberOf IPipeTask\r\n     */\r\n    source(context: ITaskContext, dist: IAssertDist, gulp: Gulp): TransformSource | Promise<TransformSource>;\r\n    /**\r\n     * task pipe works.\r\n     *\r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} [gulp]\r\n     * @returns {Pipe[]}\r\n     *\r\n     * @memberOf IPipeTask\r\n     */\r\n    pipes(context: ITaskContext, dist: IAssertDist, gulp?: Gulp): Pipe[];\r\n\r\n    /**\r\n     * output pipes.\r\n     *\r\n     * @param {ITaskContext} [context]\r\n     * @param {Gulp} [gulp]\r\n     * @returns {OutputPipe[]}\r\n     *\r\n     * @memberOf IPipeTask\r\n     */\r\n    output(context: ITaskContext, dist: IAssertDist, gulp?: Gulp): OutputPipe[];\r\n    /**\r\n     * execute task works.\r\n     *\r\n     * @param {ITaskContext} context\r\n     * @param {Gulp} [gulp]\r\n     * @returns {Promise<any>}\r\n     *\r\n     * @memberOf IPipeTask\r\n     */\r\n    execute(context: ITaskContext, gulp?: Gulp): Promise<any>;\r\n}\r\n\r\n/**\r\n * Task base class.\r\n *\r\n * @export\r\n * @class Task\r\n * @implements {ITask}\r\n */\r\nexport abstract class PipeTask implements IPipeTask {\r\n    /**\r\n     * run mutil source stream way. default parallel.\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    public runWay = RunWay.parallel;\r\n    /**\r\n     * task default name.\r\n     *\r\n     * @type {string}\r\n     * @memberOf PipeTask\r\n     */\r\n    name: string;\r\n\r\n\r\n    constructor(info?: ITaskInfo) {\r\n        this.info = info || {};\r\n        this.info.name = this.info.name || this.name;\r\n    }\r\n\r\n    protected info: ITaskInfo;\r\n\r\n    /**\r\n     * get task info.\r\n     *\r\n     * @type {ITaskInfo}\r\n     * @memberOf PipeTask\r\n     */\r\n    public getInfo(): ITaskInfo {\r\n        if (!this.info.name) {\r\n            this.info.name = this.name;\r\n        }\r\n        return this.info;\r\n    }\r\n\r\n    /**\r\n     * source streams.\r\n     *\r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} option\r\n     * @param {Gulp} gulp\r\n     * @returns {(TransformSource | Promise<TransformSource>)}\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    source(ctx: ITaskContext, dist: IAssertDist, gulp: Gulp): TransformSource | Promise<TransformSource> {\r\n        let option = ctx.option;\r\n        if (option.source) {\r\n            return _.isFunction(option.source) ? option.source(ctx, dist, gulp) : option.source;\r\n        }\r\n        let loader = <IPipeOption>option['loader'];\r\n        if (loader && option.source) {\r\n            return _.isFunction(loader.source) ? loader.source(ctx, dist, gulp) : loader.source;\r\n        }\r\n        return gulp.src(ctx.getSrc(this.getInfo()));\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * task pipe works.\r\n     *\r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} [gulp]\r\n     * @returns {Pipe[]}\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    pipes(ctx: ITaskContext, dist: IAssertDist, gulp?: Gulp): Pipe[] {\r\n        let option = ctx.option;\r\n        let pipes: Pipe[] = null;\r\n        let loader = <IPipeOption>option['loader'];\r\n        if (loader && _.isFunction(loader.pipes)) {\r\n            pipes = _.isFunction(loader.pipes) ? loader.pipes(ctx, option, gulp) : _.filter(<Pipe[]>loader.pipes, p => p);\r\n        }\r\n\r\n        if (option.pipes) {\r\n            let opps = _.isFunction(option.pipes) ? option.pipes(ctx, option, gulp) : _.filter(<Pipe[]>option.pipes, p => p);\r\n            if (opps && opps.length > 0) {\r\n                pipes = pipes ? pipes.concat(opps) : opps;\r\n            }\r\n        }\r\n        return pipes || [];\r\n    }\r\n\r\n    /**\r\n     * output pipes.\r\n     *\r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} [gulp]\r\n     * @returns {OutputPipe[]}\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    output(ctx: ITaskContext, dist: IAssertDist, gulp?: Gulp): OutputPipe[] {\r\n        let option = ctx.option;\r\n        let pipes: OutputPipe[] = null;\r\n        let loader = <IPipeOption>option['loader'];\r\n        if (loader && !_.isString(loader) && !_.isArray(loader)) {\r\n            if (loader.output) {\r\n                pipes = _.isFunction(loader.output) ? loader.output(ctx, option, gulp) : _.filter(<OutputPipe[]>loader.pipes, p => p);\r\n            } else if (loader.output === null) {\r\n                return [(stream) => stream];\r\n            }\r\n        }\r\n        if (option.output) {\r\n            let opps = _.isFunction(option.output) ? option.output(ctx, option, gulp) : _.filter(<OutputPipe[]>option.output, p => p);\r\n            if (opps && opps.length > 0) {\r\n                pipes = pipes ? pipes.concat(opps) : opps;\r\n            }\r\n        } else if (option.output === null) {\r\n            return [(stream) => stream];\r\n        }\r\n\r\n        return pipes || [(stream) => stream.pipe(gulp.dest(ctx.getDist(dist)))]\r\n    }\r\n\r\n    /**\r\n     *  custom pipe Promise.\r\n     *\r\n     * @protected\r\n     * @param {ITransform} source\r\n     * @param {ITaskContext} ctx\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} gulp\r\n     * @returns\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    protected customPipe(source: ITransform, ctx: ITaskContext, dist: IAssertDist, gulp: Gulp): ITransform | Promise<ITransform> {\r\n        let cfgopt = ctx.option;\r\n        let loader = <IPipeOption>cfgopt['loader'];\r\n        let prsrc: Promise<ITransform>;\r\n        let oper;\r\n        if (cfgopt.pipe) {\r\n            oper = this.getTransformOperate(source);\r\n            prsrc = this.cpipe2Promise(source, cfgopt, ctx, dist, gulp);\r\n        }\r\n        if (loader && !_.isString(loader) && !_.isArray(loader) && loader.pipe) {\r\n            oper = this.getTransformOperate(source);\r\n            prsrc = prsrc ?\r\n                prsrc.then(stream => {\r\n                    this.setTransformOperate(stream, oper);\r\n                    return this.cpipe2Promise(stream, loader, ctx, dist, gulp)\r\n                })\r\n                : this.cpipe2Promise(source, loader, ctx, dist, gulp);\r\n        }\r\n\r\n        if (prsrc) {\r\n            return prsrc.then(stream => {\r\n                this.setTransformOperate(stream, oper);\r\n                return stream;\r\n            });\r\n        }\r\n\r\n        return source;\r\n    }\r\n\r\n    /**\r\n     * get option.\r\n     *\r\n     * @protected\r\n     * @param {ITaskContext} context\r\n     * @returns {IAssertDist}\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    protected getOption(context: ITaskContext): IAssertDist {\r\n        return context.option;\r\n    }\r\n\r\n    /**\r\n     * match pipe Operate\r\n     *\r\n     * @protected\r\n     * @param {IPipe} p\r\n     * @param {string} name\r\n     * @param {ITaskContext} ctx\r\n     * @param {IPipe} [trsOperate]\r\n     * @param {boolean} [isOutput=false]\r\n     * @returns\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    protected match(p: IPipe, name: string, ctx: ITaskContext, trsOperate?: IPipe, isOutput = false) {\r\n        // return this.matchOperate(p, name, ctx, isOutput) && (!trsOperate || (trsOperate && this.matchOperate(trsOperate, name, ctx, isOutput)));\r\n        return this.matchOperate(p, name, ctx, isOutput) || (trsOperate && this.matchOperate(trsOperate, name, ctx, isOutput));\r\n    }\r\n\r\n    /**\r\n     * match operate.\r\n     * @param p\r\n     * @param name\r\n     * @param ctx\r\n     * @param isOutput\r\n     */\r\n    protected matchOperate(p: IPipe, name: string, ctx: ITaskContext, isOutput = false) {\r\n        if (!p) {\r\n            return false;\r\n        }\r\n        if (p.name && !name.endsWith(ctx.toStr(p.taskName || p.name))) {\r\n            return false;\r\n        }\r\n\r\n        if (p.oper && (ctx.to(p.oper) & ctx.oper) <= 0) {\r\n            return false;\r\n        }\r\n\r\n        if (isOutput && p.noneOutput === true) {\r\n            return false;\r\n        } else if (!isOutput && p.nonePipe === true) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * convert custom pipe result to Promise.\r\n     *\r\n     * @protected\r\n     * @param {ITransform} source\r\n     * @param {ICustomPipe} opt\r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} gulp\r\n     * @returns\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    protected cpipe2Promise(source: ITransform, opt: ICustomPipe, context: ITaskContext, dist: IAssertDist, gulp: Gulp) {\r\n        return new Promise<ITransform>((resolve, reject) => {\r\n            let ps = opt.pipe(source, context, dist, gulp, (err) => {\r\n                if (err) {\r\n                    reject(err);\r\n                } else {\r\n                    resolve();\r\n                }\r\n            });\r\n            if (ps) {\r\n                Promise.resolve(ps).then(resolve, reject);\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n    protected operateKey = 'pipe_operate';\r\n    protected operateFileds = ['name', 'oper', 'order', 'nonePipe', 'noneOutput'];\r\n    /**\r\n     * get transform Operate.\r\n     *\r\n     * @protected\r\n     * @param {ITransform | OutputPipe} source\r\n     * @returns {IPipe}\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    protected getTransformOperate(source: ITransform | OutputPipe): IPipe {\r\n        if (!source) {\r\n            return null;\r\n        }\r\n        return (source[this.operateKey] ? source[this.operateKey] : _.pick(source, this.operateFileds)) as IPipe;\r\n    }\r\n\r\n    /**\r\n     * set transform Operate.\r\n     *\r\n     * @protected\r\n     * @param {ITransform | OutputPipe} source\r\n     * @param {IPipe} operate\r\n     * @returns\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    protected setTransformOperate(source: ITransform | OutputPipe, operate: IPipe) {\r\n        if (!source) {\r\n            return;\r\n        }\r\n\r\n        let soperate = source[this.operateKey] = source[this.operateKey] || {};\r\n\r\n        _.each(this.operateFileds, n => {\r\n            if (!_.isUndefined(operate[n])) {\r\n                soperate[n] = operate[n];\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * covert pipes transform to Promise.\r\n     *\r\n     * @protected\r\n     * @param {ITransform} source\r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} gulp\r\n     * @param {Pipe[]} [pipes]\r\n     * @returns\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    protected pipes2Promise(source: ITransform, ctx: ITaskContext, dist: IAssertDist, gulp: Gulp, pipes?: Pipe[]) {\r\n        let name = ctx.taskName(dist, this.name);\r\n        let oper = this.getTransformOperate(source);\r\n        if (!this.match(oper, name, ctx)) {\r\n            return Promise.resolve(source);\r\n        }\r\n        pipes = pipes || this.pipes(ctx, dist, gulp);\r\n        return Promise.all(_.map(pipes, (p: Pipe) => {\r\n            if (_.isFunction(p)) {\r\n                return p(ctx, dist, gulp);\r\n            } else {\r\n                if (!this.match(p, name, ctx)) {\r\n                    return null;\r\n                } else {\r\n                    p.pipe = p.pipe || p.toTransform;\r\n                    if (!p.pipe) {\r\n                        return null;\r\n                    }\r\n                    return Promise.resolve(p.pipe(ctx, dist, gulp))\r\n                        .then(trs => {\r\n                            // trs.order = ctx.to(p.order)\r\n                            this.setTransformOperate(trs, p);\r\n                            // trs.order = p.order;\r\n                            return trs;\r\n                        });\r\n                }\r\n            }\r\n        }))\r\n            .then(tanseq => {\r\n\r\n                let tans = sortOrder<ITransform>(tanseq, it => this.getTransformOperate(it).order, ctx, true);\r\n\r\n                _.each(tans, (stream: ITransform) => {\r\n                    if (!this.match(this.getTransformOperate(stream), name, ctx, oper)) {\r\n                        return;\r\n                    }\r\n\r\n                    if (_.isFunction(stream.transformSourcePipe)) {\r\n                        source = stream.transformSourcePipe(source);\r\n                    } else if (_.isFunction(source.transformPipe)) {\r\n                        source = source.transformPipe(stream);\r\n                    } else {\r\n                        source = source.pipe(stream);\r\n                    }\r\n                });\r\n                this.setTransformOperate(source, oper);\r\n                return source;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * output pipes transform to Promise.\r\n     *\r\n     * @protected\r\n     * @param {ITransform} source\r\n     * @param {ITaskContext} context\r\n     * @param {IAssertDist} dist\r\n     * @param {Gulp} gulp\r\n     * @param {OutputPipe[]} [outputs]\r\n     * @returns\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    protected output2Promise(source: ITransform, context: ITaskContext, dist: IAssertDist, gulp: Gulp, outputs?: OutputPipe[]) {\r\n        let name = context.taskName(dist, this.name);\r\n        let oper = this.getTransformOperate(source);\r\n        outputs = outputs || this.output(context, dist, gulp);\r\n        return Promise.all(_.map(outputs, output => {\r\n            if (_.isFunction(output)) {\r\n                return output(source, context, dist, gulp);\r\n            } else {\r\n                if (!this.match(this.getTransformOperate(output), name, context, oper, true)) {\r\n                    return null;\r\n                } else {\r\n                    return output.toTransform(source, context, dist, gulp);\r\n                }\r\n            }\r\n        }))\r\n            .then(outputs => {\r\n                return Promise.all(_.map(outputs, output => {\r\n                    return new Promise((resolve, reject) => {\r\n                        if (output) {\r\n                            output\r\n                                .once('end', () => {\r\n                                    resolve(output);\r\n                                })\r\n                                .once('error', reject);\r\n                        } else {\r\n                            resolve();\r\n                        }\r\n                    }).then(result => {\r\n                        output.removeAllListeners('error');\r\n                        output.removeAllListeners('end');\r\n                        return result;\r\n                    });\r\n                }));\r\n            })\r\n    }\r\n\r\n    /**\r\n     * each one source stream works.\r\n     *\r\n     * @protected\r\n     * @param {ITransform} source\r\n     * @param {ITaskContext} ctx\r\n     * @param {IAssertDist} option\r\n     * @param {Gulp} gulp\r\n     * @param {Pipe[]} [pipes]\r\n     * @param {OutputPipe[]} [output]\r\n     * @returns\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    protected working(source: ITransform, ctx: ITaskContext, option: IAssertDist, gulp: Gulp, pipes?: Pipe[], output?: OutputPipe[]) {\r\n        return Promise.resolve(source)\r\n            .then(psrc => this.customPipe(psrc, ctx, option, gulp))\r\n            .then(psrc => this.pipes2Promise(psrc, ctx, option, gulp, pipes))\r\n            .then(psrc => this.output2Promise(psrc, ctx, option, gulp, output))\r\n    }\r\n\r\n    /**\r\n     * execute task working\r\n     *\r\n     * @param {ITaskContext} context\r\n     * @param {Gulp} [gulp]\r\n     * @returns {Promise<any>}\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    execute(context: ITaskContext, gulp?: Gulp): Promise<any> {\r\n        let option = this.getOption(context);\r\n        return Promise.resolve(this.source(context, option, gulp))\r\n            .then(stream => {\r\n                if (_.isArray(stream)) {\r\n                    if (this.runWay === RunWay.parallel) {\r\n                        return Promise.all(_.map(stream, st => this.working(st, context, option, gulp)));\r\n                    } else if (this.runWay === RunWay.sequence) {\r\n                        let pthen: Promise<any>;\r\n                        _.each(stream, st => {\r\n                            if (!pthen) {\r\n                                pthen = this.working(st, context, option, gulp);\r\n                            } else {\r\n                                pthen = pthen.then(() => {\r\n                                    return this.working(st, context, option, gulp);\r\n                                });\r\n                            }\r\n                        });\r\n                        return pthen;\r\n                    } else {\r\n                        return Promise.reject('runWay setting error.');\r\n                    }\r\n                } else {\r\n                    return this.working(stream, context, option, gulp);\r\n                }\r\n            });\r\n    }\r\n\r\n    /**\r\n     * setup task works.\r\n     *\r\n     * @param {ITaskContext} context\r\n     * @param {Gulp} [gulp]\r\n     * @returns {TaskResult}\r\n     *\r\n     * @memberOf PipeTask\r\n     */\r\n    setup(context: ITaskContext, gulp?: Gulp): TaskResult {\r\n        gulp = gulp || coregulp;\r\n        // let option = this.getOption(context);\r\n        let tk = context.taskName(this.getInfo());\r\n        console.log(`register ${this.name || ''} task:`, chalk.cyan(tk));\r\n\r\n        gulp.task(tk, () => {\r\n            return this.execute(context, gulp);\r\n        });\r\n\r\n        this.info.taskName = tk;\r\n\r\n        return tk;\r\n    }\r\n}\r\n"]}