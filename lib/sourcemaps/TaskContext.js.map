{"version":3,"sources":["TaskContext.ts"],"names":["bindingConfig","cfg","parent","createContext","opt","option","add","TaskContext","currentOperation","env","oper","deploy","Operation_1","Operation","release","build","watch","test","serve","e2e","getAssertSrc","assert","src","testSrc","e2eSrc","watchSrc","clean","cleanSrc","dist","getCurrentDist","ds","ctx","taskStringVal","deployDist","releaseDist","e2eDist","testDist","buildDist","files","express","filter","mapping","Promise","resolve","globby","then","_","map","taskSourceVal","isFunction","name","require","gulp","chalk","child_process_1","minimist","generateTask_1","taskSequence_1","sortOrder_1","match_1","absolute_1","findTasks_1","path","fs","Mode_1","RunWay_1","NodeSequence_1","exports","NULLBuilder","node","isBuilt","globals","packages","this","taskseq","sequence","children","createEnv","setConfig","Object","defineProperty","prototype","_gulp","_builder","builder","process","argv","slice","string","default","NODE_ENV","setEnvViaOperate","undefined","extend","root","getRootPath","to","getConfig","isConfig","obj","context","curcfg","omit","remove","push","items","each","i","isTask","find","mode","item","isFinded","contexts","Mode","traverse","r","route","eachChildren","trans","arr","matchCompare","task","match","getSrc","relative","c","absoluteSrc","getDist","absolutePath","subTaskName","ext","taskName","names","toStr","t","reverse","isString","defaultTaskName","join","findTasks","module","envmatch","group","findTasksInModule","findTasksInDir","dirs","findTaskDefine","findTaskDefineInModule","findTaskDefineInDir","fileFilter","toSequence","tasks","zipName","runSequence","runTaskSequence","zipSequence","flattenSequence","generateTask","gtask","concat","addToSequence","_this","getRootFolders","getFolders","pathstr","dir","readdirSync","folders","d","sf","f","lstatSync","isDirectory","fl","getDistFolders","toRootSrc","toRootPath","toDistSrc","toDistPath","val","toSrc","source","toUrl","basePath","toPath","replace","getPackage","filename","packageFile","getNpmModuleVersion","packageCfg","version","dependencies","devDependencies","hasNpmModule","setupChildren","all","setup","seq","load","subtasks","tseq","srcs","ordertask","sortOrder","order","subseq","idx","isArray","length","ptasks","it","getRunSequence","tk","runWay","RunWay","parallel","nodeSequence","NodeSequence","after","splice","apply","addTask","_i","arguments","_a","removeTask","indexOf","run","help","runDynamic","getInfo","ps","st","execute","execShell","cmd","options","allowError","reject","console","log","cyan","shell","exec","err","stdout","stderr","on","data","code","execFile","file","args","existsSync","proc","yellow","printHelp","isBoolean","registerTasks","globalTasks","keys"],"mappings":"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","file":"../TaskContext.js","sourcesContent":["import *as _ from 'lodash';\r\nimport { Gulp } from 'gulp';\r\nimport *as gulp from 'gulp';\r\nimport * as chalk from 'chalk';\r\nimport { exec, execFile, ExecOptions, ExecFileOptions } from 'child_process';\r\nimport * as minimist from 'minimist';\r\nimport { generateTask } from './generateTask';\r\nimport { toSequence, runSequence, addToSequence, zipSequence, flattenSequence, runTaskSequence } from './taskSequence';\r\nimport { sortOrder } from './utils/sortOrder';\r\nimport { matchCompare } from './utils/match';\r\nimport { absoluteSrc, absolutePath } from './utils/absolute';\r\nimport { findTasksInModule, findTaskDefineInModule, findTasksInDir, findTaskDefineInDir } from './findTasks';\r\nimport { IPipeTask } from './PipeTask';\r\nimport *as path from 'path';\r\nimport *as fs from 'fs';\r\nimport { ITaskConfig } from './TaskConfig';\r\nimport { ITaskContext } from './ITaskContext';\r\nimport { IAssertOption } from './IAssertOption';\r\nimport { Builder } from './Builder';\r\nimport { IAsserts } from './IAsserts';\r\nimport { ITask, ITaskInfo } from './ITask';\r\nimport { Src, TaskString, TaskSource, ZipTaskName, folderCallback, CtxType } from './types';\r\nimport { Operation } from './Operation';\r\nimport { IEnvOption } from './IEnvOption';\r\nimport { Express } from './utils/Express';\r\nimport { Mode } from './Mode';\r\nimport { ITaskDecorator } from './ITaskDecorator';\r\nimport { ITaskDefine } from './ITaskDefine';\r\nimport { IDynamicTaskOption } from './IDynamicTaskOption';\r\nimport { RunWay } from './RunWay';\r\nimport { NodeSequence } from './NodeSequence';\r\nimport { IAssertDist } from './IAssertDist';\r\nconst globby = require('globby');\r\n\r\n/**\r\n *binding Config, create task context.\r\n *\r\n *@export\r\n *@param {ITaskConfig} cfg\r\n *@param {ITaskContext} [parent]\r\n *@returns {ITaskContext}\r\n */\r\nexport function bindingConfig(cfg: ITaskConfig, parent?: ITaskContext): ITaskContext {\r\n    return createContext(cfg, parent);\r\n}\r\n\r\n/**\r\n *create Task context.\r\n *\r\n *@export\r\n *@param {ITaskConfig | IAssertOption} cfg\r\n *@param {ITaskContext} [parent]\r\n *@returns {ITaskContext}\r\n */\r\nexport function createContext(cfg: ITaskConfig | IAssertOption, parent?: ITaskContext): ITaskContext {\r\n    let opt: ITaskConfig = (cfg && cfg['option']) ? (cfg as ITaskConfig) : ({ option: cfg } as ITaskConfig);\r\n    if (opt.createContext) {\r\n        return opt.createContext(cfg, parent);\r\n    }\r\n    return parent ? parent.add(opt) : new TaskContext(opt);\r\n}\r\n\r\nconst NULLBuilder = <Builder>{\r\n    build<T extends IAsserts>(node: ITaskContext, option?: T): ITaskContext {\r\n        return node;\r\n    },\r\n\r\n    // buildChildren<T extends IAsserts>(node: ITaskContext, option?: T): ITaskContext {\r\n    //     return node;\r\n    // },\r\n\r\n    isBuilt(node: ITaskContext): boolean {\r\n        return false;\r\n    }\r\n\r\n    // clean(node: ITaskContext) {\r\n\r\n    // }\r\n}\r\n/**\r\n *global data.\r\n */\r\nlet globals = {};\r\nlet packages = {};\r\n\r\n/**\r\n *TaskContext\r\n *\r\n *@export\r\n *@class TaskContext\r\n *@implements {ITaskContext}\r\n */\r\nexport class TaskContext implements ITaskContext {\r\n    protected cfg: ITaskConfig;\r\n    protected taskseq: ITask[] = [];\r\n\r\n    protected sequence: Src[] = [];\r\n    protected children: ITaskContext[] = [];\r\n\r\n    oper: Operation;\r\n    option: IAsserts;\r\n    env: IEnvOption;\r\n    globals: any;\r\n    parent: ITaskContext;\r\n\r\n    constructor(cfg: ITaskConfig) {\r\n        cfg = cfg || {};\r\n        cfg.env = cfg.env || this.createEnv();\r\n        this.setConfig(cfg);\r\n    }\r\n\r\n    private _gulp: Gulp;\r\n    get gulp() {\r\n        return this._gulp || gulp;\r\n    }\r\n    set gulp(gulp: Gulp) {\r\n        this._gulp = gulp;\r\n    }\r\n\r\n    protected _builder: Builder;\r\n    get builder(): Builder {\r\n        return this._builder || NULLBuilder;\r\n    }\r\n\r\n    set builder(builder: Builder) {\r\n        this._builder = builder;\r\n    }\r\n\r\n    protected createEnv(): IEnvOption {\r\n        let env: IEnvOption = minimist(process.argv.slice(2), {\r\n            string: 'env',\r\n            default: { env: process.env.NODE_ENV || 'development' }\r\n        }) as IEnvOption;\r\n        return env;\r\n    }\r\n\r\n    protected setEnvViaOperate(oper: Operation) {\r\n        this.env = this.env || {};\r\n        if ((oper & Operation.deploy) > 0) {\r\n            this.env.deploy = true;\r\n            this.env.release = undefined;\r\n        } else if ((oper & Operation.release) > 0) {\r\n            this.env.release = true;\r\n            this.env.deploy = undefined;\r\n            oper = Operation.release;\r\n        }\r\n\r\n        if ((oper & Operation.watch) > 0) {\r\n            this.env.watch = true;\r\n        }\r\n\r\n        if ((oper & Operation.test) > 0) {\r\n            this.env.test = true;\r\n        }\r\n\r\n        if ((oper & Operation.serve) > 0) {\r\n            this.env.serve = true;\r\n        }\r\n\r\n        if ((oper & Operation.e2e) > 0) {\r\n            this.env.e2e = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     *load config\r\n     *\r\n     *@param {ITaskConfig} cfg\r\n     *\r\n     *@memberof TaskContext\r\n     */\r\n    setConfig(cfg: ITaskConfig) {\r\n        if (!cfg) {\r\n            return;\r\n        }\r\n        if (cfg.env) {\r\n            this.env = cfg.env = _.extend({}, this.env || {}, cfg.env);\r\n            this.oper = currentOperation(this.env);\r\n        }\r\n        // make sure root.\r\n        if (!this.env.root) {\r\n            this.env.root = this.getRootPath();\r\n        }\r\n        if (cfg.oper) {\r\n            this.oper = this.to(cfg.oper);\r\n            this.setEnvViaOperate(this.oper);\r\n        }\r\n        this.globals = cfg.globals || globals;\r\n        if (cfg.option) {\r\n            this.option = cfg.option = _.extend({}, this.option || {}, cfg.option);\r\n        }\r\n        this.cfg = _.extend(this.cfg, cfg);\r\n    }\r\n\r\n    /**\r\n     *get config.\r\n     *\r\n     *@returns {ITaskConfig}\r\n     *\r\n     *@memberof TaskContext\r\n     */\r\n    getConfig(): ITaskConfig {\r\n        return this.cfg || {};\r\n    }\r\n\r\n    protected isConfig(obj: any): boolean {\r\n        return obj && obj['option'];\r\n    }\r\n\r\n    /**\r\n     * add sub ITaskContext\r\n     *\r\n     * @param {(ITaskContext | ITaskConfig | IAssertOption)} context\r\n     * @returns {ITaskContext} sub context.\r\n     * @memberof TaskContext\r\n     */\r\n    add(context: ITaskContext | ITaskConfig | IAssertOption): ITaskContext {\r\n        let ctx: ITaskContext;\r\n        let curcfg: ITaskConfig = _.omit(this.getConfig(), 'option');\r\n        if (context instanceof TaskContext) {\r\n            ctx = context;\r\n            if (ctx.parent) {\r\n                ctx.parent.remove(ctx);\r\n            }\r\n            ctx.setConfig(_.extend({}, curcfg, ctx.getConfig()));\r\n        } else {\r\n            let opt: ITaskConfig = (this.isConfig(context) ? context : { option: context }) as ITaskConfig;\r\n            opt = _.extend({}, curcfg, opt);\r\n            ctx = this.createContext(opt);\r\n        }\r\n        ctx.parent = this;\r\n        this.children.push(ctx);\r\n        // if (!ctx.builder.isBuilt(ctx)) {\r\n        //     ctx.builder.build(ctx);\r\n        // }\r\n        return ctx;\r\n    }\r\n\r\n    /**\r\n     * create context.\r\n     *\r\n     * @protected\r\n     * @param {(ITaskConfig)} cfg\r\n     * @returns {ITaskContext}\r\n     * @memberof TaskContext\r\n     */\r\n    protected createContext(cfg: ITaskConfig): ITaskContext {\r\n        return new TaskContext(cfg)\r\n    }\r\n\r\n    /**\r\n     *remove sub ITaskContext.\r\n     *\r\n     *@param {ITaskContext} [context]\r\n     *\r\n     *@memberOf ITaskContext\r\n     */\r\n    remove(context?: ITaskContext): ITaskContext[] {\r\n        let items = _.remove(this.children, context);\r\n        _.each(items, i => {\r\n            if (i) {\r\n                i.parent = null;\r\n            }\r\n        });\r\n        return items;\r\n    }\r\n\r\n    /**\r\n     * is task class.\r\n     *\r\n     * @param {any} obj\r\n     * @returns {boolean}\r\n     * @memberof TaskContext\r\n     */\r\n    isTask(obj: any): boolean {\r\n        if (!obj) {\r\n            return false;\r\n        }\r\n        if (!_.isFunction(obj)) {\r\n            return false;\r\n        }\r\n        return obj['__task'] || obj['__dynamictask']\r\n    }\r\n\r\n\r\n    /**\r\n     *find sub context via express.\r\n     *\r\n     *@template T\r\n     *@param {(T | Express<T, boolean>)} express\r\n     *@param {Mode} [mode]\r\n     *@returns {T}\r\n     *@memberof TaskContext\r\n     */\r\n    find<T extends ITaskContext>(express: T | Express<T, boolean>, mode?: Mode): T {\r\n        let context: ITaskContext;\r\n        this.each<T>(item => {\r\n            if (context) {\r\n                return false;\r\n            }\r\n            let isFinded = _.isFunction(express) ? express(item) : (<ITaskContext>express) === item;\r\n            if (isFinded) {\r\n                context = item;\r\n                return false;\r\n            }\r\n            return true;\r\n        }, mode);\r\n        return context as T;\r\n    }\r\n\r\n    /**\r\n     *filter items.\r\n     *\r\n     *@template T\r\n     *@param {(Express<T, void | boolean>)} express\r\n     *@param {Mode} [mode]\r\n     *@returns {ITaskContext[]}\r\n     *@memberof TaskContext\r\n     */\r\n    filter<T extends ITaskContext>(express: Express<T, void | boolean>, mode?: Mode): T[] {\r\n        let contexts: ITaskContext[] = [];\r\n        this.each<T>(item => {\r\n            if (express(item)) {\r\n                contexts.push(item);\r\n            }\r\n        }, mode);\r\n        return contexts as T[];\r\n    }\r\n    /**\r\n     *find parent context via express.\r\n     *\r\n     *@param {(ITaskContext | Express<ITaskContext, boolean>)} express\r\n     *@param {Mode} [mode] {enum:['route','children', traverse']} default traverse.\r\n     *\r\n     *@memberOf ITaskContext\r\n     */\r\n    each<T extends ITaskContext>(express: Express<T, void | boolean>, mode?: Mode) {\r\n        mode = mode || Mode.traverse;\r\n        let r;\r\n        switch (mode) {\r\n            case Mode.route:\r\n                r = this.route(express);\r\n                break;\r\n            case Mode.children:\r\n                r = this.eachChildren(express);\r\n                break;\r\n\r\n            case Mode.traverse:\r\n                r = this.trans(express);\r\n                break;\r\n            default:\r\n                r = this.trans(express);\r\n                break;\r\n        }\r\n        return r;\r\n    }\r\n\r\n    /**\r\n     * map context.\r\n     *\r\n     *@template T\r\n     *@param {Express<ITaskContext, T>} express\r\n     *@param {Mode} [mode]\r\n     *@param {Express<ITaskContext, boolean>} [filter]\r\n     *@returns {T[]}\r\n     *\r\n     *@memberof TaskContext\r\n     */\r\n    map<T>(express: Express<ITaskContext, T>, mode?: Mode, filter?: Express<ITaskContext, boolean>): T[] {\r\n        let arr: T[] = []\r\n        this.each((ctx) => {\r\n            if (filter) {\r\n                if (filter(ctx)) {\r\n                    arr.push(express(ctx));\r\n                }\r\n            } else {\r\n                arr.push(express(ctx));\r\n            }\r\n        }, mode);\r\n        return arr;\r\n    }\r\n\r\n    eachChildren(express: Express<ITaskContext, void | boolean>) {\r\n        _.each(this.children, item => {\r\n            return express(item);\r\n        });\r\n    }\r\n\r\n    /**\r\n     *do express work in routing.\r\n     *\r\n     *@param {Express<ITaskContext, void | boolean>} express\r\n     *\r\n     *@memberOf ITaskContext\r\n     */\r\n    route(express: Express<ITaskContext, void | boolean>) {\r\n        if (express(this) === false) {\r\n            return false;\r\n        };\r\n        if (this.parent && this.parent.route) {\r\n            return this.parent.route(express);\r\n        }\r\n    }\r\n    /**\r\n     *translate all sub context to do express work.\r\n     *\r\n     *@param {Express<ITaskContext, void | boolean>} express\r\n     *\r\n     *@memberOf ITaskContext\r\n     */\r\n    trans(express: Express<ITaskContext, void | boolean>) {\r\n        if (express(this) === false) {\r\n            return false;\r\n        }\r\n        _.each(this.children, item => {\r\n            return item.trans(express);\r\n        });\r\n        return true;\r\n    }\r\n\r\n    matchCompare(task: ITaskInfo, match: ITaskInfo): boolean {\r\n        if (this.option.match) {\r\n            return this.option.match(task, match);\r\n        }\r\n        return matchCompare(this, task, match);\r\n    }\r\n\r\n    getSrc(task?: ITaskInfo, relative = false): Src {\r\n        let src: Src;\r\n        let ctx = this;\r\n        let oper = this.to<Operation>(task ? (task.oper || ctx.oper) : ctx.oper);\r\n        if (task && task.assert) {\r\n            src = taskSourceVal(getAssertSrc(task.assert, oper), ctx)\r\n        }\r\n\r\n        if (!src) {\r\n            this.route(c => {\r\n                src = taskSourceVal(getAssertSrc(c.option, oper), c);\r\n                if (src) {\r\n                    return false;\r\n                }\r\n                return true;\r\n            });\r\n        }\r\n        return (relative !== false) ? src : absoluteSrc(ctx.env.root, src);\r\n    }\r\n\r\n    getDist(task?: ITaskInfo, relative = false): string {\r\n        let dist: string;\r\n        let ctx = this;\r\n        // let oper = task ? (task.oper || context.oper) : context.oper;\r\n        if (task && task.assert) {\r\n            dist = getCurrentDist(task.assert, ctx);\r\n        }\r\n        if (!dist) {\r\n            this.route(c => {\r\n                dist = getCurrentDist(c.option, c);\r\n                if (dist) {\r\n                    return false;\r\n                }\r\n                return true;\r\n            });\r\n        }\r\n\r\n        return (relative !== false) ? dist : absolutePath(ctx.env.root, dist);\r\n    }\r\n\r\n    subTaskName(task: TaskString | ITaskInfo, ext?: string) {\r\n        return this.taskName(task, ext);\r\n    }\r\n\r\n    taskName(task: TaskString | ITaskInfo, ext = ''): string {\r\n        let ctx = this;\r\n        let name = '';\r\n        let names = _.filter(this.map(c => {\r\n            return c.toStr(c.option.name);\r\n        }, Mode.route), t => !!t).reverse();\r\n\r\n        if (_.isString(task) || _.isFunction(task)) {\r\n            name = this.toStr(task);\r\n        } else if (task && task !== ctx.option) {\r\n            // oper = task.oper || context.oper;\r\n            let tinf = task as ITaskInfo;\r\n            if (task.name) {\r\n                name = taskStringVal(task.name, ctx)\r\n            }\r\n            if (!name && task.assert && task.assert.name) {\r\n                name = taskStringVal(task.assert.name, ctx)\r\n            }\r\n        }\r\n        if (!name) {\r\n            name = ctx.toStr(ctx.option.defaultTaskName);\r\n        }\r\n\r\n        if (name) {\r\n            names.push(name);\r\n        }\r\n        if (ext) {\r\n            names.push(ext);\r\n        }\r\n\r\n        // console.log('taskName:----------------------\\n', names);\r\n\r\n        return names.join('-');\r\n    }\r\n\r\n    findTasks(module: string | Object, match?: ITaskInfo): Promise<ITask[]> {\r\n        let envmatch: ITaskDecorator = {};\r\n        if (this.env.group) {\r\n            envmatch.group = this.env.group;\r\n        }\r\n        if (this.oper) {\r\n            envmatch.oper = this.oper;\r\n        }\r\n\r\n        return findTasksInModule(module, _.extend(envmatch, match || {}), this);\r\n    }\r\n\r\n    findTasksInDir(dirs: TaskSource, match?: ITaskInfo): Promise<ITask[]> {\r\n        let envmatch: ITaskDecorator = {};\r\n        if (this.env.group) {\r\n            envmatch.group = this.env.group;\r\n        }\r\n        if (this.oper) {\r\n            envmatch.oper = this.oper;\r\n        }\r\n        return findTasksInDir(this.to(dirs), _.extend(envmatch, match || {}), this);\r\n    }\r\n\r\n    findTaskDefine(module: string | Object): Promise<ITaskDefine> {\r\n        return findTaskDefineInModule(module);\r\n    }\r\n\r\n    findTaskDefineInDir(dirs: TaskSource): Promise<ITaskDefine> {\r\n        return findTaskDefineInDir(this.to(dirs));\r\n    }\r\n\r\n    fileFilter(express: Src, filter?: (fileName: string) => boolean, mapping?: (filename: string) => string): Promise<string[]> {\r\n        return files(express, filter, mapping);\r\n    }\r\n\r\n\r\n    /**\r\n     *to Sequence.\r\n     *\r\n     *@param {ITask[]} tasks\r\n     *@param {ZipTaskName} [zipName]\r\n     *@returns {Src[]}\r\n     *\r\n     *@memberof TaskContext\r\n     */\r\n    toSequence(tasks: ITask[], zipName?: ZipTaskName): Src[] {\r\n        return toSequence(this.gulp, tasks, this, zipName);\r\n    }\r\n\r\n    /**\r\n     *filter file in directory.  default implement in bindingConfig.\r\n     *\r\n     *@param {Gulp} gulp\r\n     *@param {Src[]} tasks\r\n     *@returns {Promise<any>}\r\n     *\r\n     *@memberOf ITaskContext\r\n     */\r\n    runSequence(tasks: Src[]): Promise<any> {\r\n        return runSequence(this.gulp, tasks);\r\n    }\r\n\r\n    /**\r\n     *run task sequence in this context.\r\n     *\r\n     *@param {(ITask[] | Promise<ITask[]>)} tasks\r\n     *@param {ZipTaskName} [zipName]\r\n     *@returns {Promise<any>}\r\n     *\r\n     *@memberof TaskContext\r\n     */\r\n    runTaskSequence(tasks: ITask[] | Promise<ITask[]>, zipName?: ZipTaskName): Promise<any> {\r\n        return runTaskSequence(this.gulp, tasks, this, zipName);\r\n    }\r\n\r\n    /**\r\n     *zip task sequence.\r\n     *\r\n     *@param {Src[]} tasks\r\n     *@param {ZipTaskName} [zipName]\r\n     *@returns {string}\r\n     *\r\n     *@memberof ITaskContext\r\n     */\r\n    zipSequence(tasks: Src[], zipName?: ZipTaskName): string {\r\n        return zipSequence(this.gulp, tasks, this, zipName);\r\n    }\r\n\r\n    /**\r\n     *flattenSequence in this context.\r\n     *\r\n     *@param {Src[]} tasks\r\n     *@param {ZipTaskName} [zipName]\r\n     *@returns {string[]}\r\n     *\r\n     *@memberof ITaskContext\r\n     */\r\n    flattenSequence(tasks: Src[], zipName?: ZipTaskName): string[] {\r\n        return flattenSequence(this.gulp, tasks, this, zipName);\r\n    }\r\n\r\n\r\n    /**\r\n     *dynamic generate tasks.  default implement in bindingConfig.\r\n     *\r\n     *@param {(IDynamicTaskOption | IDynamicTaskOption[])} tasks\r\n     *@param {ITaskInfo} [match]\r\n     *@returns {ITask[]}\r\n     *\r\n     *@memberOf ITaskContext\r\n     */\r\n    generateTask(tasks: IDynamicTaskOption | IDynamicTaskOption[], match?: ITaskInfo): ITask[] {\r\n        let ctx = this;\r\n        let gtask = generateTask(this, tasks, _.extend({ oper: ctx.oper }, match || {}));\r\n        this.taskseq = this.taskseq.concat(gtask);\r\n        return this.taskseq;\r\n    }\r\n\r\n    /**\r\n     *add task result to task sequence. default implement in bindingConfig.\r\n     *\r\n     *@param {Src[]} sequence  task sequence.\r\n     *@param {ITaskInfo} task\r\n     *@returns {Src[]}\r\n     *\r\n     *@memberOf ITaskContext\r\n     */\r\n    addToSequence(sequence: Src[], task: ITaskInfo): Src[] {\r\n        if (this.cfg.addToSequence) {\r\n            return this.cfg.addToSequence(sequence, task);\r\n        }\r\n        return addToSequence(sequence, task, this);\r\n    }\r\n\r\n    getRootPath() {\r\n        let root: string;\r\n        if (this.env && this.env.root) {\r\n            root = this.env.root\r\n        } else {\r\n            this.each(c => {\r\n                if (c.env && c.env.root) {\r\n                    root = this.env.root;\r\n                    return false;\r\n                }\r\n                return true;\r\n            }, Mode.route);\r\n        }\r\n        return root;\r\n    }\r\n\r\n    getRootFolders(express?: folderCallback): string[] {\r\n        return this.getFolders(this.getRootPath(), express);\r\n    }\r\n\r\n    getFolders(pathstr: string, express?: folderCallback): string[] {\r\n        let dir = fs.readdirSync(pathstr);\r\n        let folders = [];\r\n        _.each(dir, (d: string) => {\r\n            let sf = path.join(pathstr, d);\r\n            let f = fs.lstatSync(sf);\r\n            if (f.isDirectory()) {\r\n                if (express) {\r\n                    let fl = express(sf, d, this);\r\n                    if (fl) {\r\n                        folders.push(fl);\r\n                    }\r\n                } else {\r\n                    folders.push(sf);\r\n                }\r\n            }\r\n        });\r\n        return folders;\r\n    }\r\n\r\n    getDistFolders(express?: folderCallback, task?: ITaskInfo): string[] {\r\n        return this.getFolders(this.getDist(task), express);\r\n    }\r\n\r\n    toRootSrc(src: Src): Src {\r\n        return absoluteSrc(this.getRootPath(), src);\r\n    }\r\n\r\n    toRootPath(pathstr: string): string {\r\n        return absolutePath(this.getRootPath(), pathstr);\r\n    }\r\n\r\n    toDistSrc(src: Src, task?: ITaskInfo): Src {\r\n        return absoluteSrc(this.getDist(task), src);\r\n    }\r\n\r\n    toDistPath(pathstr: string, task?: ITaskInfo): string {\r\n        return absolutePath(this.getDist(task), pathstr);\r\n    }\r\n\r\n    to<T>(val: CtxType<T>): T {\r\n        return _.isFunction(val) ? val(this) : val;\r\n    }\r\n\r\n    toSrc(source: TaskSource): Src {\r\n        return taskSourceVal(source, this);\r\n    }\r\n\r\n    toStr(name: TaskString): string {\r\n        return taskStringVal(name, this);\r\n    }\r\n\r\n    toUrl(basePath: string, toPath?: string): string {\r\n        return (toPath ? path.relative(basePath, toPath) : basePath).replace(/\\\\/g, '/'); // .replace(/^\\//g, '');\r\n    }\r\n\r\n    getPackage(filename?: TaskString): any {\r\n        filename = filename || this.cfg.packageFile;\r\n        let name = this.toRootPath(this.toStr(filename) || 'package.json');\r\n        if (!packages[name]) {\r\n            packages[name] = require(name);\r\n        }\r\n        return packages[name]\r\n    }\r\n\r\n    getNpmModuleVersion(name: string, packageFile?: string): string {\r\n        let packageCfg = this.getPackage(packageFile);\r\n        if (!packageCfg) {\r\n            return '';\r\n        }\r\n        let version = '';\r\n        if (packageCfg.dependencies) {\r\n            version = packageCfg.dependencies[name]\r\n        }\r\n        if (!version && packageCfg.devDependencies) {\r\n            version = packageCfg.devDependencies[name]\r\n        }\r\n\r\n        return version || '';\r\n\r\n    }\r\n    hasNpmModule(name: string, packageFile?: string): boolean {\r\n        return this.getNpmModuleVersion(name, packageFile) !== '';\r\n    }\r\n\r\n    protected setupChildren(): Promise<ITaskContext[]> {\r\n        return Promise.all(this.map(ctx => {\r\n            return ctx.setup()\r\n                .then(seq => {\r\n                    return ctx;\r\n                });\r\n        }, Mode.children))\r\n    }\r\n\r\n    setup(): Promise<Src[]> {\r\n        if (this.option.oper && (this.oper & this.to(this.option.oper)) <= 0) {\r\n            // this.sequence = null;\r\n            return Promise.resolve(null);\r\n        } else {\r\n            return Promise.resolve(this.load())\r\n                .then(tasks => {\r\n                    return this.setupChildren()\r\n                        .then(subtasks => {\r\n                            return {\r\n                                tseq: tasks,\r\n                                subtasks: subtasks\r\n                            }\r\n                        })\r\n\r\n                })\r\n                .then(srcs => {\r\n                    let opt = this.option as IAsserts;\r\n                    let tseq = srcs.tseq;\r\n                    let ordertask = sortOrder(srcs.subtasks, ctx => ctx.option.order, this);\r\n\r\n                    let subseq: Src[] = [];\r\n                    _.each(ordertask, (t, idx) => {\r\n                        if (_.isArray(t)) {\r\n                            if (t.length > 0) {\r\n                                let ptasks = _.filter(_.map(t, it => this.zipSequence(<Src[]>it.getRunSequence())), it => !!it);\r\n                                if (ptasks.length > 0) {\r\n                                    subseq.push(ptasks);\r\n                                }\r\n                            }\r\n                        } else {\r\n                            let tk = this.zipSequence(t.getRunSequence());\r\n                            tk && subseq.push(tk);\r\n                        }\r\n                    });\r\n\r\n                    // let children = this.zipSequence(subseq, (name, runway) => this.subTaskName(name, (runway === RunWay.sequence ? '-sub-seq' : '-sub-paral')));\r\n                    subseq = this.flattenSequence(subseq);\r\n                    tseq = this.flattenSequence(tseq);\r\n                    if (tseq.length > 0) {\r\n                        tseq = opt.runWay === RunWay.parallel ? [this.flattenSequence(tseq)] : this.flattenSequence(tseq);\r\n                        if (subseq && subseq.length > 0) {\r\n                            if (opt.nodeSequence === NodeSequence.after) {\r\n                                tseq.splice(0, 0, ...subseq);\r\n                            } else {\r\n                                tseq.push(...subseq);\r\n                            }\r\n                        }\r\n                    } else {\r\n                        tseq = subseq;\r\n                    }\r\n\r\n                    this.sequence = tseq;\r\n                    return this.sequence;\r\n                });\r\n        }\r\n    }\r\n\r\n    getRunSequence(): Src[] {\r\n        return this.sequence || [];\r\n    }\r\n\r\n    load(): Src[] | Promise<Src[]> {\r\n        if (!this.builder.isBuilt(this)) {\r\n            return Promise.resolve(this.builder.build(this))\r\n                .then(ctx => {\r\n                    return this.toSequence(this.taskseq);\r\n                });\r\n        } else {\r\n            return this.toSequence(this.taskseq);\r\n        }\r\n    }\r\n\r\n    addTask(...task: ITask[]) {\r\n        this.taskseq.push(...task);\r\n    }\r\n\r\n    removeTask(task: ITask): ITask[] | Promise<ITask[]> {\r\n        let idx = this.taskseq.indexOf(task);\r\n        if (idx >= 0 && idx < this.taskseq.length) {\r\n            return this.taskseq.splice(idx, 1);\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     *run task in this context.\r\n     *\r\n     *@returns {Promise<any>}\r\n     *\r\n     *@memberof TaskContext\r\n     */\r\n    run(): Promise<any> {\r\n        if (this.env.help) {\r\n            return Promise.resolve(this.help())\r\n        } else {\r\n            // if (!this.builder.isBuilt(this)) {\r\n            //     this.builder.build(this);\r\n            // }\r\n            return this.setup()\r\n                .then(tseq => {\r\n                    let opt = this.option as IAsserts;\r\n                    if (opt.runWay === RunWay.parallel) {\r\n                        return this.runSequence([this.flattenSequence(tseq)]);\r\n                    } else {\r\n                        return this.runSequence(tseq);\r\n                    }\r\n                });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * just run task. not register on global tasks.\r\n     * @param tasks\r\n     * @param match\r\n     */\r\n    runDynamic(tasks: IDynamicTaskOption | IDynamicTaskOption[], match?: ITaskInfo): Promise<any> {\r\n        let gtask = sortOrder(generateTask(this, tasks, _.extend({ oper: this.oper }, match || {})), t => t.getInfo().order, this);\r\n        let ps = Promise.resolve();\r\n        _.each(gtask, (t: ITask | ITask[]) => {\r\n            ps = ps.then(() => {\r\n                if (_.isArray(t)) {\r\n                    return Promise.all(_.map(t, st => {\r\n                        return st.execute ? st.execute(this, this.gulp || gulp) : null;\r\n                    }));\r\n                } else {\r\n                    return t.execute ? t.execute(this, this.gulp || gulp) : null;\r\n                }\r\n            });\r\n        });\r\n        return ps;\r\n    }\r\n\r\n    execShell(cmd: string, options?: ExecOptions, allowError = true): Promise<any> {\r\n        if (!cmd) {\r\n            return Promise.resolve();\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            console.log('execute shell:', chalk.cyan(cmd));\r\n            let shell = exec(cmd, options, (err, stdout, stderr) => {\r\n                if (err) {\r\n                    reject(err);\r\n                } else {\r\n                    resolve(stdout);\r\n                }\r\n            });\r\n\r\n            shell.stdout.on('data', data => {\r\n                console.log(data);\r\n            });\r\n\r\n            shell.stderr.on('data', err => {\r\n                console.log(err);\r\n                if (!allowError) {\r\n                    reject(err);\r\n                }\r\n            });\r\n\r\n            shell.on('exit', (code) => {\r\n                console.log(`exit child process with code：${code}`);\r\n                if (code > 0) {\r\n                    reject(code);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    execFile(file: string, args?: string[], options?: ExecFileOptions, allowError = true): Promise<any> {\r\n        if (!file && !fs.existsSync(file)) {\r\n            console.log('file:', chalk.yellow(file), 'no exists.');\r\n            return Promise.resolve();\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            console.log('execute shell:', chalk.cyan(file));\r\n            let proc = execFile(file, args, options, (err, stdout, stderr) => {\r\n                if (err) {\r\n                    reject(err);\r\n                } else {\r\n                    resolve(stdout);\r\n                }\r\n            });\r\n\r\n            proc.stdout.on('data', data => {\r\n                console.log(data);\r\n            });\r\n\r\n            proc.stderr.on('data', data => {\r\n                console.log(data);\r\n                if (!allowError) {\r\n                    reject(data);\r\n                }\r\n            });\r\n\r\n            proc.on('exit', (code) => {\r\n                console.log(`exit child process with code：${code}`);\r\n                if (code > 0) {\r\n                    reject(code);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n\r\n    help() {\r\n        this.cfg.printHelp && this.cfg.printHelp(_.isBoolean(this.env.help) ? '' : this.env.help);\r\n    }\r\n\r\n    tasks(express?: (item: ITask) => boolean): ITask[] {\r\n        return express ? _.filter(this.taskseq, express) : this.taskseq;\r\n    }\r\n\r\n    registerTasks(express?: (item: ITask) => boolean): ITask[] {\r\n        let tasks = [];\r\n        this.each(c => {\r\n            tasks = tasks.concat(c.tasks(express));\r\n        });\r\n        return tasks;\r\n    }\r\n\r\n    globalTasks(): string[] {\r\n        return _.keys(this.globals.tasks || {});\r\n    }\r\n}\r\n\r\n\r\n/**\r\n *get current env Operation.\r\n *\r\n *@export\r\n *@param {EnvOption} env\r\n *@returns\r\n */\r\nfunction currentOperation(env: IEnvOption) {\r\n    let oper: Operation;\r\n    if (env.deploy) {\r\n        oper = Operation.deploy | Operation.release;\r\n    } else if (env.release) {\r\n        oper = Operation.release;\r\n    } else {\r\n        oper = Operation.build;\r\n    }\r\n\r\n    if (env.watch) {\r\n        oper = oper | Operation.watch;\r\n    }\r\n    if (env.test) {\r\n        oper = oper | Operation.test;\r\n    }\r\n    if (env.serve) {\r\n        oper = oper | Operation.serve;\r\n    }\r\n    if (env.e2e) {\r\n        oper = oper | Operation.e2e;\r\n    }\r\n\r\n    return oper;\r\n}\r\n\r\n/**\r\n *get assert source.\r\n *\r\n *@param {IAssertDist} assert\r\n *@param {Operation} oper\r\n *@returns\r\n */\r\nfunction getAssertSrc(assert: IAssertDist, oper: Operation) {\r\n    let src = null;\r\n\r\n    if ((oper & Operation.test) > 0) {\r\n        src = assert.testSrc;\r\n    } else if ((oper & Operation.e2e) > 0) {\r\n        src = assert.e2eSrc;\r\n    } else if ((oper & Operation.watch) > 0) {\r\n        src = assert.watchSrc;\r\n    } else if ((oper & Operation.clean) > 0) {\r\n        src = assert.cleanSrc || assert.dist;\r\n    }\r\n\r\n\r\n    return src || assert.src;\r\n}\r\n\r\n/**\r\n *get dist.\r\n *\r\n *@param {IAssertDist} ds\r\n *@param {ITaskContext} ctx\r\n *@returns\r\n */\r\nfunction getCurrentDist(ds: IAssertDist, ctx: ITaskContext) {\r\n    let dist: string;\r\n    let env = ctx.env;\r\n    let oper = ctx.oper;\r\n    if (env.deploy || (oper & Operation.deploy) > 0) {\r\n        dist = taskStringVal(ds.deployDist, ctx);\r\n    }\r\n    if (!dist && (env.release || (oper & Operation.release) > 0)) {\r\n        dist = taskStringVal(ds.releaseDist, ctx);\r\n    }\r\n    if (!dist && (env.e2e || (oper & Operation.e2e) > 0)) {\r\n        dist = taskStringVal(ds.e2eDist, ctx);\r\n    }\r\n    if (!dist && (env.test || (oper & Operation.test) > 0)) {\r\n        dist = taskStringVal(ds.testDist, ctx);\r\n    }\r\n    if (!dist && ((oper & Operation.build) > 0)) {\r\n        dist = taskStringVal(ds.buildDist, ctx);\r\n    }\r\n    if (!dist) {\r\n        dist = taskStringVal(ds.dist, ctx);\r\n    }\r\n\r\n    return dist;\r\n}\r\n\r\n\r\n\r\n/**\r\n *filter fileName in directory.\r\n *\r\n *@export\r\n *@param {string} directory\r\n *@param {((fileName: string) => boolean)} [express]\r\n *@returns {string[]}\r\n */\r\nfunction files(express: Src, filter?: (fileName: string) => boolean, mapping?: (filename: string) => string): Promise<string[]> {\r\n    return Promise.resolve(globby(express))\r\n        .then((files: string[]) => {\r\n            if (filter) {\r\n                files = _.filter(files, filter)\r\n            }\r\n            if (mapping) {\r\n                files = _.map(files, mapping);\r\n            }\r\n            return files;\r\n        })\r\n}\r\n\r\n/**\r\n *task src, string or array string.\r\n *\r\n *@export\r\n *@param {TaskSource} src\r\n *@param {Operation} oper runtime Operation\r\n *@param {IEnvOption} [env]\r\n *@returns\r\n */\r\nfunction taskSourceVal(src: TaskSource, ctx: ITaskContext) {\r\n    return _.isFunction(src) ? src(ctx) : (src || '');\r\n}\r\n\r\n/**\r\n *task string.\r\n *\r\n *@export\r\n *@param {TaskString} name\r\n *@param {ITaskContext} ctx\r\n *@returns\r\n */\r\nfunction taskStringVal(name: TaskString, ctx: ITaskContext) {\r\n    return _.isFunction(name) ? name(ctx) : (name || '');\r\n}\r\n"]}