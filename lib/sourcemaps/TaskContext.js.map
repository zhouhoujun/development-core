{"version":3,"sources":["TaskContext.ts"],"names":["bindingConfig","cfg","parent","createContext","opt","option","add","TaskContext","currentOperation","env","oper","deploy","TaskConfig_1","Operation","release","build","watch","test","serve","e2e","getAssertSrc","assert","src","testSrc","e2eSrc","watchSrc","clean","cleanSrc","dist","getCurrentDist","ds","ctx","routeDist","c","toStr","deployDist","releaseDist","e2eDist","testDist","buildDist","express","each","Mode","route","files","filter","mapping","Promise","resolve","globby","then","_","map","taskSourceVal","isFunction","taskStringVal","name","require","gulp","minimist","generateTask_1","taskSequence_1","utils_1","findTasks_1","path","fs","exports","NULLBuilder","node","isBuilt","globals","this","taskseq","sequence","children","packages","createEnv","setConfig","Object","defineProperty","prototype","_gulp","_builder","builder","process","argv","slice","string","default","NODE_ENV","setEnvViaOperate","extend","root","getRootPath","getConfig","isConfig","obj","context","curcfg","omit","remove","push","items","i","isTask","find","mode","item","isFinded","contexts","traverse","r","eachChildren","trans","arr","matchCompare","task","match","getSrc","relative","absoluteSrc","getDist","absolutePath","subTaskName","ext","taskName","names","t","reverse","isString","defaultTaskName","join","findTasks","module","envmatch","group","findTasksInModule","findTasksInDir","dirs","to","findTaskDefine","findTaskDefineInModule","findTaskDefineInDir","fileFilter","toSequence","tasks","zipName","runSequence","runTaskSequence","zipSequence","flattenSequence","generateTask","gtask","concat","addToSequence","_this","getRootFolders","getFolders","pathstr","dir","readdirSync","folders","d","sf","f","lstatSync","isDirectory","fl","getDistFolders","toRootSrc","toRootPath","toDistSrc","toDistPath","setting","toSrc","source","toUrl","basePath","toPath","replace","getPackage","filename","packageFile","setup","load","all","seq","subtasks","tseq","srcs","ordertask","sortOrder","order","subseq","idx","isArray","length","ptasks","it","getRunSequence","tk","runWay","RunWay","parallel","nodeSequence","NodeSequence","after","splice","apply","addTask","_i","arguments","_a","removeTask","indexOf","run","help","printHelp","isBoolean","registerTasks","globalTasks","keys"],"mappings":"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","file":"../TaskContext.js","sourcesContent":["import *as _ from 'lodash';\r\nimport { Gulp } from 'gulp';\r\nimport *as gulp from 'gulp';\r\nimport * as minimist from 'minimist';\r\nimport {\r\n    ITask, IAssertDist, IEnvOption, Operation, ITaskContext, ITaskDefine, IDynamicTaskOption, Builder\r\n    , ITaskDecorator, IAssertOption, NodeSequence, RunWay, ZipTaskName, Express, Mode, ITaskConfig, ITaskInfo, Src, TaskSource, IAsserts, TaskString, folderCallback\r\n} from './TaskConfig';\r\nimport { generateTask } from './generateTask';\r\nimport { toSequence, runSequence, addToSequence, zipSequence, flattenSequence, runTaskSequence } from './taskSequence';\r\nimport { sortOrder, matchCompare, absoluteSrc, absolutePath } from './utils';\r\nimport { findTasksInModule, findTaskDefineInModule, findTasksInDir, findTaskDefineInDir } from './findTasks';\r\nimport *as path from 'path';\r\nimport *as fs from 'fs';\r\nconst globby = require('globby');\r\n\r\n/**\r\n *binding Config, create task context.\r\n *\r\n *@export\r\n *@param {ITaskConfig} cfg\r\n *@param {ITaskContext} [parent]\r\n *@returns {ITaskContext}\r\n */\r\nexport function bindingConfig(cfg: ITaskConfig, parent?: ITaskContext): ITaskContext {\r\n    return createContext(cfg, parent);\r\n}\r\n\r\n/**\r\n *create Task context.\r\n *\r\n *@export\r\n *@param {ITaskConfig | IAssertOption} cfg\r\n *@param {ITaskContext} [parent]\r\n *@returns {ITaskContext}\r\n */\r\nexport function createContext(cfg: ITaskConfig | IAssertOption, parent?: ITaskContext): ITaskContext {\r\n    let opt: ITaskConfig = (cfg && cfg['option']) ? (cfg as ITaskConfig) : ({ option: cfg } as ITaskConfig);\r\n    if (opt.createContext) {\r\n        return opt.createContext(cfg, parent);\r\n    }\r\n    return parent ? parent.add(opt) : new TaskContext(opt);\r\n}\r\n\r\nconst NULLBuilder = <Builder>{\r\n    build<T extends IAsserts>(node: ITaskContext, option?: T): ITaskContext {\r\n        return node;\r\n    },\r\n\r\n    // buildChildren<T extends IAsserts>(node: ITaskContext, option?: T): ITaskContext {\r\n    //     return node;\r\n    // },\r\n\r\n    isBuilt(node: ITaskContext): boolean {\r\n        return false;\r\n    }\r\n\r\n    // clean(node: ITaskContext) {\r\n\r\n    // }\r\n}\r\n/**\r\n *global data.\r\n */\r\nlet globals = {};\r\n\r\n/**\r\n *TaskContext\r\n *\r\n *@export\r\n *@class TaskContext\r\n *@implements {ITaskContext}\r\n */\r\nexport class TaskContext implements ITaskContext {\r\n    protected cfg: ITaskConfig;\r\n    protected taskseq: ITask[] = [];\r\n\r\n    protected sequence: Src[] = [];\r\n    protected children: ITaskContext[] = [];\r\n\r\n    oper: Operation;\r\n    option: IAsserts;\r\n    env: IEnvOption;\r\n    globals: any;\r\n    parent: ITaskContext;\r\n\r\n    constructor(cfg: ITaskConfig) {\r\n        cfg = cfg || {};\r\n        cfg.env = cfg.env || this.createEnv();\r\n        this.setConfig(cfg);\r\n    }\r\n\r\n    private _gulp: Gulp;\r\n    get gulp() {\r\n        return this._gulp || gulp;\r\n    }\r\n    set gulp(gulp: Gulp) {\r\n        this._gulp = gulp;\r\n    }\r\n\r\n    protected _builder: Builder;\r\n    get builder(): Builder {\r\n        return this._builder || NULLBuilder;\r\n    }\r\n\r\n    set builder(builder: Builder) {\r\n        this._builder = builder;\r\n    }\r\n\r\n    protected createEnv(): IEnvOption {\r\n        let env: IEnvOption = minimist(process.argv.slice(2), {\r\n            string: 'env',\r\n            default: { env: process.env.NODE_ENV || 'development' }\r\n        }) as IEnvOption;\r\n        return env;\r\n    }\r\n\r\n    protected setEnvViaOperate(oper: Operation) {\r\n        this.env = this.env || {};\r\n        if ((oper & Operation.deploy) > 0) {\r\n            this.env.deploy = true;\r\n            this.env.release = false;\r\n        } else if ((oper & Operation.release) > 0) {\r\n            this.env.release = true;\r\n            this.env.deploy = false;\r\n            oper = Operation.release;\r\n        }\r\n\r\n        if ((oper & Operation.watch) > 0) {\r\n            this.env.watch = true;\r\n        }\r\n\r\n        if ((oper & Operation.test) > 0) {\r\n            this.env.test = true;\r\n        }\r\n\r\n        if ((oper & Operation.serve) > 0) {\r\n            this.env.serve = true;\r\n        }\r\n\r\n        if ((oper & Operation.e2e) > 0) {\r\n            this.env.e2e = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     *load config\r\n     *\r\n     *@param {ITaskConfig} cfg\r\n     *\r\n     *@memberof TaskContext\r\n     */\r\n    setConfig(cfg: ITaskConfig) {\r\n        if (!cfg) {\r\n            return;\r\n        }\r\n        if (cfg.env) {\r\n            this.env = cfg.env = _.extend({}, this.env || {}, cfg.env);\r\n            this.oper = currentOperation(this.env);\r\n        }\r\n        // make sure root.\r\n        if (!this.env.root) {\r\n            this.env.root = this.getRootPath();\r\n        }\r\n        if (cfg.oper) {\r\n            this.oper = cfg.oper;\r\n            this.setEnvViaOperate(this.oper);\r\n        }\r\n        this.globals = cfg.globals || globals;\r\n        if (cfg.option) {\r\n            this.option = cfg.option = _.extend({}, this.option || {}, cfg.option);\r\n        }\r\n        this.cfg = _.extend(this.cfg, cfg);\r\n    }\r\n\r\n    /**\r\n     *get config.\r\n     *\r\n     *@returns {ITaskConfig}\r\n     *\r\n     *@memberof TaskContext\r\n     */\r\n    getConfig(): ITaskConfig {\r\n        return this.cfg || {};\r\n    }\r\n\r\n    protected isConfig(obj: any): boolean {\r\n        return obj && obj['option'];\r\n    }\r\n\r\n    /**\r\n     * add sub ITaskContext\r\n     *\r\n     * @param {(ITaskContext | ITaskConfig | IAssertOption)} context\r\n     * @returns {ITaskContext} sub context.\r\n     * @memberof TaskContext\r\n     */\r\n    add(context: ITaskContext | ITaskConfig | IAssertOption): ITaskContext {\r\n        let ctx: ITaskContext;\r\n        let curcfg: ITaskConfig = _.omit(this.getConfig(), 'option');\r\n        if (context instanceof TaskContext) {\r\n            ctx = context;\r\n            if (ctx.parent) {\r\n                ctx.parent.remove(ctx);\r\n            }\r\n            ctx.setConfig(_.extend({}, curcfg, ctx.getConfig()));\r\n        } else {\r\n            let opt: ITaskConfig = (this.isConfig(context) ? context : { option: context }) as ITaskConfig;\r\n            opt = _.extend({}, curcfg, opt);\r\n            ctx = this.createContext(opt);\r\n        }\r\n        ctx.parent = this;\r\n        this.children.push(ctx);\r\n        // if (!ctx.builder.isBuilt(ctx)) {\r\n        //     ctx.builder.build(ctx);\r\n        // }\r\n        return ctx;\r\n    }\r\n\r\n    /**\r\n     * create context.\r\n     *\r\n     * @protected\r\n     * @param {(ITaskConfig)} cfg\r\n     * @returns {ITaskContext}\r\n     * @memberof TaskContext\r\n     */\r\n    protected createContext(cfg: ITaskConfig): ITaskContext {\r\n        return new TaskContext(cfg)\r\n    }\r\n\r\n    /**\r\n     *remove sub ITaskContext.\r\n     *\r\n     *@param {ITaskContext} [context]\r\n     *\r\n     *@memberOf ITaskContext\r\n     */\r\n    remove(context?: ITaskContext): ITaskContext[] {\r\n        let items = _.remove(this.children, context);\r\n        _.each(items, i => {\r\n            if (i) {\r\n                i.parent = null;\r\n            }\r\n        });\r\n        return items;\r\n    }\r\n\r\n    /**\r\n     * is task class.\r\n     *\r\n     * @param {any} obj\r\n     * @returns {boolean}\r\n     * @memberof TaskContext\r\n     */\r\n    isTask(obj: any): boolean {\r\n        if (!obj) {\r\n            return false;\r\n        }\r\n        if (!_.isFunction(obj)) {\r\n            return false;\r\n        }\r\n        return obj['__task'] || obj['__dynamictask']\r\n    }\r\n\r\n\r\n    /**\r\n     *find sub context via express.\r\n     *\r\n     *@template T\r\n     *@param {(T | Express<T, boolean>)} express\r\n     *@param {Mode} [mode]\r\n     *@returns {T}\r\n     *@memberof TaskContext\r\n     */\r\n    find<T extends ITaskContext>(express: T | Express<T, boolean>, mode?: Mode): T {\r\n        let context: ITaskContext;\r\n        this.each<T>(item => {\r\n            if (context) {\r\n                return false;\r\n            }\r\n            let isFinded = _.isFunction(express) ? express(item) : (<ITaskContext>express) === item;\r\n            if (isFinded) {\r\n                context = item;\r\n                return false;\r\n            }\r\n            return true;\r\n        }, mode);\r\n        return context as T;\r\n    }\r\n\r\n    /**\r\n     *filter items.\r\n     *\r\n     *@template T\r\n     *@param {(Express<T, void | boolean>)} express\r\n     *@param {Mode} [mode]\r\n     *@returns {ITaskContext[]}\r\n     *@memberof TaskContext\r\n     */\r\n    filter<T extends ITaskContext>(express: Express<T, void | boolean>, mode?: Mode): T[] {\r\n        let contexts: ITaskContext[] = [];\r\n        this.each<T>(item => {\r\n            if (express(item)) {\r\n                contexts.push(item);\r\n            }\r\n        }, mode);\r\n        return contexts as T[];\r\n    }\r\n    /**\r\n     *find parent context via express.\r\n     *\r\n     *@param {(ITaskContext | Express<ITaskContext, boolean>)} express\r\n     *@param {Mode} [mode] {enum:['route','children', traverse']} default traverse.\r\n     *\r\n     *@memberOf ITaskContext\r\n     */\r\n    each<T extends ITaskContext>(express: Express<T, void | boolean>, mode?: Mode) {\r\n        mode = mode || Mode.traverse;\r\n        let r;\r\n        switch (mode) {\r\n            case Mode.route:\r\n                r = this.route(express);\r\n                break;\r\n            case Mode.children:\r\n                r = this.eachChildren(express);\r\n                break;\r\n\r\n            case Mode.traverse:\r\n                r = this.trans(express);\r\n                break;\r\n            default:\r\n                r = this.trans(express);\r\n                break;\r\n        }\r\n        return r;\r\n    }\r\n\r\n    /**\r\n     * map context.\r\n     *\r\n     *@template T\r\n     *@param {Express<ITaskContext, T>} express\r\n     *@param {Mode} [mode]\r\n     *@param {Express<ITaskContext, boolean>} [filter]\r\n     *@returns {T[]}\r\n     *\r\n     *@memberof TaskContext\r\n     */\r\n    map<T>(express: Express<ITaskContext, T>, mode?: Mode, filter?: Express<ITaskContext, boolean>): T[] {\r\n        let arr: T[] = []\r\n        this.each((ctx) => {\r\n            if (filter) {\r\n                if (filter(ctx)) {\r\n                    arr.push(express(ctx));\r\n                }\r\n            } else {\r\n                arr.push(express(ctx));\r\n            }\r\n        }, mode);\r\n        return arr;\r\n    }\r\n\r\n    eachChildren(express: Express<ITaskContext, void | boolean>) {\r\n        _.each(this.children, item => {\r\n            return express(item);\r\n        });\r\n    }\r\n\r\n    /**\r\n     *do express work in routing.\r\n     *\r\n     *@param {Express<ITaskContext, void | boolean>} express\r\n     *\r\n     *@memberOf ITaskContext\r\n     */\r\n    route(express: Express<ITaskContext, void | boolean>) {\r\n        if (express(this) === false) {\r\n            return false;\r\n        };\r\n        if (this.parent && this.parent.route) {\r\n            return this.parent.route(express);\r\n        }\r\n    }\r\n    /**\r\n     *translate all sub context to do express work.\r\n     *\r\n     *@param {Express<ITaskContext, void | boolean>} express\r\n     *\r\n     *@memberOf ITaskContext\r\n     */\r\n    trans(express: Express<ITaskContext, void | boolean>) {\r\n        if (express(this) === false) {\r\n            return false;\r\n        }\r\n        _.each(this.children, item => {\r\n            return item.trans(express);\r\n        });\r\n        return true;\r\n    }\r\n\r\n    matchCompare(task: ITaskInfo, match: ITaskInfo): boolean {\r\n        if (this.option.match) {\r\n            return this.option.match(task, match);\r\n        }\r\n        return matchCompare(task, match);\r\n    }\r\n\r\n    getSrc(task?: ITaskInfo, relative = false): Src {\r\n        let src: Src;\r\n        let ctx = this;\r\n        let oper = task ? (task.oper || ctx.oper) : ctx.oper;\r\n        if (task && task.assert) {\r\n            src = taskSourceVal(getAssertSrc(task.assert, oper), ctx)\r\n        }\r\n\r\n        if (!src) {\r\n            this.route(c => {\r\n                src = taskSourceVal(getAssertSrc(c.option, oper), c);\r\n                if (src) {\r\n                    return false;\r\n                }\r\n                return true;\r\n            });\r\n        }\r\n        return (relative !== false) ? src : absoluteSrc(ctx.env.root, src);\r\n    }\r\n\r\n    getDist(task?: ITaskInfo, relative = false): string {\r\n        let dist: string;\r\n        let ctx = this;\r\n        // let oper = task ? (task.oper || context.oper) : context.oper;\r\n        if (task && task.assert) {\r\n            dist = getCurrentDist(task.assert, ctx);\r\n        }\r\n        if (!dist) {\r\n            this.route(c => {\r\n                dist = getCurrentDist(c.option, c);\r\n                if (dist) {\r\n                    return false;\r\n                }\r\n                return true;\r\n            });\r\n        }\r\n\r\n        return (relative !== false) ? dist : absolutePath(ctx.env.root, dist);\r\n    }\r\n\r\n    subTaskName(task: TaskString | ITaskInfo, ext?: string) {\r\n        return this.taskName(task, ext);\r\n    }\r\n\r\n    taskName(task: TaskString | ITaskInfo, ext = ''): string {\r\n        let ctx = this;\r\n        let name = '';\r\n        let names = _.filter(this.map(c => {\r\n            return c.toStr(c.option.name);\r\n        }, Mode.route), t => !!t).reverse();\r\n\r\n        if (_.isString(task) || _.isFunction(task)) {\r\n            name = this.toStr(task);\r\n        } else if (task && task !== ctx.option) {\r\n            // oper = task.oper || context.oper;\r\n            if (task.name) {\r\n                name = taskStringVal(task.name, ctx)\r\n            }\r\n            if (!name && task.assert && task.assert.name) {\r\n                name = taskStringVal(task.assert.name, ctx)\r\n            }\r\n        }\r\n        if (!name) {\r\n            name = ctx.toStr(ctx.option.defaultTaskName);\r\n        }\r\n\r\n        if (name) {\r\n            names.push(name);\r\n        }\r\n        if (ext) {\r\n            names.push(ext);\r\n        }\r\n\r\n        // console.log('taskName:----------------------\\n', names);\r\n\r\n        return names.join('-');\r\n    }\r\n\r\n    findTasks(module: string | Object, match?: ITaskInfo): Promise<ITask[]> {\r\n        let envmatch: ITaskDecorator = {};\r\n        if (this.env.group) {\r\n            envmatch.group = this.env.group;\r\n        }\r\n        if (this.oper) {\r\n            envmatch.oper = this.oper;\r\n        }\r\n\r\n        return findTasksInModule(module, _.extend(envmatch, match || {}), this);\r\n    }\r\n\r\n    findTasksInDir(dirs: TaskSource, match?: ITaskInfo): Promise<ITask[]> {\r\n        let envmatch: ITaskDecorator = {};\r\n        if (this.env.group) {\r\n            envmatch.group = this.env.group;\r\n        }\r\n        if (this.oper) {\r\n            envmatch.oper = this.oper;\r\n        }\r\n        return findTasksInDir(this.to(dirs), _.extend(envmatch, match || {}), this);\r\n    }\r\n\r\n    findTaskDefine(module: string | Object): Promise<ITaskDefine> {\r\n        return findTaskDefineInModule(module);\r\n    }\r\n\r\n    findTaskDefineInDir(dirs: TaskSource): Promise<ITaskDefine> {\r\n        return findTaskDefineInDir(this.to(dirs));\r\n    }\r\n\r\n    fileFilter(express: Src, filter?: (fileName: string) => boolean, mapping?: (filename: string) => string): Promise<string[]> {\r\n        return files(express, filter, mapping);\r\n    }\r\n\r\n\r\n    /**\r\n     *to Sequence.\r\n     *\r\n     *@param {ITask[]} tasks\r\n     *@param {ZipTaskName} [zipName]\r\n     *@returns {Src[]}\r\n     *\r\n     *@memberof TaskContext\r\n     */\r\n    toSequence(tasks: ITask[], zipName?: ZipTaskName): Src[] {\r\n        return toSequence(this.gulp, tasks, this, zipName);\r\n    }\r\n\r\n    /**\r\n     *filter file in directory.  default implement in bindingConfig.\r\n     *\r\n     *@param {Gulp} gulp\r\n     *@param {Src[]} tasks\r\n     *@returns {Promise<any>}\r\n     *\r\n     *@memberOf ITaskContext\r\n     */\r\n    runSequence(tasks: Src[]): Promise<any> {\r\n        return runSequence(this.gulp, tasks);\r\n    }\r\n\r\n    /**\r\n     *run task sequence in this context.\r\n     *\r\n     *@param {(ITask[] | Promise<ITask[]>)} tasks\r\n     *@param {ZipTaskName} [zipName]\r\n     *@returns {Promise<any>}\r\n     *\r\n     *@memberof TaskContext\r\n     */\r\n    runTaskSequence(tasks: ITask[] | Promise<ITask[]>, zipName?: ZipTaskName): Promise<any> {\r\n        return runTaskSequence(this.gulp, tasks, this, zipName);\r\n    }\r\n\r\n    /**\r\n     *zip task sequence.\r\n     *\r\n     *@param {Src[]} tasks\r\n     *@param {ZipTaskName} [zipName]\r\n     *@returns {string}\r\n     *\r\n     *@memberof ITaskContext\r\n     */\r\n    zipSequence(tasks: Src[], zipName?: ZipTaskName): string {\r\n        return zipSequence(this.gulp, tasks, this, zipName);\r\n    }\r\n\r\n    /**\r\n     *flattenSequence in this context.\r\n     *\r\n     *@param {Src[]} tasks\r\n     *@param {ZipTaskName} [zipName]\r\n     *@returns {string[]}\r\n     *\r\n     *@memberof ITaskContext\r\n     */\r\n    flattenSequence(tasks: Src[], zipName?: ZipTaskName): string[] {\r\n        return flattenSequence(this.gulp, tasks, this, zipName);\r\n    }\r\n\r\n\r\n    /**\r\n     *dynamic generate tasks.  default implement in bindingConfig.\r\n     *\r\n     *@param {(IDynamicTaskOption | IDynamicTaskOption[])} tasks\r\n     *@param {ITaskInfo} [match]\r\n     *@returns {ITask[]}\r\n     *\r\n     *@memberOf ITaskContext\r\n     */\r\n    generateTask(tasks: IDynamicTaskOption | IDynamicTaskOption[], match?: ITaskInfo): ITask[] {\r\n        let ctx = this;\r\n        let gtask = generateTask(tasks, _.extend({ oper: ctx.oper }, match || {}), this);\r\n        this.taskseq = this.taskseq.concat(gtask);\r\n        return this.taskseq;\r\n    }\r\n\r\n    /**\r\n     *add task result to task sequence. default implement in bindingConfig.\r\n     *\r\n     *@param {Src[]} sequence  task sequence.\r\n     *@param {ITaskInfo} task\r\n     *@returns {Src[]}\r\n     *\r\n     *@memberOf ITaskContext\r\n     */\r\n    addToSequence(sequence: Src[], task: ITaskInfo): Src[] {\r\n        if (this.cfg.addToSequence) {\r\n            return this.cfg.addToSequence(sequence, task);\r\n        }\r\n        return addToSequence(sequence, task, this);\r\n    }\r\n\r\n    getRootPath() {\r\n        let root: string;\r\n        if (this.env && this.env.root) {\r\n            root = this.env.root\r\n        } else {\r\n            this.each(c => {\r\n                if (c.env && c.env.root) {\r\n                    root = this.env.root;\r\n                    return false;\r\n                }\r\n                return true;\r\n            }, Mode.route);\r\n        }\r\n        return root;\r\n    }\r\n\r\n    getRootFolders(express?: folderCallback): string[] {\r\n        return this.getFolders(this.getRootPath(), express);\r\n    }\r\n\r\n    getFolders(pathstr: string, express?: folderCallback): string[] {\r\n        let dir = fs.readdirSync(pathstr);\r\n        let folders = [];\r\n        _.each(dir, (d: string) => {\r\n            let sf = path.join(pathstr, d);\r\n            let f = fs.lstatSync(sf);\r\n            if (f.isDirectory()) {\r\n                if (express) {\r\n                    let fl = express(sf, d, this);\r\n                    if (fl) {\r\n                        folders.push(fl);\r\n                    }\r\n                } else {\r\n                    folders.push(sf);\r\n                }\r\n            }\r\n        });\r\n        return folders;\r\n    }\r\n\r\n    getDistFolders(express?: folderCallback, task?: ITaskInfo): string[] {\r\n        return this.getFolders(this.getDist(task), express);\r\n    }\r\n\r\n    toRootSrc(src: Src): Src {\r\n        return absoluteSrc(this.getRootPath(), src);\r\n    }\r\n\r\n    toRootPath(pathstr: string): string {\r\n        return absolutePath(this.getRootPath(), pathstr);\r\n    }\r\n\r\n    toDistSrc(src: Src, task?: ITaskInfo): Src {\r\n        return absoluteSrc(this.getDist(task), src);\r\n    }\r\n\r\n    toDistPath(pathstr: string, task?: ITaskInfo): string {\r\n        return absolutePath(this.getDist(task), pathstr);\r\n    }\r\n\r\n    to<T>(setting: T | ((ctx: ITaskContext) => T)): T {\r\n        return _.isFunction(setting) ? setting(this) : setting;\r\n    }\r\n\r\n    toSrc(source: TaskSource): Src {\r\n        return taskSourceVal(source, this);\r\n    }\r\n\r\n    toStr(name: TaskString): string {\r\n        return taskStringVal(name, this);\r\n    }\r\n\r\n    toUrl(basePath: string, toPath?: string): string {\r\n        return (toPath ? path.relative(basePath, toPath) : basePath).replace(/\\\\/g, '/'); // .replace(/^\\//g, '');\r\n    }\r\n\r\n    private packages = {};\r\n    getPackage(filename?: TaskString): any {\r\n        filename = filename || this.cfg.packageFile;\r\n        let name = this.toRootPath(this.toStr(filename) || 'package.json');\r\n        if (!this.packages[name]) {\r\n            this.packages[name] = require(name);\r\n        }\r\n        return this.packages[name]\r\n    }\r\n\r\n    setup(): Promise<Src[]> {\r\n        if (this.option.oper && (this.oper & this.option.oper) <= 0) {\r\n            // this.sequence = null;\r\n            return Promise.resolve(null);\r\n        } else {\r\n            return Promise.resolve(this.load())\r\n                .then(tasks => {\r\n                    return Promise.all(this.map(ctx => {\r\n                        return ctx.setup()\r\n                            .then(seq => {\r\n                                return ctx;\r\n                            });\r\n                    }, Mode.children))\r\n                        .then(subtasks => {\r\n                            return {\r\n                                tseq: tasks,\r\n                                subtasks: subtasks\r\n                            }\r\n                        })\r\n\r\n                })\r\n                .then(srcs => {\r\n                    let opt = this.option as IAsserts;\r\n                    let tseq = srcs.tseq;\r\n                    let ordertask = sortOrder(srcs.subtasks, ctx => ctx.option.order, this);\r\n\r\n                    let subseq: Src[] = [];\r\n                    _.each(ordertask, (t, idx) => {\r\n                        if (_.isArray(t)) {\r\n                            if (t.length > 0) {\r\n                                let ptasks = _.filter(_.map(t, it => this.zipSequence(<Src[]>it.getRunSequence())), it => !!it);\r\n                                if (ptasks.length > 0) {\r\n                                    subseq.push(ptasks);\r\n                                }\r\n                            }\r\n                        } else {\r\n                            let tk = this.zipSequence(t.getRunSequence());\r\n                            tk && subseq.push(tk);\r\n                        }\r\n                    });\r\n\r\n                    // let children = this.zipSequence(subseq, (name, runway) => this.subTaskName(name, (runway === RunWay.sequence ? '-sub-seq' : '-sub-paral')));\r\n                    subseq = this.flattenSequence(subseq);\r\n                    tseq = this.flattenSequence(tseq);\r\n                    if (tseq.length > 0) {\r\n                        tseq = opt.runWay === RunWay.parallel ? [this.flattenSequence(tseq)] : this.flattenSequence(tseq);\r\n                        if (subseq && subseq.length > 0) {\r\n                            if (opt.nodeSequence === NodeSequence.after) {\r\n                                tseq.splice(0, 0, ...subseq);\r\n                            } else {\r\n                                tseq.push(...subseq);\r\n                            }\r\n                        }\r\n                    } else {\r\n                        tseq = subseq;\r\n                    }\r\n\r\n                    this.sequence = tseq;\r\n                    return this.sequence;\r\n                });\r\n        }\r\n    }\r\n\r\n    getRunSequence(): Src[] {\r\n        return this.sequence || [];\r\n    }\r\n\r\n    load(): Src[] | Promise<Src[]> {\r\n        if (!this.builder.isBuilt(this)) {\r\n            return Promise.resolve(this.builder.build(this))\r\n                .then(ctx => {\r\n                    return this.toSequence(this.taskseq);\r\n                });\r\n        } else {\r\n            return this.toSequence(this.taskseq);\r\n        }\r\n    }\r\n\r\n    addTask(...task: ITask[]) {\r\n        this.taskseq.push(...task);\r\n    }\r\n\r\n    removeTask(task: ITask): ITask[] | Promise<ITask[]> {\r\n        let idx = this.taskseq.indexOf(task);\r\n        if (idx >= 0 && idx < this.taskseq.length) {\r\n            return this.taskseq.splice(idx, 1);\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     *run task in this context.\r\n     *\r\n     *@returns {Promise<any>}\r\n     *\r\n     *@memberof TaskContext\r\n     */\r\n    run(): Promise<any> {\r\n        if (this.env.help) {\r\n            return Promise.resolve(this.help())\r\n        } else {\r\n            // if (!this.builder.isBuilt(this)) {\r\n            //     this.builder.build(this);\r\n            // }\r\n            return this.setup()\r\n                .then(tseq => {\r\n                    let opt = this.option as IAsserts;\r\n                    if (opt.runWay === RunWay.parallel) {\r\n                        return this.runSequence([this.flattenSequence(tseq)]);\r\n                    } else {\r\n                        return this.runSequence(tseq);\r\n                    }\r\n                });\r\n        }\r\n    }\r\n\r\n    help() {\r\n        this.cfg.printHelp && this.cfg.printHelp(_.isBoolean(this.env.help) ? '' : this.env.help);\r\n    }\r\n\r\n    tasks(express?: (item: ITask) => boolean): ITask[] {\r\n        return express ? _.filter(this.taskseq, express) : this.taskseq;\r\n    }\r\n\r\n    registerTasks(express?: (item: ITask) => boolean): ITask[] {\r\n        let tasks = [];\r\n        this.each(c => {\r\n            tasks = tasks.concat(c.tasks(express));\r\n        });\r\n        return tasks;\r\n    }\r\n\r\n    globalTasks(): string[] {\r\n        return _.keys(this.globals.tasks || {});\r\n    }\r\n}\r\n\r\n\r\n/**\r\n *get current env Operation.\r\n *\r\n *@export\r\n *@param {EnvOption} env\r\n *@returns\r\n */\r\nfunction currentOperation(env: IEnvOption) {\r\n    let oper: Operation;\r\n    if (env.deploy) {\r\n        oper = Operation.deploy | Operation.release;\r\n    } else if (env.release) {\r\n        oper = Operation.release;\r\n    } else {\r\n        oper = Operation.build;\r\n    }\r\n\r\n    if (env.watch) {\r\n        oper = oper | Operation.watch;\r\n    }\r\n    if (env.test) {\r\n        oper = oper | Operation.test;\r\n    }\r\n    if (env.serve) {\r\n        oper = oper | Operation.serve;\r\n    }\r\n    if (env.e2e) {\r\n        oper = oper | Operation.e2e;\r\n    }\r\n\r\n    return oper;\r\n}\r\n\r\n/**\r\n *get assert source.\r\n *\r\n *@param {IAssertDist} assert\r\n *@param {Operation} oper\r\n *@returns\r\n */\r\nfunction getAssertSrc(assert: IAssertDist, oper: Operation) {\r\n    let src = null;\r\n\r\n    if ((oper & Operation.test) > 0) {\r\n        src = assert.testSrc;\r\n    } else if ((oper & Operation.e2e) > 0) {\r\n        src = assert.e2eSrc;\r\n    } else if ((oper & Operation.watch) > 0) {\r\n        src = assert.watchSrc;\r\n    } else if ((oper & Operation.clean) > 0) {\r\n        src = assert.cleanSrc || assert.dist;\r\n    }\r\n\r\n\r\n    return src || assert.src;\r\n}\r\n\r\n/**\r\n *get dist.\r\n *\r\n *@param {IAssertDist} ds\r\n *@param {ITaskContext} ctx\r\n *@returns\r\n */\r\nfunction getCurrentDist(ds: IAssertDist, ctx: ITaskContext) {\r\n    let dist: string;\r\n    let env = ctx.env;\r\n    let oper = ctx.oper;\r\n    if (env.deploy || (oper & Operation.deploy) > 0) {\r\n        dist = routeDist(ctx, (c) => {\r\n            return c.toStr(ds.deployDist);\r\n        });\r\n    }\r\n    if (!dist && (env.release || (oper & Operation.release) > 0)) {\r\n        dist = routeDist(ctx, (c) => {\r\n            return c.toStr(ds.releaseDist);\r\n        });\r\n    }\r\n    if (!dist && (env.e2e || (oper & Operation.e2e) > 0)) {\r\n        dist = routeDist(ctx, (c) => {\r\n            return c.toStr(ds.e2eDist);\r\n        });\r\n    }\r\n    if (!dist && (env.test || (oper & Operation.test) > 0)) {\r\n        dist = routeDist(ctx, (c) => {\r\n            return c.toStr(ds.testDist);\r\n        });\r\n    }\r\n    if (!dist && ((oper & Operation.build) > 0)) {\r\n        dist = routeDist(ctx, (c) => {\r\n            return c.toStr(ds.buildDist);\r\n        });\r\n    }\r\n    if (!dist) {\r\n        // dist = taskStringVal(ds.dist, ctx);\r\n        dist = routeDist(ctx, (c) => {\r\n            return c.toStr(ds.dist);\r\n        })\r\n    }\r\n\r\n    return dist;\r\n}\r\n\r\n\r\nfunction routeDist(ctx: ITaskContext, express: (ctx: ITaskContext) => string) {\r\n    let dist = '';\r\n    ctx.each((c) => {\r\n        dist = express(c);\r\n        if (dist) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }, Mode.route);\r\n    return dist;\r\n}\r\n\r\n\r\n\r\n/**\r\n *filter fileName in directory.\r\n *\r\n *@export\r\n *@param {string} directory\r\n *@param {((fileName: string) => boolean)} [express]\r\n *@returns {string[]}\r\n */\r\nfunction files(express: Src, filter?: (fileName: string) => boolean, mapping?: (filename: string) => string): Promise<string[]> {\r\n    return Promise.resolve(globby(express))\r\n        .then((files: string[]) => {\r\n            if (filter) {\r\n                files = _.filter(files, filter)\r\n            }\r\n            if (mapping) {\r\n                files = _.map(files, mapping);\r\n            }\r\n            return files;\r\n        })\r\n}\r\n\r\n/**\r\n *task src, string or array string.\r\n *\r\n *@export\r\n *@param {TaskSource} src\r\n *@param {Operation} oper runtime Operation\r\n *@param {IEnvOption} [env]\r\n *@returns\r\n */\r\nfunction taskSourceVal(src: TaskSource, ctx: ITaskContext) {\r\n    return _.isFunction(src) ? src(ctx) : (src || '');\r\n}\r\n\r\n/**\r\n *task string.\r\n *\r\n *@export\r\n *@param {TaskString} name\r\n *@param {ITaskContext} ctx\r\n *@returns\r\n */\r\nfunction taskStringVal(name: TaskString, ctx: ITaskContext) {\r\n    return _.isFunction(name) ? name(ctx) : (name || '');\r\n}\r\n"]}