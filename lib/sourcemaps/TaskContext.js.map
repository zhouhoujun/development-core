{"version":3,"sources":["TaskContext.ts"],"names":["bindingConfig","cfg","parent","createContext","TaskContext","currentOperation","env","oper","deploy","TaskConfig_1","Operation","release","build","watch","test","serve","e2e","getAssertSrc","assert","src","testSrc","e2eSrc","watchSrc","clean","cleanSrc","dist","getCurrentDist","ds","ctx","taskStringVal","deployDist","releaseDist","e2eDist","testDist","buildDist","files","express","filter","mapping","Promise","resolve","globby","then","_","map","taskSourceVal","isFunction","name","require","gulp","minimist","generateTask_1","taskSequence_1","utils_1","findTasks_1","path","fs","exports","globals","this","taskseq","sequence","children","packages","add","pcfg","omit","getConfig","createEnv","setConfig","Object","defineProperty","prototype","_gulp","process","argv","slice","string","default","NODE_ENV","extend","option","context","push","remove","items","each","i","find","mode","item","isFinded","contexts","Mode","traverse","r","route","eachChildren","trans","arr","matchCompare","task","match","getSrc","relative","c","absoluteSrc","root","getDist","absolutePath","subTaskName","ext","isString","optName","indexOf","findTasks","module","findTasksInModule","findTasksInDir","dirs","to","findTaskDefine","findTaskDefineInModule","findTaskDefineInDir","fileFilter","toSequence","tasks","zipName","runSequence","runTaskSequence","zipSequence","flattenSequence","generateTask","gtask","concat","addToSequence","getRootPath","getRootFolders","getFolders","pathstr","_this","dir","readdirSync","folders","d","sf","join","f","lstatSync","isDirectory","fl","getDistFolders","toRootSrc","toRootPath","toDistSrc","toDistPath","setting","toSrc","source","toStr","toUrl","basePath","toPath","replace","getPackage","filename","packageFile","setup","all","setupTasks","seq","srcs","opt","tseq","shift","ordertask","sortOrder","order","subseq","t","idx","isArray","it","getRunSequence","tk","runWay","RunWay","parallel","length","nodeSequence","NodeSequence","after","splice","apply","addTask","_i","arguments","_a","removeTask","run","help","printHelp","isBoolean","registerTasks","globalTasks","keys"],"mappings":"YAwBA,SAAAA,eAA8BC,EAAkBC,GAC5C,MAAOC,eAAcF,EAAKC,GAW9B,QAAAC,eAA8BF,EAAkBC,GAC5C,MAAID,GAAIE,cACGF,EAAIE,cAAcF,EAAKC,GAE3B,GAAIE,aAAYH,EAAKC,GAmpBhC,QAAAG,kBAA0BC,GACtB,GAAIC,EAsBJ,OApBIA,GADAD,EAAIE,OACGC,aAAAC,UAAUF,OAASC,aAAAC,UAAUC,QAC7BL,EAAIK,QACJF,aAAAC,UAAUC,QAEVF,aAAAC,UAAUE,MAGjBN,EAAIO,QACJN,GAAcE,aAAAC,UAAUG,OAExBP,EAAIQ,OACJP,GAAcE,aAAAC,UAAUI,MAExBR,EAAIS,QACJR,GAAcE,aAAAC,UAAUK,OAExBT,EAAIU,MACJT,GAAcE,aAAAC,UAAUM,KAGrBT,EAUX,QAAAU,cAAsBC,EAAqBX,GACvC,GAAIY,GAAM,IAaV,QAXKZ,EAAOE,aAAAC,UAAUI,MAAQ,EAC1BK,EAAMD,EAAOE,SACLb,EAAOE,aAAAC,UAAUM,KAAO,EAChCG,EAAMD,EAAOG,QACLd,EAAOE,aAAAC,UAAUG,OAAS,EAClCM,EAAMD,EAAOI,UACLf,EAAOE,aAAAC,UAAUa,OAAS,IAClCJ,EAAMD,EAAOM,UAAYN,EAAOO,MAI7BN,GAAOD,EAAOC,IAUzB,QAAAO,gBAAwBC,EAAiBC,GACrC,GAAIH,GACAnB,EAAMsB,EAAItB,IACVC,EAAOqB,EAAIrB,IAoBf,QAnBID,EAAIE,SAAWD,EAAOE,aAAAC,UAAUF,QAAU,KAC1CiB,EAAOI,cAAcF,EAAGG,WAAYF,KAEnCH,IAASnB,EAAIK,UAAYJ,EAAOE,aAAAC,UAAUC,SAAW,KACtDc,EAAOI,cAAcF,EAAGI,YAAaH,KAEpCH,IAASnB,EAAIU,MAAQT,EAAOE,aAAAC,UAAUM,KAAO,KAC9CS,EAAOI,cAAcF,EAAGK,QAASJ,KAEhCH,IAASnB,EAAIQ,OAASP,EAAOE,aAAAC,UAAUI,MAAQ,KAChDW,EAAOI,cAAcF,EAAGM,SAAUL,KAEjCH,IAAUlB,EAAOE,aAAAC,UAAUE,OAAS,IACrCa,EAAOI,cAAcF,EAAGO,UAAWN,IAElCH,IACDA,EAAOI,cAAcF,EAAGF,KAAMG,IAG3BH,EAYX,QAAAU,OAAeC,EAAcC,EAAwCC,GACjE,MAAOC,SAAQC,QAAQC,OAAOL,IACzBM,KAAK,SAACP,GAOH,MANIE,KACAF,EAAQQ,EAAEN,OAAOF,EAAOE,IAExBC,IACAH,EAAQQ,EAAEC,IAAIT,EAAOG,IAElBH,IAanB,QAAAU,eAAuB1B,EAAiBS,GACpC,MAAOe,GAAEG,WAAW3B,GAAOA,EAAIS,GAAQT,GAAO,GAWlD,QAAAU,eAAuBkB,EAAkBnB,GACrC,MAAOe,GAAEG,WAAWC,GAAQA,EAAKnB,GAAQmB,GAAQ,yDA1zBrD,IAAAJ,GAAAK,QAAA,UAEAC,KAAAD,QAAA,QACAE,SAAAF,QAAA,YACAvC,aAAAuC,QAAA,gBAIAG,eAAAH,QAAA,kBACAI,eAAAJ,QAAA,kBACAK,QAAAL,QAAA,WACAM,YAAAN,QAAA,eACAO,KAAAP,QAAA,QACAQ,GAAAR,QAAA,MACMP,OAASO,QAAQ,SAUvBS,SAAAzD,cAAAA,cAYAyD,QAAAtD,cAAAA,aAUA,IAAIuD,YASJtD,YAAA,WAYI,QAAAA,GAAYH,EAAyBC,GACjC,GADiCyD,KAAAzD,OAAAA,EAV3ByD,KAAAC,WAEAD,KAAAE,YACAF,KAAAG,YA4fFH,KAAAI,YApfA7D,EAAQ,CACRA,EAAO8D,IAAIL,KACX,IAAIM,GAAoBtB,EAAEuB,KAAKhE,EAAOiE,YAAa,SACnDF,GAAK3D,IAAM2D,EAAK3D,KAAOqD,KAAKS,YAC5BT,KAAKU,UAAUJ,OAEfhE,GAAMA,MACNA,EAAIK,IAAML,EAAIK,KAAOqD,KAAKS,WAE9BT,MAAKU,UAAUpE,GAomBvB,MAhmBIqE,QAAAC,eAAInE,EAAAoE,UAAA,YAAJ,WACI,MAAOb,MAAKc,OAASxB,UAEzB,SAASA,GACLU,KAAKc,MAAQxB,mCAGP7C,EAAAoE,UAAAJ,UAAV,WACI,GAAI9D,GAAkB4C,SAASwB,QAAQC,KAAKC,MAAM,IAC9CC,OAAQ,MACRC,SAAWxE,IAAKoE,QAAQpE,IAAIyE,UAAY,gBAE5C,OAAOzE,IAUXF,EAAAoE,UAAAH,UAAA,SAAUpE,GACDA,IAGDA,EAAIM,OACJoD,KAAKpD,KAAON,EAAIM,MAEhBN,EAAIK,MACJqD,KAAKrD,IAAML,EAAIK,IAAMqC,EAAEqC,UAAW/E,EAAIK,IAAKqD,KAAKrD,SAC3CqD,KAAKpD,OACNoD,KAAKpD,KAAOF,iBAAiBJ,EAAIK,OAGzCqD,KAAKD,QAAUzD,EAAIyD,SAAWA,QAC1BzD,EAAIgF,SACJtB,KAAKsB,OAAShF,EAAIgF,OAAStC,EAAEqC,UAAW/E,EAAIgF,OAAQtB,KAAKsB,aAE7DtB,KAAK1D,IAAM0C,EAAEqC,OAAO/E,EAAK0D,KAAK1D,OAUlCG,EAAAoE,UAAAL,UAAA,WACI,MAAOR,MAAK1D,SAUhBG,EAAAoE,UAAAR,IAAA,SAAIkB,GACAA,EAAQhF,OAASyD,KACjBA,KAAKG,SAASqB,KAAKD,IASvB9E,EAAAoE,UAAAY,OAAA,SAAOF,GACH,GAAIG,GAAQ1C,EAAEyC,OAAOzB,KAAKG,SAAUoB,EAMpC,OALAvC,GAAE2C,KAAKD,EAAO,SAAAE,GACNA,IACAA,EAAErF,OAAS,QAGZmF,GAaXjF,EAAAoE,UAAAgB,KAAA,SAA6BpD,EAAkCqD,GAC3D,GAAIP,EAYJ,OAXAvB,MAAK2B,KAAQ,SAAAI,GACT,GAAIR,EACA,OAAO,CAEX,IAAIS,GAAWhD,EAAEG,WAAWV,GAAWA,EAAQsD,GAAuBtD,IAAasD,CACnF,QAAIC,IACAT,EAAUQ,GACH,IAGZD,GACIP,GAYX9E,EAAAoE,UAAAnC,OAAA,SAA+BD,EAAqCqD,GAChE,GAAIG,KAMJ,OALAjC,MAAK2B,KAAQ,SAAAI,GACLtD,EAAQsD,IACRE,EAAST,KAAKO,IAEnBD,GACIG,GAUXxF,EAAAoE,UAAAc,KAAA,SAA6BlD,EAAqCqD,GAC9DA,EAAOA,GAAQhF,aAAAoF,KAAKC,QACpB,IAAIC,EACJ,QAAQN,GACJ,IAAKhF,cAAAoF,KAAKG,MACND,EAAIpC,KAAKqC,MAAM5D,EACf,MACJ,KAAK3B,cAAAoF,KAAK/B,SACNiC,EAAIpC,KAAKsC,aAAa7D,EACtB,MAEJ,KAAK3B,cAAAoF,KAAKC,SACNC,EAAIpC,KAAKuC,MAAM9D,EACf,MACJ,SACI2D,EAAIpC,KAAKuC,MAAM9D,GAGvB,MAAO2D,IAcX3F,EAAAoE,UAAA5B,IAAA,SAAOR,EAAmCqD,EAAapD,GACnD,GAAI8D,KAUJ,OATAxC,MAAK2B,KAAK,SAAC1D,GACHS,EACIA,EAAOT,IACPuE,EAAIhB,KAAK/C,EAAQR,IAGrBuE,EAAIhB,KAAK/C,EAAQR,KAEtB6D,GACIU,GAGX/F,EAAAoE,UAAAyB,aAAA,SAAa7D,GACTO,EAAE2C,KAAK3B,KAAKG,SAAU,SAAA4B,GAClB,MAAOtD,GAAQsD,MAWvBtF,EAAAoE,UAAAwB,MAAA,SAAM5D,GACF,QAAKA,EAAQuB,QAGTA,KAAKzD,QAAUyD,KAAKzD,OAAO8F,MACpBrC,KAAKzD,OAAO8F,MAAM5D,GAD7B,SAWJhC,EAAAoE,UAAA0B,MAAA,SAAM9D,GACF,MAAIA,GAAQuB,SAAU,IAGtBhB,EAAE2C,KAAK3B,KAAKG,SAAU,SAAA4B,GAClB,MAAOA,GAAKQ,MAAM9D,MAEf,IAGXhC,EAAAoE,UAAA4B,aAAA,SAAaC,EAAiBC,GAC1B,MAAI3C,MAAKsB,OAAOqB,MACL3C,KAAKsB,OAAOqB,MAAMD,EAAMC,GAE5BjD,QAAA+C,aAAaC,EAAMC,IAG9BlG,EAAAoE,UAAA+B,OAAA,SAAOF,EAAkBG,GAAA,SAAAA,IAAAA,GAAA,EACrB,IAAIrF,GACAS,EAAM+B,KACNpD,EAAO8F,EAAQA,EAAK9F,MAAQqB,EAAIrB,KAAQqB,EAAIrB,IAchD,OAbI8F,IAAQA,EAAKnF,SACbC,EAAM0B,cAAc5B,aAAaoF,EAAKnF,OAAQX,GAAOqB,IAGpDT,GACDwC,KAAKqC,MAAM,SAAAS,GAEP,MADAtF,GAAM0B,cAAc5B,aAAawF,EAAExB,OAAQ1E,GAAOkG,IAC9CtF,IAMJqF,KAAa,EAASrF,EAAMkC,QAAAqD,YAAY9E,EAAItB,IAAIqG,KAAMxF,IAGlEf,EAAAoE,UAAAoC,QAAA,SAAQP,EAAkBG,GAAA,SAAAA,IAAAA,GAAA,EACtB,IAAI/E,GACAG,EAAM+B,IAeV,OAbI0C,IAAQA,EAAKnF,SACbO,EAAOC,eAAe2E,EAAKnF,OAAQU,IAElCH,GACDkC,KAAKqC,MAAM,SAAAS,GAEP,MADAhF,GAAOC,eAAe+E,EAAExB,OAAQwB,IAC5BhF,IAOJ+E,KAAa,EAAS/E,EAAO4B,QAAAwD,aAAajF,EAAItB,IAAIqG,KAAMlF,IAGpErB,EAAAoE,UAAAsC,YAAA,SAAYT,EAAMU,GAAA,SAAAA,IAAAA,EAAA,GACd,IAAInF,GAAM+B,KACNZ,EAAO,EAEPJ,GAAEqE,SAASX,GACXtD,EAAOsD,EACAA,GAAQA,IAASzE,EAAIqD,SAExBoB,EAAKtD,OACLA,EAAOlB,cAAcwE,EAAKtD,KAAMnB,KAE/BmB,GAAQsD,EAAKnF,QAAUmF,EAAKnF,OAAO6B,OACpCA,EAAOlB,cAAcwE,EAAKnF,OAAO6B,KAAMnB,IAG/C,IAAIqF,EASJ,OARAtD,MAAKqC,MAAM,SAAAS,GAEP,MADAQ,GAAUpF,cAAc4E,EAAExB,OAAOlC,KAAM0D,IACnCQ,IAMJA,EACoC,IAAhClE,EAAKmE,QAAQD,EAAU,KAChBlE,EAGPA,GAAQkE,IAAYlE,EACVkE,EAAO,IAAIlE,EAASgE,EAE3BE,EAAUF,EAEVhE,EAAOgE,GAItB3G,EAAAoE,UAAA2C,UAAA,SAAUC,EAAyBd,GAC/B,GAAI1E,GAAM+B,IACV,OAAOL,aAAA+D,kBAAkBD,EAAQzE,EAAEqC,QAASzE,KAAMqB,EAAIrB,MAAQ+F,OAAc3C,OAGhFvD,EAAAoE,UAAA8C,eAAA,SAAeC,EAAkBjB,GAC7B,GAAI1E,GAAM+B,IACV,OAAOL,aAAAgE,eAAe1F,EAAI4F,GAAGD,GAAO5E,EAAEqC,QAASzE,KAAMqB,EAAIrB,MAAQ+F,OAAc3C,OAGnFvD,EAAAoE,UAAAiD,eAAA,SAAeL,GACX,MAAO9D,aAAAoE,uBAAuBN,IAGlChH,EAAAoE,UAAAmD,oBAAA,SAAoBJ,GAChB,MAAOjE,aAAAqE,oBAAoBhE,KAAK6D,GAAGD,KAGvCnH,EAAAoE,UAAAoD,WAAA,SAAWxF,EAAcC,EAAwCC,GAC7D,MAAOH,OAAMC,EAASC,EAAQC,IAalClC,EAAAoE,UAAAqD,WAAA,SAAWC,EAAgBC,GACvB,MAAO3E,gBAAAyE,WAAWlE,KAAKV,KAAM6E,EAAOnE,KAAMoE,IAY9C3H,EAAAoE,UAAAwD,YAAA,SAAYF,GACR,MAAO1E,gBAAA4E,YAAYrE,KAAKV,KAAM6E,IAYlC1H,EAAAoE,UAAAyD,gBAAA,SAAgBH,EAAmCC,GAC/C,MAAO3E,gBAAA6E,gBAAgBtE,KAAKV,KAAM6E,EAAOnE,KAAMoE,IAYnD3H,EAAAoE,UAAA0D,YAAA,SAAYJ,EAAcC,GACtB,MAAO3E,gBAAA8E,YAAYvE,KAAKV,KAAM6E,EAAOnE,KAAMoE,IAY/C3H,EAAAoE,UAAA2D,gBAAA,SAAgBL,EAAcC,GAC1B,MAAO3E,gBAAA+E,gBAAgBxE,KAAKV,KAAM6E,EAAOnE,KAAMoE,IAanD3H,EAAAoE,UAAA4D,aAAA,SAAaN,EAAkDxB,GAC3D,GAAI1E,GAAM+B,KACN0E,EAAQlF,eAAAiF,aAAaN,EAAOnF,EAAEqC,QAASzE,KAAMqB,EAAIrB,MAAQ+F,OAAc3C,KAE3E,OADAA,MAAKC,QAAUD,KAAKC,QAAQ0E,OAAOD,GAC5B1E,KAAKC,SAYhBxD,EAAAoE,UAAA+D,cAAA,SAAc1E,EAAiBwC,GAC3B,MAAI1C,MAAK1D,IAAIsI,cACF5E,KAAK1D,IAAIsI,cAAc1E,EAAUwC,GAErCjD,eAAAmF,cAAc1E,EAAUwC,EAAM1C,OAGzCvD,EAAAoE,UAAAgE,YAAA,WACI,MAAO7E,MAAKrD,IAAIqG,MAGpBvG,EAAAoE,UAAAiE,eAAA,SAAerG,GACX,MAAOuB,MAAK+E,WAAW/E,KAAK6E,cAAepG,IAG/ChC,EAAAoE,UAAAkE,WAAA,SAAWC,EAAiBvG,GAA5B,GAAAwG,GAAAjF,KACQkF,EAAMrF,GAAGsF,YAAYH,GACrBI,IAeJ,OAdApG,GAAE2C,KAAKuD,EAAK,SAACG,GACT,GAAIC,GAAK1F,KAAK2F,KAAKP,EAASK,GACxBG,EAAI3F,GAAG4F,UAAUH,EACrB,IAAIE,EAAEE,cACF,GAAIjH,EAAS,CACT,GAAIkH,GAAKlH,EAAQ6G,EAAID,EAAGJ,EACpBU,IACAP,EAAQ5D,KAAKmE,OAGjBP,GAAQ5D,KAAK8D,KAIlBF,GAGX3I,EAAAoE,UAAA+E,eAAA,SAAenH,EAA0BiE,GACrC,MAAO1C,MAAK+E,WAAW/E,KAAKiD,QAAQP,GAAOjE,IAG/ChC,EAAAoE,UAAAgF,UAAA,SAAUrI,GACN,MAAOkC,SAAAqD,YAAY/C,KAAK1D,IAAIK,IAAIqG,KAAMxF,IAG1Cf,EAAAoE,UAAAiF,WAAA,SAAWd,GACP,MAAOtF,SAAAwD,aAAalD,KAAK1D,IAAIK,IAAIqG,KAAMgC,IAG3CvI,EAAAoE,UAAAkF,UAAA,SAAUvI,EAAUkF,GAChB,MAAOhD,SAAAqD,YAAY/C,KAAKiD,QAAQP,GAAOlF,IAG3Cf,EAAAoE,UAAAmF,WAAA,SAAWhB,EAAiBtC,GACxB,MAAOhD,SAAAwD,aAAalD,KAAKiD,QAAQP,GAAOsC,IAG5CvI,EAAAoE,UAAAgD,GAAA,SAAMoC,GACF,MAAOjH,GAAEG,WAAW8G,GAAWA,EAAQjG,MAAQiG,GAGnDxJ,EAAAoE,UAAAqF,MAAA,SAAMC,GACF,MAAOjH,eAAciH,EAAQnG,OAGjCvD,EAAAoE,UAAAuF,MAAA,SAAMhH,GACF,MAAOlB,eAAckB,EAAMY,OAG/BvD,EAAAoE,UAAAwF,MAAA,SAAMC,EAAkBC,GACpB,OAAQA,EAAS3G,KAAKiD,SAASyD,EAAUC,GAAUD,GAAUE,QAAQ,MAAO,MAIhF/J,EAAAoE,UAAA4F,WAAA,SAAWC,GACPA,EAAWA,GAAY1G,KAAK1D,IAAIqK,WAChC,IAAIvH,GAAOY,KAAK8F,WAAW9F,KAAKoG,MAAMM,IAAa,eAInD,OAHK1G,MAAKI,SAAShB,KACfY,KAAKI,SAAShB,GAAQC,QAAQD,IAE3BY,KAAKI,SAAShB,IAGzB3C,EAAAoE,UAAA+F,MAAA,WAAA,GAAA3B,GAAAjF,IAEI,OAAIA,MAAKsB,OAAO1E,OAASoD,KAAKpD,KAAOoD,KAAKsB,OAAO1E,OAAS,EAC/CgC,QAAQC,YAERD,QAAQiI,KAEP7G,KAAK8G,qBACF9G,KAAKf,IAAI,SAAAhB,GACR,MAAOA,GAAI2I,QACN7H,KAAK,SAAAgI,GACF,MAAO9I,MAEhBnB,aAAAoF,KAAK/B,YAEXpB,KAAK,SAAAiI,GACF,GAAIC,GAAMhC,EAAK3D,OACX4F,EAAOF,EAAKG,QACZC,EAAY1H,QAAA2H,UAA0BL,EAAM,SAAA/I,GAAO,MAAAA,GAAIqD,OAAOgG,OAAOrC,GAErEsC,IAuBJ,OAtBAvI,GAAE2C,KAAKyF,EAAW,SAACI,EAAGC,GAClB,GAAIzI,EAAE0I,QAAQF,GACVD,EAAO/F,KAAKxC,EAAEN,OAAOM,EAAEC,IAAIuI,EAAG,SAAAG,GAAM,MAAA1C,GAAKV,YAAmBoD,EAAGC,oBAAoB,SAAAD,GAAM,QAAEA,SACxF,CACH,GAAIE,GAAK5C,EAAKV,YAAYiD,EAAEI,iBACxBC,IACAN,EAAO/F,KAAKqG,MAMxBX,EAAOD,EAAIa,SAAWhL,aAAAiL,OAAOC,UAAY/C,EAAKT,gBAAgB0C,IAASA,EACnEK,GAAUA,EAAOU,OAAS,IACtBhB,EAAIiB,eAAiBpL,aAAAqL,aAAaC,MAClClB,EAAKmB,OAAMC,MAAXpB,GAAY,EAAG,GAACvC,OAAK4C,IAErBL,EAAK1F,KAAI8G,MAATpB,EAAaK,IAIrBtC,EAAK/E,SAAWgH,EACTjC,EAAK/E,YAK5BzD,EAAAoE,UAAA+G,eAAA,WACI,MAAO5H,MAAKE,cAGhBzD,EAAAoE,UAAAiG,WAAA,WACI,MAAO9G,MAAKkE,WAAWlE,KAAKC,UAGhCxD,EAAAoE,UAAA0H,QAAA,eAAQ,GAAA7F,MAAA8F,EAAA,EAAAA,EAAAC,UAAAR,OAAAO,IAAA9F,EAAA8F,GAAAC,UAAAD,IACJE,EAAA1I,KAAKC,SAAQuB,KAAI8G,MAAAI,EAAIhG,UAGzBjG,EAAAoE,UAAA8H,WAAA,SAAWjG,GACP,GAAI+E,GAAMzH,KAAKC,QAAQsD,QAAQb,EAC/B,OAAI+E,IAAO,GAAKA,EAAMzH,KAAKC,QAAQgI,OACxBjI,KAAKC,QAAQoI,OAAOZ,EAAK,OAaxChL,EAAAoE,UAAA+H,IAAA,WAAA,GAAA3D,GAAAjF,IACI,OAAIA,MAAKrD,IAAIkM,KACFjK,QAAQC,QAAQmB,KAAK6I,QAErB7I,KAAK4G,QACP7H,KAAK,SAAAmI,GACF,GAAID,GAAMhC,EAAK3D,MACf,OAAI2F,GAAIa,SAAWhL,aAAAiL,OAAOC,SACf/C,EAAKZ,aAAaY,EAAKT,gBAAgB0C,KAEvCjC,EAAKZ,YAAY6C,MAM5CzK,EAAAoE,UAAAgI,KAAA,WACI7I,KAAK1D,IAAIwM,WAAa9I,KAAK1D,IAAIwM,UAAU9J,EAAE+J,UAAU/I,KAAKrD,IAAIkM,MAAQ,GAAK7I,KAAKrD,IAAIkM,OAGxFpM,EAAAoE,UAAAsD,MAAA,SAAM1F,GACF,MAAOA,GAAUO,EAAEN,OAAOsB,KAAKC,QAASxB,GAAWuB,KAAKC,SAG5DxD,EAAAoE,UAAAmI,cAAA,SAAcvK,GACV,GAAI0F,KAIJ,OAHAnE,MAAK2B,KAAK,SAAAmB,GACNqB,EAAQA,EAAMQ,OAAO7B,EAAEqB,MAAM1F,MAE1B0F,GAGX1H,EAAAoE,UAAAoI,YAAA,WACI,MAAOjK,GAAEkK,KAAKlJ,KAAKD,QAAQoE,YAEnC1H,IA1nBaqD,SAAArD,YAAAA","file":"../TaskContext.js","sourcesContent":["import *as _ from 'lodash';\r\nimport { Gulp } from 'gulp';\r\nimport *as gulp from 'gulp';\r\nimport * as minimist from 'minimist';\r\nimport {\r\n    ITask, IAssertDist, IEnvOption, Operation, ITaskContext, ITaskDefine, IDynamicTaskOption\r\n    , NodeSequence, RunWay, ZipTaskName, Express, Mode, ITaskConfig, ITaskInfo, Src, TaskSource, IAsserts, TaskString, folderCallback\r\n} from './TaskConfig';\r\nimport { generateTask } from './generateTask';\r\nimport { toSequence, runSequence, addToSequence, zipSequence, flattenSequence, runTaskSequence } from './taskSequence';\r\nimport { sortOrder, matchCompare, absoluteSrc, absolutePath } from './utils';\r\nimport { findTasksInModule, findTaskDefineInModule, findTasksInDir, findTaskDefineInDir } from './findTasks';\r\nimport *as path from 'path';\r\nimport *as fs from 'fs';\r\nconst globby = require('globby');\r\n\r\n/**\r\n *binding Config, create task context.\r\n *\r\n *@export\r\n *@param {ITaskConfig} cfg\r\n *@param {ITaskContext} [parent]\r\n *@returns {ITaskContext}\r\n */\r\nexport function bindingConfig(cfg: ITaskConfig, parent?: ITaskContext): ITaskContext {\r\n    return createContext(cfg, parent);\r\n}\r\n\r\n/**\r\n *create Task context.\r\n *\r\n *@export\r\n *@param {ITaskConfig} cfg\r\n *@param {ITaskContext} [parent]\r\n *@returns {ITaskContext}\r\n */\r\nexport function createContext(cfg: ITaskConfig, parent?: ITaskContext): ITaskContext {\r\n    if (cfg.createContext) {\r\n        return cfg.createContext(cfg, parent);\r\n    }\r\n    return new TaskContext(cfg, parent);\r\n}\r\n\r\n/**\r\n *global data.\r\n */\r\nlet globals = {};\r\n\r\n/**\r\n *TaskContext\r\n *\r\n *@export\r\n *@class TaskContext\r\n *@implements {ITaskContext}\r\n */\r\nexport class TaskContext implements ITaskContext {\r\n    protected cfg: ITaskConfig;\r\n    protected taskseq: ITask[] = [];\r\n\r\n    protected sequence: Src[] = [];\r\n    protected children: ITaskContext[] = [];\r\n\r\n    oper: Operation;\r\n    option: IAsserts;\r\n    env: IEnvOption;\r\n    globals: any;\r\n\r\n    constructor(cfg: ITaskConfig, public parent?: ITaskContext) {\r\n        if (parent) {\r\n            parent.add(this);\r\n            let pcfg: ITaskConfig = _.omit(parent.getConfig(), 'option');\r\n            pcfg.env = pcfg.env || this.createEnv();\r\n            this.setConfig(pcfg);\r\n        } else {\r\n            cfg = cfg || {};\r\n            cfg.env = cfg.env || this.createEnv();\r\n        }\r\n        this.setConfig(cfg);\r\n    }\r\n\r\n    private _gulp: Gulp;\r\n    get gulp() {\r\n        return this._gulp || gulp;\r\n    }\r\n    set gulp(gulp: Gulp) {\r\n        this._gulp = gulp;\r\n    }\r\n\r\n    protected createEnv(): IEnvOption {\r\n        let env: IEnvOption = minimist(process.argv.slice(2), {\r\n            string: 'env',\r\n            default: { env: process.env.NODE_ENV || 'development' }\r\n        });\r\n        return env;\r\n    }\r\n\r\n    /**\r\n     *load config\r\n     *\r\n     *@param {ITaskConfig} cfg\r\n     *\r\n     *@memberof TaskContext\r\n     */\r\n    setConfig(cfg: ITaskConfig) {\r\n        if (!cfg) {\r\n            return;\r\n        }\r\n        if (cfg.oper) {\r\n            this.oper = cfg.oper;\r\n        }\r\n        if (cfg.env) {\r\n            this.env = cfg.env = _.extend({}, cfg.env, this.env || {});\r\n            if (!this.oper) {\r\n                this.oper = currentOperation(cfg.env);\r\n            }\r\n        }\r\n        this.globals = cfg.globals || globals;\r\n        if (cfg.option) {\r\n            this.option = cfg.option = _.extend({}, cfg.option, this.option || {});\r\n        }\r\n        this.cfg = _.extend(cfg, this.cfg);\r\n    }\r\n\r\n    /**\r\n     *get config.\r\n     *\r\n     *@returns {ITaskConfig}\r\n     *\r\n     *@memberof TaskContext\r\n     */\r\n    getConfig(): ITaskConfig {\r\n        return this.cfg || {};\r\n    }\r\n\r\n    /**\r\n     *add sub ITaskContext\r\n     *\r\n     *@param {ITaskContext} context\r\n     *\r\n     *@memberOf ITaskContext\r\n     */\r\n    add(context: ITaskContext): void {\r\n        context.parent = this;\r\n        this.children.push(context);\r\n    }\r\n    /**\r\n     *remove sub ITaskContext.\r\n     *\r\n     *@param {ITaskContext} [context]\r\n     *\r\n     *@memberOf ITaskContext\r\n     */\r\n    remove(context?: ITaskContext): ITaskContext[] {\r\n        let items = _.remove(this.children, context);\r\n        _.each(items, i => {\r\n            if (i) {\r\n                i.parent = null;\r\n            }\r\n        });\r\n        return items;\r\n    }\r\n\r\n\r\n    /**\r\n     *find sub context via express.\r\n     *\r\n     *@template T\r\n     *@param {(T | Express<T, boolean>)} express\r\n     *@param {Mode} [mode]\r\n     *@returns {T}\r\n     *@memberof TaskContext\r\n     */\r\n    find<T extends ITaskContext>(express: T | Express<T, boolean>, mode?: Mode): T {\r\n        let context: ITaskContext;\r\n        this.each<T>(item => {\r\n            if (context) {\r\n                return false;\r\n            }\r\n            let isFinded = _.isFunction(express) ? express(item) : (<ITaskContext>express) === item;\r\n            if (isFinded) {\r\n                context = item;\r\n                return false;\r\n            }\r\n            return true;\r\n        }, mode);\r\n        return context as T;\r\n    }\r\n\r\n    /**\r\n     *filter items.\r\n     *\r\n     *@template T\r\n     *@param {(Express<T, void | boolean>)} express\r\n     *@param {Mode} [mode]\r\n     *@returns {ITaskContext[]}\r\n     *@memberof TaskContext\r\n     */\r\n    filter<T extends ITaskContext>(express: Express<T, void | boolean>, mode?: Mode): ITaskContext[] {\r\n        let contexts: ITaskContext[] = [];\r\n        this.each<T>(item => {\r\n            if (express(item)) {\r\n                contexts.push(item);\r\n            }\r\n        }, mode);\r\n        return contexts;\r\n    }\r\n    /**\r\n     *find parent context via express.\r\n     *\r\n     *@param {(ITaskContext | Express<ITaskContext, boolean>)} express\r\n     *@param {Mode} [mode] {enum:['route','children', traverse']} default traverse.\r\n     *\r\n     *@memberOf ITaskContext\r\n     */\r\n    each<T extends ITaskContext>(express: Express<T, void | boolean>, mode?: Mode) {\r\n        mode = mode || Mode.traverse;\r\n        let r;\r\n        switch (mode) {\r\n            case Mode.route:\r\n                r = this.route(express);\r\n                break;\r\n            case Mode.children:\r\n                r = this.eachChildren(express);\r\n                break;\r\n\r\n            case Mode.traverse:\r\n                r = this.trans(express);\r\n                break;\r\n            default:\r\n                r = this.trans(express);\r\n                break;\r\n        }\r\n        return r;\r\n    }\r\n\r\n    /**\r\n     * map context.\r\n     *\r\n     *@template T\r\n     *@param {Express<ITaskContext, T>} express\r\n     *@param {Mode} [mode]\r\n     *@param {Express<ITaskContext, boolean>} [filter]\r\n     *@returns {T[]}\r\n     *\r\n     *@memberof TaskContext\r\n     */\r\n    map<T>(express: Express<ITaskContext, T>, mode?: Mode, filter?: Express<ITaskContext, boolean>): T[] {\r\n        let arr: T[] = []\r\n        this.each((ctx) => {\r\n            if (filter) {\r\n                if (filter(ctx)) {\r\n                    arr.push(express(ctx));\r\n                }\r\n            } else {\r\n                arr.push(express(ctx));\r\n            }\r\n        }, mode);\r\n        return arr;\r\n    }\r\n\r\n    eachChildren(express: Express<ITaskContext, void | boolean>) {\r\n        _.each(this.children, item => {\r\n            return express(item);\r\n        });\r\n    }\r\n\r\n    /**\r\n     *do express work in routing.\r\n     *\r\n     *@param {Express<ITaskContext, void | boolean>} express\r\n     *\r\n     *@memberOf ITaskContext\r\n     */\r\n    route(express: Express<ITaskContext, void | boolean>) {\r\n        if (!express(this)) {\r\n            return false;\r\n        };\r\n        if (this.parent && this.parent.route) {\r\n            return this.parent.route(express);\r\n        }\r\n    }\r\n    /**\r\n     *translate all sub context to do express work.\r\n     *\r\n     *@param {Express<ITaskContext, void | boolean>} express\r\n     *\r\n     *@memberOf ITaskContext\r\n     */\r\n    trans(express: Express<ITaskContext, void | boolean>) {\r\n        if (express(this) === false) {\r\n            return false;\r\n        }\r\n        _.each(this.children, item => {\r\n            return item.trans(express);\r\n        });\r\n        return true;\r\n    }\r\n\r\n    matchCompare(task: ITaskInfo, match: ITaskInfo): boolean {\r\n        if (this.option.match) {\r\n            return this.option.match(task, match);\r\n        }\r\n        return matchCompare(task, match);\r\n    }\r\n\r\n    getSrc(task?: ITaskInfo, relative = false): Src {\r\n        let src: Src;\r\n        let ctx = this;\r\n        let oper = task ? (task.oper || ctx.oper) : ctx.oper;\r\n        if (task && task.assert) {\r\n            src = taskSourceVal(getAssertSrc(task.assert, oper), ctx)\r\n        }\r\n\r\n        if (!src) {\r\n            this.route(c => {\r\n                src = taskSourceVal(getAssertSrc(c.option, oper), c);\r\n                if (src) {\r\n                    return false;\r\n                }\r\n                return true;\r\n            });\r\n        }\r\n        return (relative !== false) ? src : absoluteSrc(ctx.env.root, src);\r\n    }\r\n\r\n    getDist(task?: ITaskInfo, relative = false): string {\r\n        let dist: string;\r\n        let ctx = this;\r\n        // let oper = task ? (task.oper || context.oper) : context.oper;\r\n        if (task && task.assert) {\r\n            dist = getCurrentDist(task.assert, ctx);\r\n        }\r\n        if (!dist) {\r\n            this.route(c => {\r\n                dist = getCurrentDist(c.option, c);\r\n                if (dist) {\r\n                    return false;\r\n                }\r\n                return true;\r\n            });\r\n        }\r\n\r\n        return (relative !== false) ? dist : absolutePath(ctx.env.root, dist);\r\n    }\r\n\r\n    subTaskName(task, ext = '') {\r\n        let ctx = this;\r\n        let name = '';\r\n        // let oper = context.oper;\r\n        if (_.isString(task)) {\r\n            name = task;\r\n        } else if (task && task !== ctx.option) {\r\n            // oper = task.oper || context.oper;\r\n            if (task.name) {\r\n                name = taskStringVal(task.name, ctx)\r\n            }\r\n            if (!name && task.assert && task.assert.name) {\r\n                name = taskStringVal(task.assert.name, ctx)\r\n            }\r\n        }\r\n        let optName: string;\r\n        this.route(c => {\r\n            optName = taskStringVal(c.option.name, c);\r\n            if (optName) {\r\n                return false;\r\n            }\r\n            return true;\r\n        })\r\n\r\n        if (optName) {\r\n            if (name.indexOf(optName + '-') === 0) {\r\n                return name;\r\n            }\r\n            // avoid soma name.\r\n            if (name && optName !== name) {\r\n                return `${optName}-${name}` + ext;\r\n            }\r\n            return optName + ext;\r\n        } else {\r\n            return name + ext;\r\n        }\r\n    }\r\n\r\n    findTasks(module: string | Object, match?: ITaskInfo): Promise<ITask[]> {\r\n        let ctx = this;\r\n        return findTasksInModule(module, _.extend({ oper: ctx.oper }, match || {}), this);\r\n    }\r\n\r\n    findTasksInDir(dirs: TaskSource, match?: ITaskInfo): Promise<ITask[]> {\r\n        let ctx = this;\r\n        return findTasksInDir(ctx.to(dirs), _.extend({ oper: ctx.oper }, match || {}), this);\r\n    }\r\n\r\n    findTaskDefine(module: string | Object): Promise<ITaskDefine> {\r\n        return findTaskDefineInModule(module);\r\n    }\r\n\r\n    findTaskDefineInDir(dirs: TaskSource): Promise<ITaskDefine> {\r\n        return findTaskDefineInDir(this.to(dirs));\r\n    }\r\n\r\n    fileFilter(express: Src, filter?: (fileName: string) => boolean, mapping?: (filename: string) => string): Promise<string[]> {\r\n        return files(express, filter, mapping);\r\n    }\r\n\r\n\r\n    /**\r\n     *to Sequence.\r\n     *\r\n     *@param {ITask[]} tasks\r\n     *@param {ZipTaskName} [zipName]\r\n     *@returns {Src[]}\r\n     *\r\n     *@memberof TaskContext\r\n     */\r\n    toSequence(tasks: ITask[], zipName?: ZipTaskName): Src[] {\r\n        return toSequence(this.gulp, tasks, this, zipName);\r\n    }\r\n\r\n    /**\r\n     *filter file in directory.  default implement in bindingConfig.\r\n     *\r\n     *@param {Gulp} gulp\r\n     *@param {Src[]} tasks\r\n     *@returns {Promise<any>}\r\n     *\r\n     *@memberOf ITaskContext\r\n     */\r\n    runSequence(tasks: Src[]): Promise<any> {\r\n        return runSequence(this.gulp, tasks);\r\n    }\r\n\r\n    /**\r\n     *run task sequence in this context.\r\n     *\r\n     *@param {(ITask[] | Promise<ITask[]>)} tasks\r\n     *@param {ZipTaskName} [zipName]\r\n     *@returns {Promise<any>}\r\n     *\r\n     *@memberof TaskContext\r\n     */\r\n    runTaskSequence(tasks: ITask[] | Promise<ITask[]>, zipName?: ZipTaskName): Promise<any> {\r\n        return runTaskSequence(this.gulp, tasks, this, zipName);\r\n    }\r\n\r\n    /**\r\n     *zip task sequence.\r\n     *\r\n     *@param {Src[]} tasks\r\n     *@param {ZipTaskName} [zipName]\r\n     *@returns {string}\r\n     *\r\n     *@memberof ITaskContext\r\n     */\r\n    zipSequence(tasks: Src[], zipName?: ZipTaskName): string {\r\n        return zipSequence(this.gulp, tasks, this, zipName);\r\n    }\r\n\r\n    /**\r\n     *flattenSequence in this context.\r\n     *\r\n     *@param {Src[]} tasks\r\n     *@param {ZipTaskName} [zipName]\r\n     *@returns {string[]}\r\n     *\r\n     *@memberof ITaskContext\r\n     */\r\n    flattenSequence(tasks: Src[], zipName?: ZipTaskName): string[] {\r\n        return flattenSequence(this.gulp, tasks, this, zipName);\r\n    }\r\n\r\n\r\n    /**\r\n     *dynamic generate tasks.  default implement in bindingConfig.\r\n     *\r\n     *@param {(IDynamicTaskOption | IDynamicTaskOption[])} tasks\r\n     *@param {ITaskInfo} [match]\r\n     *@returns {ITask[]}\r\n     *\r\n     *@memberOf ITaskContext\r\n     */\r\n    generateTask(tasks: IDynamicTaskOption | IDynamicTaskOption[], match?: ITaskInfo): ITask[] {\r\n        let ctx = this;\r\n        let gtask = generateTask(tasks, _.extend({ oper: ctx.oper }, match || {}), this);\r\n        this.taskseq = this.taskseq.concat(gtask);\r\n        return this.taskseq;\r\n    }\r\n\r\n    /**\r\n     *add task result to task sequence. default implement in bindingConfig.\r\n     *\r\n     *@param {Src[]} sequence  task sequence.\r\n     *@param {ITaskInfo} task\r\n     *@returns {Src[]}\r\n     *\r\n     *@memberOf ITaskContext\r\n     */\r\n    addToSequence(sequence: Src[], task: ITaskInfo): Src[] {\r\n        if (this.cfg.addToSequence) {\r\n            return this.cfg.addToSequence(sequence, task);\r\n        }\r\n        return addToSequence(sequence, task, this);\r\n    }\r\n\r\n    getRootPath() {\r\n        return this.env.root;\r\n    }\r\n\r\n    getRootFolders(express?: folderCallback): string[] {\r\n        return this.getFolders(this.getRootPath(), express);\r\n    }\r\n\r\n    getFolders(pathstr: string, express?: folderCallback): string[] {\r\n        let dir = fs.readdirSync(pathstr);\r\n        let folders = [];\r\n        _.each(dir, (d: string) => {\r\n            let sf = path.join(pathstr, d);\r\n            let f = fs.lstatSync(sf);\r\n            if (f.isDirectory()) {\r\n                if (express) {\r\n                    let fl = express(sf, d, this);\r\n                    if (fl) {\r\n                        folders.push(fl);\r\n                    }\r\n                } else {\r\n                    folders.push(sf);\r\n                }\r\n            }\r\n        });\r\n        return folders;\r\n    }\r\n\r\n    getDistFolders(express?: folderCallback, task?: ITaskInfo): string[] {\r\n        return this.getFolders(this.getDist(task), express);\r\n    }\r\n\r\n    toRootSrc(src: Src): Src {\r\n        return absoluteSrc(this.cfg.env.root, src);\r\n    }\r\n\r\n    toRootPath(pathstr: string): string {\r\n        return absolutePath(this.cfg.env.root, pathstr);\r\n    }\r\n\r\n    toDistSrc(src: Src, task?: ITaskInfo): Src {\r\n        return absoluteSrc(this.getDist(task), src);\r\n    }\r\n\r\n    toDistPath(pathstr: string, task?: ITaskInfo): string {\r\n        return absolutePath(this.getDist(task), pathstr);\r\n    }\r\n\r\n    to<T>(setting: T | ((ctx: ITaskContext) => T)): T {\r\n        return _.isFunction(setting) ? setting(this) : setting;\r\n    }\r\n\r\n    toSrc(source: TaskSource): Src {\r\n        return taskSourceVal(source, this);\r\n    }\r\n\r\n    toStr(name: TaskString): string {\r\n        return taskStringVal(name, this);\r\n    }\r\n\r\n    toUrl(basePath: string, toPath?: string): string {\r\n        return (toPath ? path.relative(basePath, toPath) : basePath).replace(/\\\\/g, '/'); // .replace(/^\\//g, '');\r\n    }\r\n\r\n    private packages = {};\r\n    getPackage(filename?: TaskString): any {\r\n        filename = filename || this.cfg.packageFile;\r\n        let name = this.toRootPath(this.toStr(filename) || 'package.json');\r\n        if (!this.packages[name]) {\r\n            this.packages[name] = require(name);\r\n        }\r\n        return this.packages[name]\r\n    }\r\n\r\n    setup(): Promise<Src[]> {\r\n\r\n        if (this.option.oper && (this.oper & this.option.oper) <= 0) {\r\n            return Promise.resolve([]);\r\n        } else {\r\n            return Promise.all<any>(\r\n                [\r\n                    this.setupTasks(),\r\n                    ...this.map(ctx => {\r\n                        return ctx.setup()\r\n                            .then(seq => {\r\n                                return ctx;\r\n                            });\r\n                    }, Mode.children)\r\n                ])\r\n                .then(srcs => {\r\n                    let opt = this.option as IAsserts;\r\n                    let tseq = srcs.shift() as Src[];\r\n                    let ordertask = sortOrder(<ITaskContext[]>srcs, ctx => ctx.option.order, this);\r\n\r\n                    let subseq: Src[] = [];\r\n                    _.each(ordertask, (t, idx) => {\r\n                        if (_.isArray(t)) {\r\n                            subseq.push(_.filter(_.map(t, it => this.zipSequence(<Src[]>it.getRunSequence())), it => !!it));\r\n                        } else {\r\n                            let tk = this.zipSequence(t.getRunSequence());\r\n                            if (tk) {\r\n                                subseq.push(tk);\r\n                            }\r\n                        }\r\n                    });\r\n\r\n                    // let children = this.zipSequence(subseq, (name, runway) => this.subTaskName(name, (runway === RunWay.sequence ? '-sub-seq' : '-sub-paral')));\r\n                    tseq = opt.runWay === RunWay.parallel ? [this.flattenSequence(tseq)] : tseq;\r\n                    if (subseq && subseq.length > 0) {\r\n                        if (opt.nodeSequence === NodeSequence.after) {\r\n                            tseq.splice(0, 0, ...subseq);\r\n                        } else {\r\n                            tseq.push(...subseq);\r\n                        }\r\n                    }\r\n\r\n                    this.sequence = tseq;\r\n                    return this.sequence;\r\n                });\r\n        }\r\n    }\r\n\r\n    getRunSequence(): Src[] {\r\n        return this.sequence || [];\r\n    }\r\n\r\n    setupTasks(): Src[] | Promise<Src[]> {\r\n        return this.toSequence(this.taskseq);\r\n    }\r\n\r\n    addTask(...task: ITask[]) {\r\n        this.taskseq.push(...task);\r\n    }\r\n\r\n    removeTask(task: ITask): ITask[] | Promise<ITask[]> {\r\n        let idx = this.taskseq.indexOf(task);\r\n        if (idx >= 0 && idx < this.taskseq.length) {\r\n            return this.taskseq.splice(idx, 1);\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     *run task in this context.\r\n     *\r\n     *@returns {Promise<any>}\r\n     *\r\n     *@memberof TaskContext\r\n     */\r\n    run(): Promise<any> {\r\n        if (this.env.help) {\r\n            return Promise.resolve(this.help())\r\n        } else {\r\n            return this.setup()\r\n                .then(tseq => {\r\n                    let opt = this.option as IAsserts;\r\n                    if (opt.runWay === RunWay.parallel) {\r\n                        return this.runSequence([this.flattenSequence(tseq)]);\r\n                    } else {\r\n                        return this.runSequence(tseq);\r\n                    }\r\n                });\r\n        }\r\n    }\r\n\r\n    help() {\r\n        this.cfg.printHelp && this.cfg.printHelp(_.isBoolean(this.env.help) ? '' : this.env.help);\r\n    }\r\n\r\n    tasks(express?: (item: ITask) => boolean): ITask[] {\r\n        return express ? _.filter(this.taskseq, express) : this.taskseq;\r\n    }\r\n\r\n    registerTasks(express?: (item: ITask) => boolean): ITask[] {\r\n        let tasks = [];\r\n        this.each(c => {\r\n            tasks = tasks.concat(c.tasks(express));\r\n        });\r\n        return tasks;\r\n    }\r\n\r\n    globalTasks(): string[] {\r\n        return _.keys(this.globals.tasks || {});\r\n    }\r\n}\r\n\r\n\r\n/**\r\n *get current env Operation.\r\n *\r\n *@export\r\n *@param {EnvOption} env\r\n *@returns\r\n */\r\nfunction currentOperation(env: IEnvOption) {\r\n    let oper: Operation;\r\n    if (env.deploy) {\r\n        oper = Operation.deploy | Operation.release;\r\n    } else if (env.release) {\r\n        oper = Operation.release;\r\n    } else {\r\n        oper = Operation.build;\r\n    }\r\n\r\n    if (env.watch) {\r\n        oper = oper | Operation.watch;\r\n    }\r\n    if (env.test) {\r\n        oper = oper | Operation.test;\r\n    }\r\n    if (env.serve) {\r\n        oper = oper | Operation.serve;\r\n    }\r\n    if (env.e2e) {\r\n        oper = oper | Operation.e2e;\r\n    }\r\n\r\n    return oper;\r\n}\r\n\r\n/**\r\n *get assert source.\r\n *\r\n *@param {IAssertDist} assert\r\n *@param {Operation} oper\r\n *@returns\r\n */\r\nfunction getAssertSrc(assert: IAssertDist, oper: Operation) {\r\n    let src = null;\r\n\r\n    if ((oper & Operation.test) > 0) {\r\n        src = assert.testSrc;\r\n    } else if ((oper & Operation.e2e) > 0) {\r\n        src = assert.e2eSrc;\r\n    } else if ((oper & Operation.watch) > 0) {\r\n        src = assert.watchSrc;\r\n    } else if ((oper & Operation.clean) > 0) {\r\n        src = assert.cleanSrc || assert.dist;\r\n    }\r\n\r\n\r\n    return src || assert.src;\r\n}\r\n\r\n/**\r\n *get dist.\r\n *\r\n *@param {IAssertDist} ds\r\n *@param {ITaskContext} ctx\r\n *@returns\r\n */\r\nfunction getCurrentDist(ds: IAssertDist, ctx: ITaskContext) {\r\n    let dist: string;\r\n    let env = ctx.env;\r\n    let oper = ctx.oper;\r\n    if (env.deploy || (oper & Operation.deploy) > 0) {\r\n        dist = taskStringVal(ds.deployDist, ctx);\r\n    }\r\n    if (!dist && (env.release || (oper & Operation.release) > 0)) {\r\n        dist = taskStringVal(ds.releaseDist, ctx);\r\n    }\r\n    if (!dist && (env.e2e || (oper & Operation.e2e) > 0)) {\r\n        dist = taskStringVal(ds.e2eDist, ctx);\r\n    }\r\n    if (!dist && (env.test || (oper & Operation.test) > 0)) {\r\n        dist = taskStringVal(ds.testDist, ctx);\r\n    }\r\n    if (!dist && ((oper & Operation.build) > 0)) {\r\n        dist = taskStringVal(ds.buildDist, ctx);\r\n    }\r\n    if (!dist) {\r\n        dist = taskStringVal(ds.dist, ctx);\r\n    }\r\n\r\n    return dist;\r\n}\r\n\r\n\r\n/**\r\n *filter fileName in directory.\r\n *\r\n *@export\r\n *@param {string} directory\r\n *@param {((fileName: string) => boolean)} [express]\r\n *@returns {string[]}\r\n */\r\nfunction files(express: Src, filter?: (fileName: string) => boolean, mapping?: (filename: string) => string): Promise<string[]> {\r\n    return Promise.resolve(globby(express))\r\n        .then((files: string[]) => {\r\n            if (filter) {\r\n                files = _.filter(files, filter)\r\n            }\r\n            if (mapping) {\r\n                files = _.map(files, mapping);\r\n            }\r\n            return files;\r\n        })\r\n}\r\n\r\n/**\r\n *task src, string or array string.\r\n *\r\n *@export\r\n *@param {TaskSource} src\r\n *@param {Operation} oper runtime Operation\r\n *@param {IEnvOption} [env]\r\n *@returns\r\n */\r\nfunction taskSourceVal(src: TaskSource, ctx: ITaskContext) {\r\n    return _.isFunction(src) ? src(ctx) : (src || '');\r\n}\r\n\r\n/**\r\n *task string.\r\n *\r\n *@export\r\n *@param {TaskString} name\r\n *@param {ITaskContext} ctx\r\n *@returns\r\n */\r\nfunction taskStringVal(name: TaskString, ctx: ITaskContext) {\r\n    return _.isFunction(name) ? name(ctx) : (name || '');\r\n}\r\n"]}