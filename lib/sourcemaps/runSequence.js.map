{"version":3,"sources":["runSequence.js","runSequence.ts"],"names":["toSequence","tasks","oper","seq","_","filter","it","len","length","orderBy","t","isString","isArray","order","each","push","flatten","name","runSequence","gulp","ps","Promise","resolve","task","then","taskErr","taskStop","reslove","reject","tskmap","err","process","exit","console","error","chalk","red","e","some","values","on","start","catch","runTaskSequence","config","taskseq","map","tk","require","exports"],"mappings":"AAAA,YCYA,SAAAA,YAA2BC,EAAqBC,GAC5C,GAAIC,KACJF,GAAQG,EAAEC,OAAOJ,EAAO,SAAAK,GAAA,MAAMA,IAC9B,IAAIC,GAAMN,EAAMO,MAmChB,OAlCAP,GAAQG,EAAEK,QAAQR,EAAO,SAAAS,GACrB,MAAIA,GACIN,EAAEO,SAASD,GACJH,EACAH,EAAEQ,QAAQF,GACVH,EAEcG,EAAGG,MAGzBN,IAIXH,EAAEU,KAAKb,EAAO,SAAAS,GACLA,IAGDN,EAAEO,SAASD,GACXP,EAAIY,KAAKL,GACFN,EAAEQ,QAAQF,GACjBP,EAAIY,KAAKX,EAAEY,QAAQhB,WAAWU,EAAGR,KAE7BQ,EAAEO,OACEP,EAAER,MACGQ,EAAER,KAAOA,GAAQ,GAClBC,EAAIY,KAAKL,EAAEO,MAGfd,EAAIY,KAAKL,EAAEO,UAKpBd,EAaX,QAAAe,aAA4BC,EAAYlB,GACpC,GAAImB,GAAKC,QAAQC,SAwCjB,OAvCIrB,IAASA,EAAMO,OAAS,GACxBJ,EAAEU,KAAKb,EAAO,SAAAsB,GACVH,EAAKA,EAAGI,KAAK,WACT,GAAIC,GAAU,KAAMC,EAAW,IAC/B,OAAO,IAAIL,SAAQ,SAACM,EAASC,GACzB,GAAIC,KACJzB,GAAEU,KAAKV,EAAEQ,QAAQW,GAAQA,GAAQA,GAAO,SAAAb,GACpCmB,EAAOnB,IAAK,IAEhBe,EAAU,SAACK,GACPC,QAAQC,KAAKF,GACbG,QAAQC,MAAMC,MAAMC,IAAIN,IACxBF,EAAOE,IAEXJ,EAAW,SAACW,GACRR,EAAOQ,EAAEd,OAAQ,EACZnB,EAAEkC,KAAKlC,EAAEmC,OAAOV,GAAS,SAAAvB,GAAA,OAAOA,KACjCqB,KAGRR,EAAKqB,GAAG,YAAad,GAChBc,GAAG,WAAYf,GACpBN,EAAKsB,MAAMlB,KAEVC,KAAK,WACEL,EAAA,iBACAA,EAAA,eAAuB,YAAaO,GACpCP,EAAA,eAAuB,WAAYM,MAG1CiB,MAAM,SAAAZ,GACCX,EAAA,iBACAA,EAAA,eAAuB,YAAaO,GACpCP,EAAA,eAAuB,WAAYM,UAMpDL,EAAGsB,MAAM,SAAAZ,GACZG,QAAQC,MAAMC,MAAMC,IAAIN,MAahC,QAAAa,iBAAgCxB,EAAYlB,EAAe2C,GACvD,GAAIC,GAAU7C,WAAWI,EAAE0C,IAAI7C,EAAO,SAAA8C,GAClC,MAAOA,GAAG5B,EAAMyB,KAChBA,EAAO1C,KACX,OAAOgB,aAAYC,EAAM0B,GA1H7B,GAAYzC,GAAC4C,QAAM,UAEPb,MAAKa,QAAM,QAUPC,SAAAjD,WAAUA,WAmDViD,QAAA/B,YAAWA,YAuDX+B,QAAAN,gBAAeA","file":"../runSequence.js","sourcesContent":["\"use strict\";\nconst _ = require('lodash');\nconst chalk = require('chalk');\nfunction toSequence(tasks, oper) {\n    let seq = [];\n    tasks = _.filter(tasks, it => it);\n    let len = tasks.length;\n    tasks = _.orderBy(tasks, t => {\n        if (t) {\n            if (_.isString(t)) {\n                return len;\n            }\n            else if (_.isArray(t)) {\n                return len;\n            }\n            else {\n                return t.order;\n            }\n        }\n        return len;\n    });\n    _.each(tasks, t => {\n        if (!t) {\n            return;\n        }\n        if (_.isString(t)) {\n            seq.push(t);\n        }\n        else if (_.isArray(t)) {\n            seq.push(_.flatten(toSequence(t, oper)));\n        }\n        else {\n            if (t.name) {\n                if (t.oper) {\n                    if ((t.oper & oper) > 0) {\n                        seq.push(t.name);\n                    }\n                }\n                else {\n                    seq.push(t.name);\n                }\n            }\n        }\n    });\n    return seq;\n}\nexports.toSequence = toSequence;\nfunction runSequence(gulp, tasks) {\n    let ps = Promise.resolve();\n    if (tasks && tasks.length > 0) {\n        _.each(tasks, task => {\n            ps = ps.then(() => {\n                let taskErr = null, taskStop = null;\n                return new Promise((reslove, reject) => {\n                    let tskmap = {};\n                    _.each(_.isArray(task) ? task : [task], t => {\n                        tskmap[t] = false;\n                    });\n                    taskErr = (err) => {\n                        process.exit(err);\n                        console.error(chalk.red(err));\n                        reject(err);\n                    };\n                    taskStop = (e) => {\n                        tskmap[e.task] = true;\n                        if (!_.some(_.values(tskmap), it => !it)) {\n                            reslove();\n                        }\n                    };\n                    gulp.on('task_stop', taskStop)\n                        .on('task_err', taskErr);\n                    gulp.start(task);\n                })\n                    .then(() => {\n                    if (gulp['removeListener']) {\n                        gulp['removeListener']('task_stop', taskStop);\n                        gulp['removeListener']('task_err', taskErr);\n                    }\n                })\n                    .catch(err => {\n                    if (gulp['removeListener']) {\n                        gulp['removeListener']('task_stop', taskStop);\n                        gulp['removeListener']('task_err', taskErr);\n                    }\n                });\n            });\n        });\n    }\n    return ps.catch(err => {\n        console.error(chalk.red(err));\n    });\n}\nexports.runSequence = runSequence;\nfunction runTaskSequence(gulp, tasks, config) {\n    let taskseq = toSequence(_.map(tasks, tk => {\n        return tk(gulp, config);\n    }), config.oper);\n    return runSequence(gulp, taskseq);\n}\nexports.runTaskSequence = runTaskSequence;\n","import * as _ from 'lodash';\r\nimport { Gulp } from 'gulp';\r\nimport * as chalk from 'chalk';\r\nimport { Src, Operation, ITaskResult, TaskSequence, ITaskConfig, Task } from './TaskConfig';\r\n/**\r\n * convert setup task result to run sequence src.\r\n * \r\n * @export\r\n * @param {TaskSequence} tasks\r\n * @param {Operation} oper\r\n * @returns {Src[]}\r\n */\r\nexport function toSequence(tasks: TaskSequence, oper: Operation): Src[] {\r\n    let seq: Src[] = [];\r\n    tasks = _.filter(tasks, it => it);\r\n    let len = tasks.length;\r\n    tasks = _.orderBy(tasks, t => {\r\n        if (t) {\r\n            if (_.isString(t)) {\r\n                return len;\r\n            } else if (_.isArray(t)) {\r\n                return len;\r\n            } else {\r\n                return (<ITaskResult>t).order\r\n            }\r\n        }\r\n        return len;\r\n    });\r\n\r\n\r\n    _.each(tasks, t => {\r\n        if (!t) {\r\n            return;\r\n        }\r\n        if (_.isString(t)) {\r\n            seq.push(t);\r\n        } else if (_.isArray(t)) {\r\n            seq.push(_.flatten(toSequence(t, oper)));\r\n        } else {\r\n            if (t.name) {\r\n                if (t.oper) {\r\n                    if ((t.oper & oper) > 0) {\r\n                        seq.push(t.name);\r\n                    }\r\n                } else {\r\n                    seq.push(t.name);\r\n                }\r\n            }\r\n        }\r\n    });\r\n    return seq;\r\n}\r\n\r\n/**\r\n * run task sequence.\r\n * \r\n * @protected\r\n * @param {Gulp} gulp\r\n * @param {Src[]} tasks\r\n * @returns {Promise<any>}\r\n * \r\n * @memberOf Development\r\n */\r\nexport function runSequence(gulp: Gulp, tasks: Src[]): Promise<any> {\r\n    let ps = Promise.resolve();\r\n    if (tasks && tasks.length > 0) {\r\n        _.each(tasks, task => {\r\n            ps = ps.then(() => {\r\n                let taskErr = null, taskStop = null;\r\n                return new Promise((reslove, reject) => {\r\n                    let tskmap: any = {};\r\n                    _.each(_.isArray(task) ? task : [task], t => {\r\n                        tskmap[t] = false;\r\n                    });\r\n                    taskErr = (err) => {\r\n                        process.exit(err);\r\n                        console.error(chalk.red(err));\r\n                        reject(err);\r\n                    };\r\n                    taskStop = (e: any) => {\r\n                        tskmap[e.task] = true;\r\n                        if (!_.some(_.values(tskmap), it => !it)) {\r\n                            reslove();\r\n                        }\r\n                    }\r\n                    gulp.on('task_stop', taskStop)\r\n                        .on('task_err', taskErr);\r\n                    gulp.start(task);\r\n                })\r\n                    .then(() => {\r\n                        if (gulp['removeListener']) {\r\n                            gulp['removeListener']('task_stop', taskStop);\r\n                            gulp['removeListener']('task_err', taskErr);\r\n                        }\r\n                    })\r\n                    .catch(err => {\r\n                        if (gulp['removeListener']) {\r\n                            gulp['removeListener']('task_stop', taskStop);\r\n                            gulp['removeListener']('task_err', taskErr);\r\n                        }\r\n                    });\r\n            });\r\n        });\r\n    }\r\n    return ps.catch(err => {\r\n        console.error(chalk.red(err));\r\n    });\r\n}\r\n\r\n/**\r\n * run task sequence\r\n * \r\n * @export\r\n * @param {Gulp} gulp\r\n * @param {Task[]} tasks\r\n * @param {TaskConfig} config\r\n * @returns {Promise<any>}\r\n */\r\nexport function runTaskSequence(gulp: Gulp, tasks: Task[], config: ITaskConfig): Promise<any> {\r\n    let taskseq = toSequence(_.map(tasks, tk => {\r\n        return tk(gulp, config);\r\n    }), config.oper);\r\n    return runSequence(gulp, taskseq);\r\n}\r\n"]}