{"version":3,"sources":["utils.ts"],"names":["sortOrder","sequence","orderBy","ctx","forceSequence","parall","_","filter","t","rseq","isArray","order","isFunction","length","orderVal","isNumber","value","runWay","TaskConfig_1","RunWay","parallel","push","each","values","pals","first","splice","indexOf","contains","arr1","arr2","some","arr2Item","convertOper","decor","def","Operation","default","oper","convertMatchOper","match","matchOper","to","test","release","build","e2e","deploy","someOper","oper1","oper2","matchCompare","tinfo","matchTaskInfo","matchTaskGroup","decorOper","eq","watch","serve","group","isString","absolutePath","root","pathstr","path","isAbsolute","join","absoluteSrc","src","prefixSrc","map","p","strSrc","prefix","substring","require","exports"],"mappings":"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","file":"../utils.js","sourcesContent":["import * as _ from 'lodash';\r\nimport { IMap, RunWay, Operation, Order, ITaskDecorator, ITaskInfo, Src, ITaskContext } from './TaskConfig';\r\nimport * as path from 'path';\r\n\r\n\r\n/**\r\n * sorting via order.\r\n *\r\n * @export\r\n * @template T\r\n * @param {T[]} sequence\r\n * @param {(item: T) => Order} orderBy\r\n * @param {ITaskContext} ctx\r\n * @param {boolean} [forceSequence=false]\r\n * @returns {(Array<T | T[]>)}\r\n */\r\nexport function sortOrder<T>(sequence: T[], orderBy: (item: T) => Order, ctx: ITaskContext, forceSequence = false): Array<T | T[]> {\r\n    let parall: IMap<T[]> = {};\r\n    sequence = _.filter(sequence, t => !!t);\r\n    let rseq: Array<T | T[]> = _.orderBy(sequence, (t: T) => {\r\n        if (_.isArray(t)) {\r\n            return 0.5;\r\n        } else {\r\n            let order = orderBy(t);\r\n            if (_.isFunction(order)) {\r\n                order = order(sequence.length, ctx);\r\n            }\r\n\r\n            let orderVal: number;\r\n            if (_.isNumber(order)) {\r\n                orderVal = order;\r\n            } else if (order) {\r\n                order.value = _.isNumber(order.value) ? order.value : 0.5;\r\n                if (!forceSequence && order.runWay === RunWay.parallel) {\r\n                    parall[order.value] = parall[order.value] || [];\r\n                    parall[order.value].push(t);\r\n                }\r\n                orderVal = order.value;\r\n            } else {\r\n                orderVal = 0.5;\r\n            }\r\n\r\n            if (orderVal > 1) {\r\n                return (orderVal % sequence.length) / sequence.length;\r\n            } else if (orderVal < 0) {\r\n                orderVal = 0;\r\n            }\r\n\r\n            return orderVal;\r\n        }\r\n    });\r\n    if (!forceSequence) {\r\n        _.each(_.values(parall), pals => {\r\n            let first = _.first(pals);\r\n            rseq.splice(rseq.indexOf(first), pals.length, pals);\r\n        });\r\n    }\r\n\r\n    return rseq;\r\n}\r\n\r\n\r\nfunction contains(arr1: string[], arr2: string[]) {\r\n    return arr2.some(arr2Item => arr1.indexOf(arr2Item) >= 0);\r\n}\r\n\r\n\r\n/**\r\n * convert old version Operation to new version Operation\r\n *\r\n * @export\r\n * @param {ITaskDecorator} decor\r\n * @param {any} [def=Operation.default]\r\n * @returns\r\n */\r\nexport function convertOper(decor: ITaskDecorator, def = Operation.default) {\r\n    decor = decor || {};\r\n    // // todo  compatibility\r\n    // if (decor['watch']) {\r\n    //     decor.oper = (decor.oper || def) | Operation.watch;\r\n    // }\r\n    // if (decor['e2e']) {\r\n    //     decor.oper = (decor.oper || def) | Operation.e2e;\r\n    // }\r\n    // if (decor['test']) {\r\n    //     decor.oper = (decor.oper || def) | Operation.test;\r\n    // }\r\n    // // ----\r\n\r\n    decor.oper = decor.oper || def;\r\n    return decor;\r\n}\r\n\r\nfunction convertMatchOper(ctx: ITaskContext, match: ITaskDecorator) {\r\n    let matchOper = ctx.to(match.oper);\r\n    if ((matchOper & Operation.test) && !(matchOper & Operation.release)) {\r\n        matchOper = matchOper | Operation.build;\r\n    }\r\n    if ((matchOper & Operation.e2e) && !(matchOper & Operation.release)) {\r\n        matchOper = matchOper | Operation.build;\r\n    }\r\n    if (matchOper & Operation.deploy) {\r\n        matchOper = matchOper | Operation.test | Operation.e2e;\r\n    }\r\n    if (matchOper & Operation.release) {\r\n        matchOper = matchOper | Operation.test;\r\n    }\r\n    match.oper = matchOper;\r\n    return match;\r\n}\r\n\r\n\r\n/**\r\n * has some oper samed.\r\n *\r\n * @export\r\n * @param {Operation} oper1\r\n * @param {Operation} oper2\r\n * @returns\r\n */\r\nexport function someOper(oper1: Operation, oper2: Operation) {\r\n    return (oper1 & oper2) > 0;\r\n}\r\n\r\n\r\n/**\r\n * match\r\n *\r\n * @export\r\n * @param {ITaskContext} ctx\r\n * @param {ITaskDecorator} tinfo\r\n * @param {ITaskDecorator} match\r\n * @returns\r\n */\r\nexport function matchCompare(ctx: ITaskContext, tinfo: ITaskDecorator, match: ITaskDecorator) {\r\n\r\n    if (!matchTaskInfo(ctx, tinfo, match)) {\r\n        return false;\r\n    }\r\n\r\n    if (!matchTaskGroup(tinfo, match)) {\r\n        return false;\r\n    }\r\n    return true;\r\n\r\n}\r\n\r\n/**\r\n * match task via task info.\r\n *\r\n * @param {ITaskContext} ctx\r\n * @param {ITaskDecorator} decor\r\n * @param {ITaskDecorator} match\r\n * @returns\r\n */\r\nfunction matchTaskInfo(ctx: ITaskContext, decor: ITaskDecorator, match: ITaskDecorator) {\r\n\r\n    match = convertOper(match, Operation.build);\r\n    decor = convertOper(decor);\r\n\r\n    if (match.match) {\r\n        return match.match(decor);\r\n    } else if (decor.match) {\r\n        return decor.match(match);\r\n    } else {\r\n        match = convertMatchOper(ctx, match);\r\n    }\r\n\r\n    let decorOper = ctx.to(decor.oper);\r\n    let matchOper = ctx.to(match.oper);\r\n    let eq = decorOper & matchOper;\r\n    // console.log('eq------->:', eq);\r\n    if (eq <= 0) {\r\n        return false;\r\n    }\r\n\r\n    if (decorOper & Operation.watch) {\r\n        if ((matchOper & Operation.watch) <= 0) {\r\n            return false;\r\n        } else {\r\n            if (eq <= Operation.watch) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (decorOper & Operation.serve) {\r\n        if (!(matchOper & Operation.serve)) {\r\n            return false;\r\n        } else {\r\n            if (eq <= Operation.serve) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (decorOper & Operation.test) {\r\n        if (!(matchOper & Operation.test)) {\r\n            return false;\r\n        } else {\r\n            if (eq <= Operation.test) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (decorOper & Operation.e2e) {\r\n        if (!(matchOper & Operation.e2e)) {\r\n            return false;\r\n        } else {\r\n            if (eq <= Operation.e2e) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nfunction matchTaskGroup(tinfo: ITaskInfo, match: ITaskInfo): boolean {\r\n    if (tinfo.group && match && match.group) {\r\n        if (_.isString(match.group)) {\r\n            if (_.isString(tinfo.group) && tinfo.group !== match.group) {\r\n                return false;\r\n            } else if (_.isArray(tinfo.group) && tinfo.group.indexOf(match.group) < 0) {\r\n                return false;\r\n            }\r\n        } else if (_.isArray(match.group)) {\r\n            if (_.isString(tinfo.group) && match.group.indexOf(tinfo.group) < 0) {\r\n                return false;\r\n            } else if (_.isArray(tinfo.group) && !contains(tinfo.group, match.group)) {\r\n                return false;\r\n            }\r\n        }\r\n    } else if (tinfo.group) {\r\n        return false;\r\n    } else if (match && match.group) {\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n * convert path to absolute path.\r\n *\r\n * @export\r\n * @param {string} root\r\n * @param {string} pathstr\r\n * @returns {string}\r\n */\r\nexport function absolutePath(root: string, pathstr: string): string {\r\n    if (!root || path.isAbsolute(pathstr)) {\r\n        return pathstr;\r\n    }\r\n    return path.join(root, pathstr);\r\n}\r\n\r\n/**\r\n * convert src to absolute path src.\r\n *\r\n * @export\r\n * @param {string} root\r\n * @param {Src} src\r\n * @returns {Src}\r\n */\r\nexport function absoluteSrc(root: string, src: Src): Src {\r\n    if (_.isString(src)) {\r\n        return prefixSrc(root, src);\r\n    } else {\r\n        return _.map(src, p => prefixSrc(root, p));\r\n    }\r\n}\r\n\r\nfunction prefixSrc(root: string, strSrc: string): string {\r\n    let prefix = '';\r\n    if (/^!/.test(strSrc)) {\r\n        prefix = '!';\r\n        strSrc = strSrc.substring(1, strSrc.length);\r\n    }\r\n    return prefix + absolutePath(root, strSrc);\r\n}\r\n"]}