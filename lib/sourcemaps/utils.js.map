{"version":3,"sources":["utils.js","utils.ts"],"names":["_","require","TaskConfig_1","path","sortOrder","sequence","orderBy","ctx","forceSequence","parall","rseq","filter","t","isArray","order","isFunction","length","isNumber","orderVal","runWay","RunWay","parallel","value","push","each","values","first","pals","splice","indexOf","exports","contains","arr1","arr2","some","arr2Item","convertOper","decor","def","Operation","default","oper","convertMatchOper","match","test","release","build","e2e","deploy","someOper","oper1","oper2","matchCompare","tinfo","matchTaskInfo","matchTaskGroup","eq","watch","serve","group","isString","absolutePath","root","pathstr","isAbsolute","join","absoluteSrc","src","prefixSrc","map","p","strSrc","prefix","substring"],"mappings":"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","file":"../utils.js","sourcesContent":["\"use strict\";\nconst _ = require('lodash');\nconst TaskConfig_1 = require('./TaskConfig');\nconst path = require('path');\n/**\n * sorting via order.\n *\n * @export\n * @template T\n * @param {T[]} sequence\n * @param {(item: T) => Order} orderBy\n * @param {ITaskContext} ctx\n * @param {boolean} [forceSequence=false]\n * @returns {(Array<T | T[]>)}\n */\nfunction sortOrder(sequence, orderBy, ctx, forceSequence = false) {\n    let parall = {};\n    let rseq = _.orderBy(_.filter(sequence, t => t), (t) => {\n        if (_.isArray(t)) {\n            return 0.5;\n        }\n        else {\n            let order = orderBy(t);\n            if (_.isFunction(order)) {\n                order = order(sequence.length, ctx);\n            }\n            else if (!_.isNumber(order) && !order) {\n                order = 0.5;\n            }\n            let orderVal;\n            if (_.isNumber(order)) {\n                orderVal = order;\n            }\n            else {\n                if (!forceSequence && order.runWay === TaskConfig_1.RunWay.parallel) {\n                    parall[order.value] = parall[order.value] || [];\n                    parall[order.value].push(t);\n                }\n                orderVal = order.value;\n            }\n            if (orderVal > 1) {\n                return (orderVal % sequence.length) / sequence.length;\n            }\n            else if (orderVal < 0) {\n                orderVal = 0;\n            }\n            return orderVal;\n        }\n    });\n    if (!forceSequence) {\n        _.each(_.values(parall), pals => {\n            let first = _.first(pals);\n            rseq.splice(rseq.indexOf(first), pals.length, pals);\n        });\n    }\n    return rseq;\n}\nexports.sortOrder = sortOrder;\nfunction contains(arr1, arr2) {\n    return arr2.some(arr2Item => arr1.indexOf(arr2Item) >= 0);\n}\n/**\n * convert old version Operation to new version Operation\n *\n * @export\n * @param {ITaskDecorator} decor\n * @param {any} [def=Operation.default]\n * @returns\n */\nfunction convertOper(decor, def = TaskConfig_1.Operation.default) {\n    decor = decor || {};\n    // // todo  compatibility\n    // if (decor['watch']) {\n    //     decor.oper = (decor.oper || def) | Operation.watch;\n    // }\n    // if (decor['e2e']) {\n    //     decor.oper = (decor.oper || def) | Operation.e2e;\n    // }\n    // if (decor['test']) {\n    //     decor.oper = (decor.oper || def) | Operation.test;\n    // }\n    // // ----\n    decor.oper = decor.oper || def;\n    return decor;\n}\nexports.convertOper = convertOper;\nfunction convertMatchOper(match) {\n    if ((match.oper & TaskConfig_1.Operation.test) && !(match.oper & TaskConfig_1.Operation.release)) {\n        match.oper = match.oper | TaskConfig_1.Operation.build;\n    }\n    if ((match.oper & TaskConfig_1.Operation.e2e) && !(match.oper & TaskConfig_1.Operation.release)) {\n        match.oper = match.oper | TaskConfig_1.Operation.build;\n    }\n    if (match.oper & TaskConfig_1.Operation.deploy) {\n        match.oper = match.oper | TaskConfig_1.Operation.test | TaskConfig_1.Operation.e2e;\n    }\n    if (match.oper & TaskConfig_1.Operation.release) {\n        match.oper = match.oper | TaskConfig_1.Operation.test;\n    }\n    return match;\n}\n/**\n * has some oper samed.\n *\n * @export\n * @param {Operation} oper1\n * @param {Operation} oper2\n * @returns\n */\nfunction someOper(oper1, oper2) {\n    return (oper1 & oper2) > 0;\n}\nexports.someOper = someOper;\n/**\n * match\n *\n * @export\n * @param {ITaskDecorator} tinfo\n * @param {ITaskDecorator} match\n * @param {ITaskContext} [ctx]\n * @returns\n */\nfunction matchCompare(tinfo, match, ctx) {\n    if (ctx) {\n        return ctx.matchCompare(tinfo, match);\n    }\n    else {\n        if (!matchTaskInfo(tinfo, match)) {\n            return false;\n        }\n        if (!matchTaskGroup(tinfo, match)) {\n            return false;\n        }\n        return true;\n    }\n}\nexports.matchCompare = matchCompare;\n/**\n * match task via task info.\n *\n * @export\n * @param {ITaskDecorator} decor\n * @param {ITaskDecorator} match\n * @returns\n */\nfunction matchTaskInfo(decor, match) {\n    match = convertOper(match, TaskConfig_1.Operation.build);\n    decor = convertOper(decor);\n    if (match.match) {\n        return match.match(decor);\n    }\n    else if (decor.match) {\n        return decor.match(match);\n    }\n    else {\n        match = convertMatchOper(match);\n    }\n    let eq = decor.oper & match.oper;\n    // console.log('eq------->:', eq);\n    if (eq <= 0) {\n        return false;\n    }\n    if (decor.oper & TaskConfig_1.Operation.watch) {\n        if ((match.oper & TaskConfig_1.Operation.watch) <= 0) {\n            return false;\n        }\n        else {\n            if (eq <= TaskConfig_1.Operation.watch) {\n                return false;\n            }\n        }\n    }\n    if (decor.oper & TaskConfig_1.Operation.serve) {\n        if (!(match.oper & TaskConfig_1.Operation.serve)) {\n            return false;\n        }\n        else {\n            if (eq <= TaskConfig_1.Operation.serve) {\n                return false;\n            }\n        }\n    }\n    if (decor.oper & TaskConfig_1.Operation.test) {\n        if (!(match.oper & TaskConfig_1.Operation.test)) {\n            return false;\n        }\n        else {\n            if (eq <= TaskConfig_1.Operation.test) {\n                return false;\n            }\n        }\n    }\n    if (decor.oper & TaskConfig_1.Operation.e2e) {\n        if (!(match.oper & TaskConfig_1.Operation.e2e)) {\n            return false;\n        }\n        else {\n            if (eq <= TaskConfig_1.Operation.e2e) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nfunction matchTaskGroup(tinfo, match) {\n    if (tinfo.group && match && match.group) {\n        if (_.isString(match.group)) {\n            if (_.isString(tinfo.group) && tinfo.group !== match.group) {\n                return false;\n            }\n            else if (_.isArray(tinfo.group) && tinfo.group.indexOf(match.group) < 0) {\n                return false;\n            }\n        }\n        else if (_.isArray(match.group)) {\n            if (_.isString(tinfo.group) && match.group.indexOf(tinfo.group) < 0) {\n                return false;\n            }\n            else if (_.isArray(tinfo.group) && !contains(tinfo.group, match.group)) {\n                return false;\n            }\n        }\n    }\n    else if (tinfo.group) {\n        return false;\n    }\n    else if (match && match.group) {\n        return false;\n    }\n    return true;\n}\n/**\n * convert path to absolute path.\n *\n * @export\n * @param {string} root\n * @param {string} pathstr\n * @returns {string}\n */\nfunction absolutePath(root, pathstr) {\n    if (!root || path.isAbsolute(pathstr)) {\n        return pathstr;\n    }\n    return path.join(root, pathstr);\n}\nexports.absolutePath = absolutePath;\n/**\n * convert src to absolute path src.\n *\n * @export\n * @param {string} root\n * @param {Src} src\n * @returns {Src}\n */\nfunction absoluteSrc(root, src) {\n    if (_.isString(src)) {\n        return prefixSrc(root, src);\n    }\n    else {\n        return _.map(src, p => prefixSrc(root, p));\n    }\n}\nexports.absoluteSrc = absoluteSrc;\nfunction prefixSrc(root, strSrc) {\n    let prefix = '';\n    if (/^!/.test(strSrc)) {\n        prefix = '!';\n        strSrc = strSrc.substring(1, strSrc.length);\n    }\n    return prefix + absolutePath(root, strSrc);\n}\n","import * as _ from 'lodash';\r\nimport { IMap, RunWay, Operation, Order, ITaskDecorator, ITaskInfo, Src, ITaskContext } from './TaskConfig';\r\nimport * as path from 'path';\r\n\r\n\r\n/**\r\n * sorting via order.\r\n * \r\n * @export\r\n * @template T\r\n * @param {T[]} sequence\r\n * @param {(item: T) => Order} orderBy\r\n * @param {ITaskContext} ctx\r\n * @param {boolean} [forceSequence=false]\r\n * @returns {(Array<T | T[]>)}\r\n */\r\nexport function sortOrder<T>(sequence: T[], orderBy: (item: T) => Order, ctx: ITaskContext, forceSequence = false): Array<T | T[]> {\r\n    let parall: IMap<T[]> = {};\r\n    let rseq: Array<T | T[]> = _.orderBy(_.filter(sequence, t => t), (t: T) => {\r\n        if (_.isArray(t)) {\r\n            return 0.5;\r\n        } else {\r\n            let order = orderBy(t);\r\n            if (_.isFunction(order)) {\r\n                order = order(sequence.length, ctx);\r\n            } else if (!_.isNumber(order) && !order) {\r\n                order = 0.5;\r\n            }\r\n\r\n            let orderVal: number;\r\n            if (_.isNumber(order)) {\r\n                orderVal = order;\r\n            } else {\r\n                if (!forceSequence && order.runWay === RunWay.parallel) {\r\n                    parall[order.value] = parall[order.value] || [];\r\n                    parall[order.value].push(t);\r\n                }\r\n                orderVal = order.value;\r\n            }\r\n\r\n            if (orderVal > 1) {\r\n                return (orderVal % sequence.length) / sequence.length;\r\n            } else if (orderVal < 0) {\r\n                orderVal = 0;\r\n            }\r\n\r\n            return orderVal;\r\n        }\r\n    });\r\n    if (!forceSequence) {\r\n        _.each(_.values(parall), pals => {\r\n            let first = _.first(pals);\r\n            rseq.splice(rseq.indexOf(first), pals.length, pals);\r\n        });\r\n    }\r\n\r\n    return rseq;\r\n}\r\n\r\n\r\nfunction contains(arr1: string[], arr2: string[]) {\r\n    return arr2.some(arr2Item => arr1.indexOf(arr2Item) >= 0);\r\n}\r\n\r\n\r\n/**\r\n * convert old version Operation to new version Operation\r\n * \r\n * @export\r\n * @param {ITaskDecorator} decor\r\n * @param {any} [def=Operation.default]\r\n * @returns\r\n */\r\nexport function convertOper(decor: ITaskDecorator, def = Operation.default) {\r\n    decor = decor || {};\r\n    // // todo  compatibility\r\n    // if (decor['watch']) {\r\n    //     decor.oper = (decor.oper || def) | Operation.watch;\r\n    // }\r\n    // if (decor['e2e']) {\r\n    //     decor.oper = (decor.oper || def) | Operation.e2e;\r\n    // }\r\n    // if (decor['test']) {\r\n    //     decor.oper = (decor.oper || def) | Operation.test;\r\n    // }\r\n    // // ----\r\n\r\n    decor.oper = decor.oper || def;\r\n    return decor;\r\n}\r\n\r\nfunction convertMatchOper(match: ITaskDecorator) {\r\n    if ((match.oper & Operation.test) && !(match.oper & Operation.release)) {\r\n        match.oper = match.oper | Operation.build;\r\n    }\r\n    if ((match.oper & Operation.e2e) && !(match.oper & Operation.release)) {\r\n        match.oper = match.oper | Operation.build;\r\n    }\r\n    if (match.oper & Operation.deploy) {\r\n        match.oper = match.oper | Operation.test | Operation.e2e;\r\n    }\r\n    if (match.oper & Operation.release) {\r\n        match.oper = match.oper | Operation.test;\r\n    }\r\n\r\n    return match;\r\n}\r\n\r\n\r\n/**\r\n * has some oper samed.\r\n * \r\n * @export\r\n * @param {Operation} oper1\r\n * @param {Operation} oper2\r\n * @returns\r\n */\r\nexport function someOper(oper1: Operation, oper2: Operation) {\r\n    return (oper1 & oper2) > 0;\r\n}\r\n\r\n\r\n/**\r\n * match\r\n * \r\n * @export\r\n * @param {ITaskDecorator} tinfo\r\n * @param {ITaskDecorator} match\r\n * @param {ITaskContext} [ctx]\r\n * @returns\r\n */\r\nexport function matchCompare(tinfo: ITaskDecorator, match: ITaskDecorator, ctx?: ITaskContext) {\r\n    if (ctx) {\r\n        return ctx.matchCompare(tinfo, match);\r\n    } else {\r\n        if (!matchTaskInfo(tinfo, match)) {\r\n            return false;\r\n        }\r\n\r\n        if (!matchTaskGroup(tinfo, match)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * match task via task info.\r\n * \r\n * @export\r\n * @param {ITaskDecorator} decor\r\n * @param {ITaskDecorator} match\r\n * @returns\r\n */\r\nfunction matchTaskInfo(decor: ITaskDecorator, match: ITaskDecorator) {\r\n\r\n    match = convertOper(match, Operation.build);\r\n    decor = convertOper(decor);\r\n\r\n    if (match.match) {\r\n        return match.match(decor);\r\n    } else if (decor.match) {\r\n        return decor.match(match);\r\n    } else {\r\n        match = convertMatchOper(match);\r\n    }\r\n\r\n    let eq = decor.oper & match.oper;\r\n    // console.log('eq------->:', eq);\r\n    if (eq <= 0) {\r\n        return false;\r\n    }\r\n\r\n    if (decor.oper & Operation.watch) {\r\n        if ((match.oper & Operation.watch) <= 0) {\r\n            return false;\r\n        } else {\r\n            if (eq <= Operation.watch) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (decor.oper & Operation.serve) {\r\n        if (!(match.oper & Operation.serve)) {\r\n            return false;\r\n        } else {\r\n            if (eq <= Operation.serve) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (decor.oper & Operation.test) {\r\n        if (!(match.oper & Operation.test)) {\r\n            return false;\r\n        } else {\r\n            if (eq <= Operation.test) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (decor.oper & Operation.e2e) {\r\n        if (!(match.oper & Operation.e2e)) {\r\n            return false;\r\n        } else {\r\n            if (eq <= Operation.e2e) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nfunction matchTaskGroup(tinfo: ITaskInfo, match: ITaskInfo): boolean {\r\n    if (tinfo.group && match && match.group) {\r\n        if (_.isString(match.group)) {\r\n            if (_.isString(tinfo.group) && tinfo.group !== match.group) {\r\n                return false;\r\n            } else if (_.isArray(tinfo.group) && tinfo.group.indexOf(match.group) < 0) {\r\n                return false;\r\n            }\r\n        } else if (_.isArray(match.group)) {\r\n            if (_.isString(tinfo.group) && match.group.indexOf(tinfo.group) < 0) {\r\n                return false;\r\n            } else if (_.isArray(tinfo.group) && !contains(tinfo.group, match.group)) {\r\n                return false;\r\n            }\r\n        }\r\n    } else if (tinfo.group) {\r\n        return false;\r\n    } else if (match && match.group) {\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n * convert path to absolute path.\r\n * \r\n * @export\r\n * @param {string} root\r\n * @param {string} pathstr\r\n * @returns {string}\r\n */\r\nexport function absolutePath(root: string, pathstr: string): string {\r\n    if (!root || path.isAbsolute(pathstr)) {\r\n        return pathstr;\r\n    }\r\n    return path.join(root, pathstr);\r\n}\r\n\r\n/**\r\n * convert src to absolute path src.\r\n * \r\n * @export\r\n * @param {string} root\r\n * @param {Src} src\r\n * @returns {Src}\r\n */\r\nexport function absoluteSrc(root: string, src: Src): Src {\r\n    if (_.isString(src)) {\r\n        return prefixSrc(root, src);\r\n    } else {\r\n        return _.map(src, p => prefixSrc(root, p));\r\n    }\r\n}\r\n\r\nfunction prefixSrc(root: string, strSrc: string): string {\r\n    let prefix = '';\r\n    if (/^!/.test(strSrc)) {\r\n        prefix = '!';\r\n        strSrc = strSrc.substring(1, strSrc.length);\r\n    }\r\n    return prefix + absolutePath(root, strSrc);\r\n}\r\n"]}