{"version":3,"sources":["utils.js","utils.ts"],"names":["files","directory","express","res","fn","_","each","fs_1","readdirSync","fname","filePn","fst","lstatSync","isDirectory","concat","push","taskSourceVal","src","oper","isFunction","taskStringVal","name","contains","arr1","arr2","some","arr2Item","indexOf","matchTaskGroup","tk","match","group","isString","isArray","require","exports"],"mappings":"AAAA,YCWA,SAAAA,OAAsBC,EAAmBC,GACrC,GAAIC,KAaJ,OAZAD,GAAUA,GAAY,SAACE,GAAD,OAAQ,GAC9BC,EAAEC,KAAKC,KAAAC,YAAYP,GAAY,SAAAQ,GAC3B,GAAIC,GAAST,EAAY,IAAMQ,EAC3BE,EAAMJ,KAAAK,UAAUF,EACfC,GAAIE,cAKLV,EAAMA,EAAIW,OAAOd,MAAMU,EAAQR,IAJ3BA,EAAQQ,IACRP,EAAIY,KAAKL,KAMdP,EAGX,QAAAa,eAA8BC,EAAiBC,GAC3C,MAAOb,GAAEc,WAAWF,GAAOA,EAAIC,GAASD,GAAO,GAGnD,QAAAG,eAA8BC,EAAkBH,GAC5C,MAAOb,GAAEc,WAAWE,GAAQA,EAAKH,GAASG,GAAQ,GAItD,QAAAC,UAAkBC,EAAgBC,GAC9B,MAAOA,GAAKC,KAAK,SAAAC,GAAA,MAAYH,GAAKI,QAAQD,IAAa,IAG3D,QAAAE,gBAA+BC,EAAeC,GAC1C,GAAID,EAAGE,OAASD,GAASA,EAAMC,OAC3B,GAAI1B,EAAE2B,SAASF,EAAMC,OAAQ,CACzB,GAAI1B,EAAE2B,SAASH,EAAGE,QAAUF,EAAGE,QAAUD,EAAMC,MAC3C,OAAO,CACJ,IAAI1B,EAAE4B,QAAQJ,EAAGE,QAAUF,EAAGE,MAAMJ,QAAQG,EAAMC,OAAS,EAC9D,OAAO,MAER,IAAI1B,EAAE4B,QAAQH,EAAMC,OAAQ,CAC/B,GAAI1B,EAAE2B,SAASH,EAAGE,QAAUD,EAAMC,MAAMJ,QAAQE,EAAGE,OAAS,EACxD,OAAO,CACJ,IAAI1B,EAAE4B,QAAQJ,EAAGE,SAAWT,SAASO,EAAGE,MAAOD,EAAMC,OACxD,OAAO,OAGZ,CAAA,GAAIF,EAAGE,MACV,OAAO,CACJ,IAAID,GAASA,EAAMC,MACtB,OAAO,EAGX,OAAO,EA9DX,GAAY1B,GAAC6B,QAAM,UAEnB3B,KAAA2B,QAAuC,KASvBC,SAAAnC,MAAKA,MAiBLmC,QAAAnB,cAAaA,cAIbmB,QAAAf,cAAaA,cASbe,QAAAP,eAAcA","file":"../utils.js","sourcesContent":["\"use strict\";\nconst _ = require('lodash');\nconst fs_1 = require('fs');\n/**\n * filter fileName in directory.\n *\n * @export\n * @param {string} directory\n * @param {((fileName: string) => boolean)} [express]\n * @returns {string[]}\n */\nfunction files(directory, express) {\n    let res = [];\n    express = express || ((fn) => true);\n    _.each(fs_1.readdirSync(directory), fname => {\n        let filePn = directory + '/' + fname;\n        var fst = fs_1.lstatSync(filePn);\n        if (!fst.isDirectory()) {\n            if (express(filePn)) {\n                res.push(filePn);\n            }\n        }\n        else {\n            res = res.concat(files(filePn, express));\n        }\n    });\n    return res;\n}\nexports.files = files;\nfunction taskSourceVal(src, oper) {\n    return _.isFunction(src) ? src(oper) : (src || '');\n}\nexports.taskSourceVal = taskSourceVal;\nfunction taskStringVal(name, oper) {\n    return _.isFunction(name) ? name(oper) : (name || '');\n}\nexports.taskStringVal = taskStringVal;\nfunction contains(arr1, arr2) {\n    return arr2.some(arr2Item => arr1.indexOf(arr2Item) >= 0);\n}\nfunction matchTaskGroup(tk, match) {\n    if (tk.group && match && match.group) {\n        if (_.isString(match.group)) {\n            if (_.isString(tk.group) && tk.group !== match.group) {\n                return false;\n            }\n            else if (_.isArray(tk.group) && tk.group.indexOf(match.group) < 0) {\n                return false;\n            }\n        }\n        else if (_.isArray(match.group)) {\n            if (_.isString(tk.group) && match.group.indexOf(tk.group) < 0) {\n                return false;\n            }\n            else if (_.isArray(tk.group) && !contains(tk.group, match.group)) {\n                return false;\n            }\n        }\n    }\n    else if (tk.group) {\n        return false;\n    }\n    else if (match && match.group) {\n        return false;\n    }\n    return true;\n}\nexports.matchTaskGroup = matchTaskGroup;\n","import * as _ from 'lodash';\r\nimport { TaskSource, TaskString, Operation, ITaskInfo } from './TaskConfig';\r\nimport { readdirSync, lstatSync } from 'fs';\r\n/**\r\n * filter fileName in directory.\r\n * \r\n * @export\r\n * @param {string} directory\r\n * @param {((fileName: string) => boolean)} [express]\r\n * @returns {string[]}\r\n */\r\nexport function files(directory: string, express?: ((fileName: string) => boolean)): string[] {\r\n    let res: string[] = [];\r\n    express = express || ((fn) => true);\r\n    _.each(readdirSync(directory), fname => {\r\n        let filePn = directory + '/' + fname;\r\n        var fst = lstatSync(filePn);\r\n        if (!fst.isDirectory()) {\r\n            if (express(filePn)) {\r\n                res.push(filePn)\r\n            }\r\n        } else {\r\n            res = res.concat(files(filePn, express))\r\n        }\r\n    });\r\n    return res;\r\n}\r\n\r\nexport function taskSourceVal(src: TaskSource, oper?: Operation) {\r\n    return _.isFunction(src) ? src(oper) : (src || '');\r\n}\r\n\r\nexport function taskStringVal(name: TaskString, oper?: Operation) {\r\n    return _.isFunction(name) ? name(oper) : (name || '');\r\n}\r\n\r\n\r\nfunction contains(arr1: string[], arr2: string[]) {\r\n    return arr2.some(arr2Item => arr1.indexOf(arr2Item) >= 0);\r\n}\r\n\r\nexport function matchTaskGroup(tk: ITaskInfo, match: ITaskInfo): boolean {\r\n    if (tk.group && match && match.group) {\r\n        if (_.isString(match.group)) {\r\n            if (_.isString(tk.group) && tk.group !== match.group) {\r\n                return false;\r\n            } else if (_.isArray(tk.group) && tk.group.indexOf(match.group) < 0) {\r\n                return false;\r\n            }\r\n        } else if (_.isArray(match.group)) {\r\n            if (_.isString(tk.group) && match.group.indexOf(tk.group) < 0) {\r\n                return false;\r\n            } else if (_.isArray(tk.group) && !contains(tk.group, match.group)) {\r\n                return false;\r\n            }\r\n        }\r\n    } else if (tk.group) {\r\n        return false;\r\n    } else if (match && match.group) {\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n"]}