{"version":3,"sources":["utils.js","utils.ts"],"names":["files","express","filter","mapping","Promise","resolve","globby","then","_","map","sortOrder","sequence","orderBy","ctx","forceSequence","arguments","length","undefined","parall","rseq","t","isArray","order","isFunction","isNumber","orderVal","runWay","TaskConfig_1","RunWay","parallel","value","push","each","values","pals","first","splice","indexOf","taskSourceVal","src","taskStringVal","name","contains","arr1","arr2","some","arr2Item","convertOper","decor","def","Operation","default","oper","convertMatchOper","match","test","release","build","e2e","deploy","someOper","oper1","oper2","matchTaskInfo","eq","watch","serve","matchTaskGroup","tinfo","group","isString","absolutePath","root","pathstr","path","isAbsolute","join","absoluteSrc","prefixSrc","p","strSrc","prefix","substring","require","exports"],"mappings":"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","file":"../utils.js","sourcesContent":["\"use strict\";\nconst _ = require('lodash');\nconst TaskConfig_1 = require('./TaskConfig');\nconst path = require('path');\nconst globby = require('globby');\n/**\n * filter fileName in directory.\n *\n * @export\n * @param {string} directory\n * @param {((fileName: string) => boolean)} [express]\n * @returns {string[]}\n */\nfunction files(express, filter, mapping) {\n    // let res: string[] = [];\n    // express = express || ((fn) => true);\n    // _.each(readdirSync(directory), fname => {\n    //     let filePn = directory + '/' + fname;\n    //     var fst = lstatSync(filePn);\n    //     if (!fst.isDirectory()) {\n    //         if (express(filePn)) {\n    //             res.push(filePn)\n    //         }\n    //     } else {\n    //         res = res.concat(files(filePn, express))\n    //     }\n    // });\n    // return res;\n    return Promise.resolve(globby(express))\n        .then((files) => {\n        if (filter) {\n            files = _.filter(files, filter);\n        }\n        if (mapping) {\n            files = _.map(files, mapping);\n        }\n        return files;\n    });\n}\nexports.files = files;\n/**\n * sorting via order.\n *\n * @export\n * @template T\n * @param {T[]} sequence\n * @param {(item: T) => Order} orderBy\n * @param {ITaskContext} ctx\n * @param {boolean} [forceSequence=false]\n * @returns {(Array<T | T[]>)}\n */\nfunction sortOrder(sequence, orderBy, ctx, forceSequence = false) {\n    let parall = {};\n    let rseq = _.orderBy(_.filter(sequence, t => t), (t) => {\n        if (_.isArray(t)) {\n            return 0.5;\n        }\n        else {\n            let order = orderBy(t);\n            if (_.isFunction(order)) {\n                order = order(sequence.length, ctx);\n            }\n            else if (!_.isNumber(order) && !order) {\n                order = 0.5;\n            }\n            let orderVal;\n            if (_.isNumber(order)) {\n                orderVal = order;\n            }\n            else {\n                if (!forceSequence && order.runWay === TaskConfig_1.RunWay.parallel) {\n                    parall[order.value] = parall[order.value] || [];\n                    parall[order.value].push(t);\n                }\n                orderVal = order.value;\n            }\n            if (orderVal > 1) {\n                return (orderVal % sequence.length) / sequence.length;\n            }\n            else if (orderVal < 0) {\n                orderVal = 0;\n            }\n            return orderVal;\n        }\n    });\n    if (!forceSequence) {\n        _.each(_.values(parall), pals => {\n            let first = _.first(pals);\n            rseq.splice(rseq.indexOf(first), pals.length, pals);\n        });\n    }\n    return rseq;\n}\nexports.sortOrder = sortOrder;\n/**\n * task src, string or array string.\n *\n * @export\n * @param {TaskSource} src\n * @param {Operation} oper runtime Operation\n * @param {IEnvOption} [env]\n * @returns\n */\nfunction taskSourceVal(src, ctx) {\n    return _.isFunction(src) ? src(ctx) : (src || '');\n}\nexports.taskSourceVal = taskSourceVal;\n/**\n * task string.\n *\n * @export\n * @param {TaskString} name\n * @param {ITaskContext} ctx\n * @returns\n */\nfunction taskStringVal(name, ctx) {\n    return _.isFunction(name) ? name(ctx) : (name || '');\n}\nexports.taskStringVal = taskStringVal;\nfunction contains(arr1, arr2) {\n    return arr2.some(arr2Item => arr1.indexOf(arr2Item) >= 0);\n}\n/**\n * convert old version Operation to new version Operation\n *\n * @export\n * @param {ITaskDecorator} decor\n * @param {any} [def=Operation.default]\n * @returns\n */\nfunction convertOper(decor, def = TaskConfig_1.Operation.default) {\n    decor = decor || {};\n    // // todo  compatibility\n    // if (decor['watch']) {\n    //     decor.oper = (decor.oper || def) | Operation.watch;\n    // }\n    // if (decor['e2e']) {\n    //     decor.oper = (decor.oper || def) | Operation.e2e;\n    // }\n    // if (decor['test']) {\n    //     decor.oper = (decor.oper || def) | Operation.test;\n    // }\n    // // ----\n    decor.oper = decor.oper || def;\n    return decor;\n}\nexports.convertOper = convertOper;\nfunction convertMatchOper(match) {\n    if ((match.oper & TaskConfig_1.Operation.test) && !(match.oper & TaskConfig_1.Operation.release)) {\n        match.oper = match.oper | TaskConfig_1.Operation.build;\n    }\n    if ((match.oper & TaskConfig_1.Operation.e2e) && !(match.oper & TaskConfig_1.Operation.release)) {\n        match.oper = match.oper | TaskConfig_1.Operation.build;\n    }\n    if (match.oper & TaskConfig_1.Operation.deploy) {\n        match.oper = match.oper | TaskConfig_1.Operation.test | TaskConfig_1.Operation.e2e;\n    }\n    if (match.oper & TaskConfig_1.Operation.release) {\n        match.oper = match.oper | TaskConfig_1.Operation.test;\n    }\n    return match;\n}\n/**\n * has some oper samed.\n *\n * @export\n * @param {Operation} oper1\n * @param {Operation} oper2\n * @returns\n */\nfunction someOper(oper1, oper2) {\n    return (oper1 & oper2) > 0;\n}\nexports.someOper = someOper;\n/**\n * match task via task info.\n *\n * @export\n * @param {ITaskDecorator} decor\n * @param {ITaskDecorator} match\n * @returns\n */\nfunction matchTaskInfo(decor, match) {\n    match = convertOper(match, TaskConfig_1.Operation.build);\n    decor = convertOper(decor);\n    if (match.match) {\n        return match.match(decor);\n    }\n    else if (decor.match) {\n        return decor.match(match);\n    }\n    else {\n        match = convertMatchOper(match);\n    }\n    let eq = decor.oper & match.oper;\n    // console.log('eq------->:', eq);\n    if (eq <= 0) {\n        return false;\n    }\n    if (decor.oper & TaskConfig_1.Operation.watch) {\n        if ((match.oper & TaskConfig_1.Operation.watch) <= 0) {\n            return false;\n        }\n        else {\n            if (eq <= TaskConfig_1.Operation.watch) {\n                return false;\n            }\n        }\n    }\n    if (decor.oper & TaskConfig_1.Operation.serve) {\n        if (!(match.oper & TaskConfig_1.Operation.serve)) {\n            return false;\n        }\n        else {\n            if (eq <= TaskConfig_1.Operation.serve) {\n                return false;\n            }\n        }\n    }\n    if (decor.oper & TaskConfig_1.Operation.test) {\n        if (!(match.oper & TaskConfig_1.Operation.test)) {\n            return false;\n        }\n        else {\n            if (eq <= TaskConfig_1.Operation.test) {\n                return false;\n            }\n        }\n    }\n    if (decor.oper & TaskConfig_1.Operation.e2e) {\n        if (!(match.oper & TaskConfig_1.Operation.e2e)) {\n            return false;\n        }\n        else {\n            if (eq <= TaskConfig_1.Operation.e2e) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nexports.matchTaskInfo = matchTaskInfo;\nfunction matchTaskGroup(tinfo, match) {\n    if (tinfo.group && match && match.group) {\n        if (_.isString(match.group)) {\n            if (_.isString(tinfo.group) && tinfo.group !== match.group) {\n                return false;\n            }\n            else if (_.isArray(tinfo.group) && tinfo.group.indexOf(match.group) < 0) {\n                return false;\n            }\n        }\n        else if (_.isArray(match.group)) {\n            if (_.isString(tinfo.group) && match.group.indexOf(tinfo.group) < 0) {\n                return false;\n            }\n            else if (_.isArray(tinfo.group) && !contains(tinfo.group, match.group)) {\n                return false;\n            }\n        }\n    }\n    else if (tinfo.group) {\n        return false;\n    }\n    else if (match && match.group) {\n        return false;\n    }\n    return true;\n}\nexports.matchTaskGroup = matchTaskGroup;\n/**\n * convert path to absolute path.\n *\n * @export\n * @param {string} root\n * @param {string} pathstr\n * @returns {string}\n */\nfunction absolutePath(root, pathstr) {\n    if (!root || path.isAbsolute(pathstr)) {\n        return pathstr;\n    }\n    return path.join(root, pathstr);\n}\nexports.absolutePath = absolutePath;\n/**\n * convert src to absolute path src.\n *\n * @export\n * @param {string} root\n * @param {Src} src\n * @returns {Src}\n */\nfunction absoluteSrc(root, src) {\n    if (_.isString(src)) {\n        return prefixSrc(root, src);\n    }\n    else {\n        return _.map(src, p => prefixSrc(root, p));\n    }\n}\nexports.absoluteSrc = absoluteSrc;\nfunction prefixSrc(root, strSrc) {\n    let prefix = '';\n    if (/^!/.test(strSrc)) {\n        prefix = '!';\n        strSrc = strSrc.substring(1, strSrc.length);\n    }\n    return prefix + absolutePath(root, strSrc);\n}\n","import * as _ from 'lodash';\r\nimport { IMap, RunWay, TaskSource, TaskString, Operation, Order, ITaskDecorator, ITaskInfo, Src, ITaskContext } from './TaskConfig';\r\nimport { readdirSync, lstatSync } from 'fs';\r\nimport * as path from 'path';\r\nconst globby = require('globby');\r\n/**\r\n * filter fileName in directory.\r\n * \r\n * @export\r\n * @param {string} directory\r\n * @param {((fileName: string) => boolean)} [express]\r\n * @returns {string[]}\r\n */\r\nexport function files(express: Src, filter?: (fileName: string) => boolean, mapping?: (filename: string) => string): Promise<string[]> {\r\n    // let res: string[] = [];\r\n    // express = express || ((fn) => true);\r\n    // _.each(readdirSync(directory), fname => {\r\n    //     let filePn = directory + '/' + fname;\r\n    //     var fst = lstatSync(filePn);\r\n    //     if (!fst.isDirectory()) {\r\n    //         if (express(filePn)) {\r\n    //             res.push(filePn)\r\n    //         }\r\n    //     } else {\r\n    //         res = res.concat(files(filePn, express))\r\n    //     }\r\n    // });\r\n    // return res;\r\n    return Promise.resolve(globby(express))\r\n        .then((files: string[]) => {\r\n            if (filter) {\r\n                files = _.filter(files, filter)\r\n            }\r\n            if (mapping) {\r\n                files = _.map(files, mapping);\r\n            }\r\n            return files;\r\n        })\r\n}\r\n\r\n/**\r\n * sorting via order.\r\n * \r\n * @export\r\n * @template T\r\n * @param {T[]} sequence\r\n * @param {(item: T) => Order} orderBy\r\n * @param {ITaskContext} ctx\r\n * @param {boolean} [forceSequence=false]\r\n * @returns {(Array<T | T[]>)}\r\n */\r\nexport function sortOrder<T>(sequence: T[], orderBy: (item: T) => Order, ctx: ITaskContext, forceSequence = false): Array<T | T[]> {\r\n    let parall: IMap<T[]> = {};\r\n    let rseq: Array<T | T[]> = _.orderBy(_.filter(sequence, t => t), (t: T) => {\r\n        if (_.isArray(t)) {\r\n            return 0.5;\r\n        } else {\r\n            let order = orderBy(t);\r\n            if (_.isFunction(order)) {\r\n                order = order(sequence.length, ctx);\r\n            } else if (!_.isNumber(order) && !order) {\r\n                order = 0.5;\r\n            }\r\n\r\n            let orderVal: number;\r\n            if (_.isNumber(order)) {\r\n                orderVal = order;\r\n            } else {\r\n                if (!forceSequence && order.runWay === RunWay.parallel) {\r\n                    parall[order.value] = parall[order.value] || [];\r\n                    parall[order.value].push(t);\r\n                }\r\n                orderVal = order.value;\r\n            }\r\n\r\n            if (orderVal > 1) {\r\n                return (orderVal % sequence.length) / sequence.length;\r\n            } else if (orderVal < 0) {\r\n                orderVal = 0;\r\n            }\r\n\r\n            return orderVal;\r\n        }\r\n    });\r\n    if (!forceSequence) {\r\n        _.each(_.values(parall), pals => {\r\n            let first = _.first(pals);\r\n            rseq.splice(rseq.indexOf(first), pals.length, pals);\r\n        });\r\n    }\r\n\r\n    return rseq;\r\n}\r\n\r\n/**\r\n * task src, string or array string.\r\n * \r\n * @export\r\n * @param {TaskSource} src\r\n * @param {Operation} oper runtime Operation\r\n * @param {IEnvOption} [env]\r\n * @returns\r\n */\r\nexport function taskSourceVal(src: TaskSource, ctx: ITaskContext) {\r\n    return _.isFunction(src) ? src(ctx) : (src || '');\r\n}\r\n\r\n/**\r\n * task string.\r\n * \r\n * @export\r\n * @param {TaskString} name\r\n * @param {ITaskContext} ctx\r\n * @returns\r\n */\r\nexport function taskStringVal(name: TaskString, ctx: ITaskContext) {\r\n    return _.isFunction(name) ? name(ctx) : (name || '');\r\n}\r\n\r\n\r\nfunction contains(arr1: string[], arr2: string[]) {\r\n    return arr2.some(arr2Item => arr1.indexOf(arr2Item) >= 0);\r\n}\r\n\r\n\r\n/**\r\n * convert old version Operation to new version Operation\r\n * \r\n * @export\r\n * @param {ITaskDecorator} decor\r\n * @param {any} [def=Operation.default]\r\n * @returns\r\n */\r\nexport function convertOper(decor: ITaskDecorator, def = Operation.default) {\r\n    decor = decor || {};\r\n    // // todo  compatibility\r\n    // if (decor['watch']) {\r\n    //     decor.oper = (decor.oper || def) | Operation.watch;\r\n    // }\r\n    // if (decor['e2e']) {\r\n    //     decor.oper = (decor.oper || def) | Operation.e2e;\r\n    // }\r\n    // if (decor['test']) {\r\n    //     decor.oper = (decor.oper || def) | Operation.test;\r\n    // }\r\n    // // ----\r\n\r\n    decor.oper = decor.oper || def;\r\n    return decor;\r\n}\r\n\r\nfunction convertMatchOper(match: ITaskDecorator) {\r\n    if ((match.oper & Operation.test) && !(match.oper & Operation.release)) {\r\n        match.oper = match.oper | Operation.build;\r\n    }\r\n    if ((match.oper & Operation.e2e) && !(match.oper & Operation.release)) {\r\n        match.oper = match.oper | Operation.build;\r\n    }\r\n    if (match.oper & Operation.deploy) {\r\n        match.oper = match.oper | Operation.test | Operation.e2e;\r\n    }\r\n    if (match.oper & Operation.release) {\r\n        match.oper = match.oper | Operation.test;\r\n    }\r\n\r\n    return match;\r\n}\r\n\r\n\r\n/**\r\n * has some oper samed.\r\n * \r\n * @export\r\n * @param {Operation} oper1\r\n * @param {Operation} oper2\r\n * @returns\r\n */\r\nexport function someOper(oper1: Operation, oper2: Operation) {\r\n    return (oper1 & oper2) > 0;\r\n}\r\n\r\n/**\r\n * match task via task info.\r\n * \r\n * @export\r\n * @param {ITaskDecorator} decor\r\n * @param {ITaskDecorator} match\r\n * @returns\r\n */\r\nexport function matchTaskInfo(decor: ITaskDecorator, match: ITaskDecorator) {\r\n\r\n    match = convertOper(match, Operation.build);\r\n    decor = convertOper(decor);\r\n\r\n    if (match.match) {\r\n        return match.match(decor);\r\n    } else if (decor.match) {\r\n        return decor.match(match);\r\n    } else {\r\n        match = convertMatchOper(match);\r\n    }\r\n\r\n    let eq = decor.oper & match.oper;\r\n    // console.log('eq------->:', eq);\r\n    if (eq <= 0) {\r\n        return false;\r\n    }\r\n\r\n    if (decor.oper & Operation.watch) {\r\n        if ((match.oper & Operation.watch) <= 0) {\r\n            return false;\r\n        } else {\r\n            if (eq <= Operation.watch) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (decor.oper & Operation.serve) {\r\n        if (!(match.oper & Operation.serve)) {\r\n            return false;\r\n        } else {\r\n            if (eq <= Operation.serve) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (decor.oper & Operation.test) {\r\n        if (!(match.oper & Operation.test)) {\r\n            return false;\r\n        } else {\r\n            if (eq <= Operation.test) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (decor.oper & Operation.e2e) {\r\n        if (!(match.oper & Operation.e2e)) {\r\n            return false;\r\n        } else {\r\n            if (eq <= Operation.e2e) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nexport function matchTaskGroup(tinfo: ITaskInfo, match: ITaskInfo): boolean {\r\n    if (tinfo.group && match && match.group) {\r\n        if (_.isString(match.group)) {\r\n            if (_.isString(tinfo.group) && tinfo.group !== match.group) {\r\n                return false;\r\n            } else if (_.isArray(tinfo.group) && tinfo.group.indexOf(match.group) < 0) {\r\n                return false;\r\n            }\r\n        } else if (_.isArray(match.group)) {\r\n            if (_.isString(tinfo.group) && match.group.indexOf(tinfo.group) < 0) {\r\n                return false;\r\n            } else if (_.isArray(tinfo.group) && !contains(tinfo.group, match.group)) {\r\n                return false;\r\n            }\r\n        }\r\n    } else if (tinfo.group) {\r\n        return false;\r\n    } else if (match && match.group) {\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n * convert path to absolute path.\r\n * \r\n * @export\r\n * @param {string} root\r\n * @param {string} pathstr\r\n * @returns {string}\r\n */\r\nexport function absolutePath(root: string, pathstr: string): string {\r\n    if (!root || path.isAbsolute(pathstr)) {\r\n        return pathstr;\r\n    }\r\n    return path.join(root, pathstr);\r\n}\r\n\r\n/**\r\n * convert src to absolute path src.\r\n * \r\n * @export\r\n * @param {string} root\r\n * @param {Src} src\r\n * @returns {Src}\r\n */\r\nexport function absoluteSrc(root: string, src: Src): Src {\r\n    if (_.isString(src)) {\r\n        return prefixSrc(root, src);\r\n    } else {\r\n        return _.map(src, p => prefixSrc(root, p));\r\n    }\r\n}\r\n\r\nfunction prefixSrc(root: string, strSrc: string): string {\r\n    let prefix = '';\r\n    if (/^!/.test(strSrc)) {\r\n        prefix = '!';\r\n        strSrc = strSrc.substring(1, strSrc.length);\r\n    }\r\n    return prefix + absolutePath(root, strSrc);\r\n}\r\n"]}