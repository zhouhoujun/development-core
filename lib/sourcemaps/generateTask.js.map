{"version":3,"sources":["generateTask.ts"],"names":["generateTask","tasks","match","ctx","taskseq","_","each","isArray","dt","watchTasks","oper","TaskConfig_1","Operation","default","watch","utils_1","matchCompare","autoWatch","push","createTask","task","createWatchTask","shell","ShellTask","execFiles","ExecFileTask","isFunction","createCustomTask","createPipesTask","factory","info","gulp","tk","taskName","console","log","chalk","cyan","DynamicTask","name","order","group","assert","callback","watchs","last","pop","event","watchChanged","map","w","isString","src","getSrc","call","taskSequence_1","runSequence","then","DynamicPipeTask","require","coregulp","PipeTask_1","cmd","this","prototype","getInfo","setup","_this","option","to","Promise","resolve","cmds","execShell","execOptions","shellRunWay","RunWay","sequence","pip_1","all","reject","files","execFile","args","execFileOptions","fileRunWay","pip_2","file","_super","__extends","getOption","toStr","customPipe","source","dist","pipe","stream","cpipe2Promise","pipes","concat","output","outputs","PipeTask","exports"],"mappings":"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","file":"../generateTask.js","sourcesContent":["import * as _ from 'lodash';\r\nimport { Gulp, WatchEvent } from 'gulp';\r\nimport * as coregulp from 'gulp';\r\nimport * as chalk from 'chalk';\r\n\r\nimport { IAssertDist, IShellOption, IExecFileOption, IOutputPipe, Operation, AsyncSrc, ITaskInfo, ITransform, RunWay, AsyncTaskSource, TaskResult, IPipe, IDynamicTaskOption, ITaskContext, ITask } from './TaskConfig';\r\nimport { matchCompare } from './utils';\r\nimport { PipeTask } from './PipeTask';\r\nimport { runSequence } from './taskSequence';\r\nimport * as watch from 'gulp-watch';\r\n\r\ntype factory = (ctx: ITaskContext, info: ITaskInfo, gulp: Gulp) => TaskResult;\r\n\r\n/**\r\n * Shell Task\r\n *\r\n * @class ShellTask\r\n * @implements {ITask}\r\n */\r\nclass ShellTask implements ITask {\r\n    constructor(protected info: ITaskInfo, protected cmd: AsyncTaskSource) {\r\n\r\n    }\r\n\r\n    /**\r\n     * get task info.\r\n     */\r\n    public getInfo(): ITaskInfo {\r\n        return this.info;\r\n    }\r\n\r\n    /**\r\n     * setup shell task.\r\n     *\r\n     * @param {ITaskContext} ctx\r\n     * @param {Gulp} [gulp]\r\n     * @returns\r\n     *\r\n     * @memberOf ShellTask\r\n     */\r\n    setup(ctx: ITaskContext, gulp?: Gulp) {\r\n        gulp = gulp || coregulp;\r\n        let option = ctx.option as IShellOption;\r\n        let tk = ctx.taskName(this.getInfo());\r\n        console.log(`register shell task:`, chalk.cyan(tk));\r\n\r\n        gulp.task(tk, () => {\r\n            let cmd = ctx.to<AsyncSrc>(this.cmd);\r\n            return Promise.resolve(cmd)\r\n                .then(cmds => {\r\n                    if (_.isString(cmds)) {\r\n                        return ctx.execShell(cmds, option.execOptions);\r\n                    } else if (_.isArray(cmds)) {\r\n                        if (option.shellRunWay === RunWay.sequence) {\r\n                            let pip = Promise.resolve();\r\n                            _.each(cmds, cmd => {\r\n                                pip = pip.then(() => ctx.execShell(cmd, option.execOptions));\r\n                            });\r\n                            return pip;\r\n                        } else {\r\n                            return Promise.all(_.map(cmds, cmd => ctx.execShell(cmd, option.execOptions)));\r\n                        }\r\n                    } else {\r\n\r\n                        return Promise.reject('shell task config error');\r\n                    }\r\n                });\r\n\r\n        });\r\n\r\n        this.info.taskName = tk;\r\n\r\n        return tk;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * exec file Task\r\n *\r\n * @class ExecFileTask\r\n * @implements {ITask}\r\n */\r\nclass ExecFileTask implements ITask {\r\n    constructor(protected info: ITaskInfo, protected files: AsyncTaskSource) {\r\n\r\n    }\r\n\r\n    /**\r\n     * get task info.\r\n     */\r\n    public getInfo(): ITaskInfo {\r\n        return this.info;\r\n    }\r\n\r\n    /**\r\n     * setup shell task.\r\n     *\r\n     * @param {ITaskContext} ctx\r\n     * @param {Gulp} [gulp]\r\n     * @returns\r\n     *\r\n     * @memberOf ShellTask\r\n     */\r\n    setup(ctx: ITaskContext, gulp?: Gulp) {\r\n        gulp = gulp || coregulp;\r\n        let option = ctx.option as IExecFileOption;\r\n        let tk = ctx.taskName(this.getInfo());\r\n        console.log(`register exec file task:`, chalk.cyan(tk));\r\n\r\n        gulp.task(tk, () => {\r\n            let files = ctx.to<AsyncSrc>(this.files);\r\n            return Promise.resolve(files)\r\n                .then(files => {\r\n                    if (_.isString(files)) {\r\n                        return ctx.execFile(files, option.args, option.execFileOptions);\r\n                    } else if (_.isArray(files)) {\r\n                        if (option.fileRunWay === RunWay.sequence) {\r\n                            let pip = Promise.resolve();\r\n                            _.each(files, file => {\r\n                                pip = pip.then(() => ctx.execFile(file, option.args, option.execFileOptions));\r\n                            });\r\n                            return pip;\r\n                        } else {\r\n                            return Promise.all(_.map(files, file => ctx.execFile(file, option.args, option.execFileOptions)));\r\n                        }\r\n                    } else {\r\n                        return Promise.reject('exec file task config error');\r\n                    }\r\n                });\r\n\r\n        });\r\n\r\n        this.info.taskName = tk;\r\n\r\n        return tk;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * custom dynamic task.\r\n *\r\n * @class DynamicTask\r\n * @implements {ITask}\r\n */\r\nclass DynamicTask implements ITask {\r\n    constructor(protected info: ITaskInfo, private factory: factory) {\r\n    }\r\n\r\n    /**\r\n     * get task info.\r\n     *\r\n     * @type {ITaskInfo}\r\n     * @memberOf PipeTask\r\n     */\r\n    public getInfo(): ITaskInfo {\r\n        return this.info;\r\n    }\r\n\r\n    setup(ctx: ITaskContext, gulp?: Gulp) {\r\n        let name = this.factory(ctx, this.getInfo(), gulp || coregulp);\r\n        if (name) {\r\n            this.info.taskName = name;\r\n        }\r\n        return name;\r\n    }\r\n}\r\n\r\n/**\r\n * pipe task for dynamic task.\r\n *\r\n * @class DynamicPipeTask\r\n * @extends {PipeTask}\r\n */\r\nclass DynamicPipeTask extends PipeTask {\r\n    constructor(private dt: IDynamicTaskOption, info?: ITaskInfo) {\r\n        super(info || dt);\r\n        this.info.assert = dt;\r\n    }\r\n\r\n    protected getOption(ctx: ITaskContext) {\r\n        this.name = this.name || ctx.toStr(this.dt.name);\r\n        return this.dt || ctx.option;\r\n    }\r\n\r\n    protected customPipe(source: ITransform, ctx: ITaskContext, dist: IAssertDist, gulp: Gulp) {\r\n        if (this.dt.pipe) {\r\n            return Promise.resolve(super.customPipe(source, ctx, dist, gulp))\r\n                .then(stream => this.cpipe2Promise(stream, this.dt, ctx, dist, gulp));\r\n        } else {\r\n            return super.customPipe(source, ctx, dist, gulp)\r\n        }\r\n    }\r\n\r\n    pipes(ctx: ITaskContext, dist: IAssertDist, gulp?: Gulp): IPipe[] {\r\n        let pipes = _.isFunction(this.dt.pipes) ? this.dt.pipes(ctx, dist, gulp) : this.dt.pipes;\r\n        pipes = pipes || [];\r\n        return pipes.concat(super.pipes(ctx, dist, gulp));\r\n    }\r\n\r\n    output(ctx: ITaskContext, dist: IAssertDist, gulp?: Gulp): IOutputPipe[] {\r\n        if (this.dt.output === null) {\r\n            return [stream => stream];\r\n        }\r\n        let outputs = _.isFunction(this.dt.output) ? this.dt.output(ctx, dist, gulp) : this.dt.output;\r\n        outputs = outputs || [];\r\n        return outputs.concat(super.output(ctx, dist, gulp));\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * dynamic build tasks.\r\n *\r\n * @export\r\n * @param {(IDynamicTaskOption | IDynamicTaskOption[])} tasks\r\n * @param {ITaskInfo} [match]\r\n * @param {ITaskContext} [ctx]\r\n * @returns {ITask[]}\r\n */\r\nexport function generateTask(tasks: IDynamicTaskOption | IDynamicTaskOption[], match?: ITaskInfo, ctx?: ITaskContext): ITask[] {\r\n    let taskseq: ITask[] = [];\r\n    _.each(_.isArray(tasks) ? tasks : [tasks], dt => {\r\n\r\n        if (dt.watchTasks) {\r\n            dt.oper = (dt.oper || Operation.default) | Operation.watch;\r\n        }\r\n\r\n        if (!matchCompare(dt, match, ctx)) {\r\n            return;\r\n        }\r\n\r\n        if (dt.watch && !(dt.oper & Operation.watch)) {\r\n            dt.oper = dt.oper | Operation.autoWatch;\r\n        }\r\n        taskseq.push(createTask(dt));\r\n\r\n    });\r\n\r\n    return taskseq;\r\n}\r\n\r\n/**\r\n * create task by dynamic option.\r\n *\r\n * @export\r\n * @param {IDynamicTaskOption} dt\r\n * @returns {ITask}\r\n */\r\nfunction createTask(dt: IDynamicTaskOption): ITask {\r\n    let task: ITask;\r\n    if (dt.oper & Operation.watch) {\r\n        task = createWatchTask(dt);\r\n    } else if (dt.shell) {\r\n        task = new ShellTask(dt, dt.shell);\r\n    } else if (dt.execFiles) {\r\n        task = new ExecFileTask(dt, dt.execFiles);\r\n    } else if (_.isFunction(dt.task)) {\r\n        // custom task\r\n        task = createCustomTask(dt);\r\n    } else {\r\n        // pipe stream task.\r\n        task = createPipesTask(dt);\r\n    }\r\n    return task;\r\n}\r\n\r\n\r\n/**\r\n * create custom task.\r\n *\r\n * @param {IDynamicTaskOption} dt\r\n * @returns {ITask}\r\n */\r\nfunction createCustomTask(dt: IDynamicTaskOption): ITask {\r\n    let factory = (ctx: ITaskContext, info: ITaskInfo, gulp: Gulp) => {\r\n        let tk = ctx.taskName(info);\r\n        console.log('register custom dynamic task:', chalk.cyan(tk));\r\n        gulp.task(tk, () => {\r\n            return dt.task(ctx, dt, gulp);\r\n        });\r\n\r\n        return tk\r\n    };\r\n\r\n    return new DynamicTask({ name: dt.name, order: dt.order, oper: dt.oper, group: dt.group, assert: dt }, factory);\r\n}\r\n\r\n\r\n/**\r\n * create dynamic watch task.\r\n *\r\n * @export\r\n * @param {IDynamicTaskOption} dt\r\n * @returns {ITask}\r\n */\r\nfunction createWatchTask(dt: IDynamicTaskOption): ITask {\r\n    let factory = (ctx: ITaskContext, info: ITaskInfo, gulp: Gulp) => {\r\n        let watchs = _.isFunction(dt.watchTasks) ? dt.watchTasks(ctx, dt) : dt.watchTasks;\r\n        // if (!_.isFunction(_.last(watchs))) {\r\n        //     watchs.push(<WatchCallback>(event: WatchEvent) => {\r\n        //         dt.watchChanged && dt.watchChanged(event, ctx);\r\n        //     });\r\n        // }\r\n        let callback;\r\n        if (!_.isFunction(_.last(watchs))) {\r\n            callback = (event: WatchEvent) => {\r\n                dt.watchChanged && dt.watchChanged(event, ctx);\r\n            };\r\n        } else {\r\n            callback = watchs.pop();\r\n        }\r\n\r\n        watchs = _.map(watchs, w => {\r\n            if (_.isString(w)) {\r\n                return ctx.taskName(w);\r\n            }\r\n            return w;\r\n        })\r\n        let tk = ctx.taskName(info);\r\n        console.log('register watch  dynamic task:', chalk.cyan(tk));\r\n        gulp.task(tk, () => {\r\n            let src = ctx.getSrc(info);\r\n            console.log('watch, src:', chalk.cyan.call(chalk, src));\r\n            // watch(src, watchs);\r\n            watch(src, () => {\r\n                runSequence(gulp, <string[]>watchs)\r\n                    .then(() => {\r\n                        callback && callback();\r\n                    });\r\n            });\r\n        });\r\n\r\n        return tk;\r\n    };\r\n\r\n    return new DynamicTask({ name: dt.name, order: dt.order, oper: dt.oper, group: dt.group, assert: dt }, factory);\r\n}\r\n\r\n/**\r\n * create pipe task.\r\n *\r\n * @export\r\n * @param {IDynamicTaskOption} dt\r\n * @returns {ITask}\r\n */\r\nfunction createPipesTask(dt: IDynamicTaskOption): ITask {\r\n    return new DynamicPipeTask(dt);\r\n}\r\n"]}