{"version":3,"sources":["generateTask.js","generateTask.ts"],"names":["generateTask","tasks","match","taskseq","_","each","isArray","dt","oper","utils_1","matchTaskGroup","watchTasks","watch","push","createWatchTask","isFunction","task","createTask","createPipesTask","factory","cfg","gulp","tk","subTaskName","name","console","log","chalk","cyan","DynamicTask","order","group","watchs","last","event","watchChanged","map","w","isString","src","getSrc","call","DynamicPipeTask","require","coregulp","PipeTask_1","decorator","_classCallCheck","this","config","taskName","info","_this","_possibleConstructorReturn","__proto__","Object","getPrototypeOf","option","dist","_this2","pipe","Promise","resolve","_get","prototype","then","stream","reject","err","pipes","concat","outputs","output","PipeTask","exports"],"mappings":"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","file":"../generateTask.js","sourcesContent":["\"use strict\";\nconst _ = require('lodash');\nconst coregulp = require('gulp');\nconst chalk = require('chalk');\nconst utils_1 = require('./utils');\nconst PipeTask_1 = require('./PipeTask');\nclass DynamicTask {\n    constructor(decorator, factory) {\n        this.decorator = decorator;\n        this.factory = factory;\n    }\n    setup(config, gulp) {\n        let name = this.factory(config, gulp || coregulp);\n        if (name) {\n            this.decorator.taskName = name;\n        }\n        return name;\n    }\n}\nclass DynamicPipeTask extends PipeTask_1.PipeTask {\n    constructor(dt, info) {\n        super(info);\n        this.dt = dt;\n        this.decorator = info || dt;\n    }\n    getOption(config) {\n        return this.dt || config.option;\n    }\n    sourceStream(config, dist, gulp) {\n        if (this.dt.pipe) {\n            return Promise.resolve(super.sourceStream(config, dist, gulp))\n                .then(stream => {\n                return new Promise((resolve, reject) => {\n                    this.dt.pipe(stream, config, this.dt, (err) => {\n                        if (err) {\n                            reject(err);\n                        }\n                        else {\n                            resolve(stream);\n                        }\n                    });\n                });\n            });\n        }\n        else {\n            return super.sourceStream(config, dist, gulp);\n        }\n    }\n    pipes(config, dist, gulp) {\n        let pipes = _.isFunction(this.dt.pipes) ? this.dt.pipes(config, dist, gulp) : this.dt.pipes;\n        pipes = pipes || [];\n        return pipes.concat(super.pipes(config, dist, gulp));\n    }\n    output(config, dist, gulp) {\n        let outputs = _.isFunction(this.dt.output) ? this.dt.output(config, dist, gulp) : this.dt.output;\n        outputs = outputs || [];\n        return outputs.concat(super.output(config, dist, gulp));\n    }\n}\nfunction generateTask(tasks, match) {\n    let taskseq = [];\n    _.each(_.isArray(tasks) ? tasks : [tasks], dt => {\n        if (match && match.oper && dt.oper && (dt.oper & match.oper) <= 0) {\n            return;\n        }\n        if (!utils_1.matchTaskGroup(dt, match)) {\n            return;\n        }\n        if (dt.watchTasks) {\n            dt.watch = dt.watch || !!dt.watchTasks;\n        }\n        if (dt.watch) {\n            if (!match || !match.watch) {\n                return;\n            }\n            if (dt.watch === match.watch) {\n                taskseq.push(createWatchTask(dt));\n            }\n        }\n        else if (_.isFunction(dt.task)) {\n            taskseq.push(createTask(dt));\n        }\n        else {\n            taskseq.push(createPipesTask(dt));\n        }\n    });\n    return taskseq;\n}\nexports.generateTask = generateTask;\nfunction createTask(dt) {\n    let factory = (cfg, gulp) => {\n        let tk = cfg.subTaskName(dt.name);\n        console.log('register custom dynamic task:', chalk.cyan(tk));\n        gulp.task(tk, () => {\n            return dt.task(cfg, dt, gulp);\n        });\n        return tk;\n    };\n    return new DynamicTask({ order: dt.order, oper: dt.oper, watch: dt.watch, group: dt.group }, factory);\n}\nfunction createWatchTask(dt) {\n    let factory = (cfg, gulp) => {\n        let watchs = _.isFunction(dt.watchTasks) ? dt.watchTasks(cfg) : dt.watchTasks;\n        if (!_.isFunction(_.last(watchs))) {\n            watchs.push((event) => {\n                dt.watchChanged && dt.watchChanged(event, cfg);\n            });\n        }\n        watchs = _.map(watchs, w => {\n            if (_.isString(w)) {\n                return cfg.subTaskName(w);\n            }\n            return w;\n        });\n        let tk = cfg.subTaskName(dt);\n        console.log('register watch  dynamic task:', chalk.cyan(tk));\n        gulp.task(tk, () => {\n            let src = cfg.getSrc(dt, dt);\n            console.log('watch, src:', chalk.cyan.call(chalk, src));\n            gulp.watch(src, watchs);\n        });\n        return tk;\n    };\n    return new DynamicTask({ order: dt.order, oper: dt.oper, watch: dt.watch, group: dt.group }, factory);\n}\nfunction createPipesTask(dt) {\n    return new DynamicPipeTask(dt);\n}\n","import * as _ from 'lodash';\r\nimport { Gulp, WatchEvent } from 'gulp';\r\nimport * as coregulp from 'gulp';\r\nimport * as chalk from 'chalk';\r\n\r\nimport { IAssertDist, IOutputPipe, ITaskInfo, ITransform, TaskResult, IPipe, IDynamicTaskOption, ITaskConfig, ITask } from './TaskConfig';\r\nimport { matchTaskGroup } from './utils';\r\nimport { PipeTask } from './PipeTask';\r\n\r\ntype factory = (config: ITaskConfig, gulp: Gulp) => TaskResult;\r\nclass DynamicTask implements ITask {\r\n    constructor(public decorator: ITaskInfo, private factory: factory) {\r\n    }\r\n    setup(config: ITaskConfig, gulp?: Gulp) {\r\n        let name = this.factory(config, gulp || coregulp);\r\n        if (name) {\r\n            this.decorator.taskName = name;\r\n        }\r\n        return name;\r\n    }\r\n}\r\n\r\nclass DynamicPipeTask extends PipeTask {\r\n    constructor(private dt: IDynamicTaskOption, info?: ITaskInfo) {\r\n        super(info);\r\n        this.decorator = info || dt;\r\n    }\r\n\r\n    protected getOption(config: ITaskConfig) {\r\n        return this.dt || config.option;\r\n    }\r\n\r\n    sourceStream(config: ITaskConfig, dist: IAssertDist, gulp?: Gulp): ITransform | Promise<ITransform> {\r\n        if (this.dt.pipe) {\r\n            return Promise.resolve(super.sourceStream(config, dist, gulp))\r\n                .then(stream => {\r\n                    return new Promise((resolve, reject) => {\r\n                        this.dt.pipe(stream, config, this.dt, (err) => {\r\n                            if (err) {\r\n                                reject(err);\r\n                            } else {\r\n                                resolve(stream);\r\n                            }\r\n                        });\r\n                    });\r\n                });\r\n        } else {\r\n            return super.sourceStream(config, dist, gulp);\r\n        }\r\n    }\r\n\r\n    pipes(config: ITaskConfig, dist: IAssertDist, gulp?: Gulp): IPipe[] {\r\n        let pipes = _.isFunction(this.dt.pipes) ? this.dt.pipes(config, dist, gulp) : this.dt.pipes;\r\n        pipes = pipes || [];\r\n        return pipes.concat(super.pipes(config, dist, gulp));\r\n    }\r\n\r\n    output(config: ITaskConfig, dist: IAssertDist, gulp?: Gulp): IOutputPipe[] {\r\n        let outputs = _.isFunction(this.dt.output) ? this.dt.output(config, dist, gulp) : this.dt.output;\r\n        outputs = outputs || [];\r\n        return outputs.concat(super.output(config, dist, gulp));\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * dynamic build tasks.\r\n * \r\n * @export\r\n * @param {(IDynamicTaskOption | IDynamicTaskOption[])} tasks\r\n * @param {ITaskInfo} [match]\r\n * @returns {ITask[]}\r\n */\r\nexport function generateTask(tasks: IDynamicTaskOption | IDynamicTaskOption[], match?: ITaskInfo): ITask[] {\r\n    let taskseq: ITask[] = [];\r\n    _.each(_.isArray(tasks) ? tasks : [tasks], dt => {\r\n\r\n        if (match && match.oper && dt.oper && (dt.oper & match.oper) <= 0) {\r\n            return;\r\n        }\r\n\r\n        if (!matchTaskGroup(dt, match)) {\r\n            return;\r\n        }\r\n\r\n\r\n        if (dt.watchTasks) {\r\n            dt.watch = dt.watch || !!dt.watchTasks;\r\n        }\r\n\r\n        if (dt.watch) {\r\n            if (!match || !match.watch) {\r\n                return;\r\n            }\r\n            if (dt.watch === match.watch) {\r\n                taskseq.push(createWatchTask(dt));\r\n            }\r\n        } else if (_.isFunction(dt.task)) {\r\n            // custom task\r\n            taskseq.push(createTask(dt));\r\n        } else {\r\n            // pipe stream task.\r\n            taskseq.push(createPipesTask(dt));\r\n        }\r\n    });\r\n\r\n    return taskseq;\r\n}\r\n\r\n\r\n\r\n/**\r\n * promise task.\r\n * \r\n * @param {DynamicTask} dt\r\n * @returns\r\n */\r\nfunction createTask(dt: IDynamicTaskOption) {\r\n    let factory = (cfg: ITaskConfig, gulp: Gulp) => {\r\n        let tk = cfg.subTaskName(dt.name);\r\n        console.log('register custom dynamic task:', chalk.cyan(tk));\r\n        gulp.task(tk, () => {\r\n            return dt.task(cfg, dt, gulp);\r\n        });\r\n\r\n        return tk\r\n    };\r\n\r\n    return new DynamicTask({ order: dt.order, oper: dt.oper, watch: dt.watch, group: dt.group }, factory);\r\n}\r\n/**\r\n * create dynamic watch task.\r\n * \r\n * @param {DynamicTask} dt\r\n * @returns\r\n */\r\nfunction createWatchTask(dt: IDynamicTaskOption) {\r\n    let factory = (cfg: ITaskConfig, gulp: Gulp) => {\r\n        let watchs = _.isFunction(dt.watchTasks) ? dt.watchTasks(cfg) : dt.watchTasks;\r\n        if (!_.isFunction(_.last(watchs))) {\r\n            watchs.push(<WatchCallback>(event: WatchEvent) => {\r\n                dt.watchChanged && dt.watchChanged(event, cfg);\r\n            });\r\n        }\r\n        watchs = _.map(watchs, w => {\r\n            if (_.isString(w)) {\r\n                return cfg.subTaskName(w);\r\n            }\r\n            return w;\r\n        })\r\n        let tk = cfg.subTaskName(dt);\r\n        console.log('register watch  dynamic task:', chalk.cyan(tk));\r\n        gulp.task(tk, () => {\r\n            let src = cfg.getSrc(dt, dt);\r\n            console.log('watch, src:', chalk.cyan.call(chalk, src));\r\n            gulp.watch(src, watchs)\r\n        });\r\n\r\n        return tk;\r\n    };\r\n\r\n    return new DynamicTask({ order: dt.order, oper: dt.oper, watch: dt.watch, group: dt.group }, factory);\r\n}\r\n\r\nfunction createPipesTask(dt: IDynamicTaskOption) {\r\n    return new DynamicPipeTask(dt);\r\n}\r\n\r\n// function createPipesTask(dt: IDynamicTaskOption) {\r\n//     let factory = (cfg: ITaskConfig, gulp: Gulp) => {\r\n\r\n//         let tk = cfg.subTaskName(dt);\r\n//         console.log('register pipes  dynamic task:', chalk.cyan(tk));\r\n//         gulp.task(tk, () => {\r\n//             let taskPromise = Promise.resolve(gulp.src(cfg.getSrc(dt, dt)));\r\n//             if (dt.pipes) {\r\n//                 let pipes = _.isFunction(dt.pipes) ? dt.pipes(cfg, dt, gulp) : dt.pipes;\r\n//                 taskPromise = taskPromise.then(psrc => {\r\n//                     return Promise.all(_.map(pipes, (p: Pipe) => {\r\n//                         return _.isFunction(p) ? p(cfg, dt, gulp) : p;\r\n//                     }))\r\n//                         .then(streams => {\r\n//                             _.each(streams, stream => {\r\n//                                 psrc = psrc.pipe(stream);\r\n//                             });\r\n//                             return psrc;\r\n//                         })\r\n//                 });\r\n\r\n//             } else if (dt.pipe) {\r\n//                 taskPromise = taskPromise.then((stream => {\r\n//                     return new Promise((resolve, reject) => {\r\n//                         return dt.pipe(stream, cfg, dt, (err) => {\r\n//                             if (err) {\r\n//                                 reject(err);\r\n//                             } else {\r\n//                                 resolve(stream);\r\n//                             }\r\n//                         });\r\n//                     });\r\n//                 }));\r\n//             }\r\n\r\n//             if (dt.output !== null) {\r\n//                 taskPromise = taskPromise.then(stream => {\r\n//                     if (dt.output) {\r\n//                         let outputs = _.isFunction(dt.output) ? dt.output(cfg, dt) : dt.output;\r\n//                         return Promise.all(_.map(outputs, output => {\r\n//                             return Promise.resolve<NodeJS.ReadWriteStream>((_.isFunction(output) ? output(stream, cfg, dt, gulp) : output))\r\n//                                 .then(output => {\r\n//                                     return new Promise((resolve, reject) => {\r\n//                                         output\r\n//                                             .once('end', () => {\r\n//                                                 resolve(output);\r\n//                                             })\r\n//                                             .once('error', reject);\r\n//                                     });\r\n//                                 });\r\n//                         }));\r\n//                     } else {\r\n//                         return new Promise((resolve, reject) => {\r\n//                             let output = gulp.dest(cfg.getDist(dt));\r\n//                             stream.pipe(output)\r\n//                                 .once('end', () => {\r\n//                                     resolve(output)\r\n//                                 })\r\n//                                 .once('error', reject);\r\n//                         });\r\n//                     }\r\n//                 });\r\n//             } else {\r\n//                 taskPromise = taskPromise.then(stream => {\r\n//                     return new Promise((resolve, reject) => {\r\n//                         stream\r\n//                             .once('end', () => {\r\n//                                 resolve(stream);\r\n//                             })\r\n//                             .once('error', reject);\r\n//                     });\r\n//                 });\r\n//             }\r\n\r\n//             // return taskPromise;\r\n//             return taskPromise.catch(err => {\r\n//                 console.log(chalk.red(err));\r\n//                 process.exit(0);\r\n//             });\r\n//         });\r\n\r\n//         return tk;\r\n//     }\r\n\r\n//     return new DynamicTask({ order: dt.order, oper: dt.oper, watch: dt.watch, group: dt.group }, factory);\r\n// }\r\n\r\n\r\n"]}