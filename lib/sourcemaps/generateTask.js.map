{"version":3,"sources":["generateTask.ts"],"names":["generateTask","ctx","tasks","match","isDynamic","taskseq","_","each","isArray","dt","oper","to","TaskConfig_1","Operation","default","watchTasks","watch","utils_1","matchCompare","autoWatch","push","createTask","task","createPipesTask","createWatchTask","shell","ShellTask","execFiles","ExecFileTask","isFunction","createCustomTask","DynamicTask","name","order","group","assert","DynamicWatchTask","DynamicPipeTask","require","coregulp","chalk","PipeTask_1","taskSequence_1","info","cmd","this","prototype","getInfo","execute","gulp","option","Promise","resolve","then","cmds","isString","execShell","execOptions","allowError","shellRunWay","RunWay","sequence","pip_1","all","map","reject","setup","_this","tk","taskName","console","log","cyan","files","execFile","args","execFileOptions","fileRunWay","pip_2","file","rt","callback","watchs","last","pop","event","watchChanged","w","src","getSrc","call","runSequence","_super","__extends","getOption","toStr","customPipe","source","dist","pipe","stream","cpipe2Promise","pipes","concat","output","outputs","PipeTask","exports"],"mappings":"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","file":"../generateTask.js","sourcesContent":["import * as _ from 'lodash';\r\nimport { Gulp, WatchEvent } from 'gulp';\r\nimport * as coregulp from 'gulp';\r\nimport * as chalk from 'chalk';\r\n\r\nimport { IAssertDist, IShellOption, IExecFileOption, IOutputPipe, Operation, AsyncSrc, ITaskInfo, ITransform, RunWay, AsyncTaskSource, TaskResult, IPipe, IDynamicTaskOption, ITaskContext, ITask } from './TaskConfig';\r\nimport { matchCompare } from './utils';\r\nimport { PipeTask } from './PipeTask';\r\nimport { runSequence } from './taskSequence';\r\nimport * as watch from 'gulp-watch';\r\n\r\n// type factory = (ctx: ITaskContext, info: ITaskInfo, gulp: Gulp) => TaskResult;\r\n\r\n/**\r\n * Shell Task\r\n *\r\n * @class ShellTask\r\n * @implements {ITask}\r\n */\r\nclass ShellTask implements ITask {\r\n    constructor(protected info: ITaskInfo, protected cmd: AsyncTaskSource) {\r\n\r\n    }\r\n\r\n    /**\r\n     * get task info.\r\n     */\r\n    public getInfo(): ITaskInfo {\r\n        return this.info;\r\n    }\r\n\r\n    execute(ctx: ITaskContext, gulp?: Gulp): Promise<any> {\r\n        let option = ctx.option as IShellOption;\r\n        let cmd = ctx.to<AsyncSrc>(this.cmd);\r\n        return Promise.resolve(cmd)\r\n            .then(cmds => {\r\n                if (_.isString(cmds)) {\r\n                    return ctx.execShell(cmds, option.execOptions, option.allowError !== false);\r\n                } else if (_.isArray(cmds)) {\r\n                    if (option.shellRunWay === RunWay.sequence) {\r\n                        let pip = Promise.resolve();\r\n                        _.each(cmds, cmd => {\r\n                            pip = pip.then(() => ctx.execShell(cmd, option.execOptions));\r\n                        });\r\n                        return pip;\r\n                    } else {\r\n                        return Promise.all(_.map(cmds, cmd => ctx.execShell(cmd, option.execOptions, option.allowError !== false)));\r\n                    }\r\n                } else {\r\n\r\n                    return Promise.reject('shell task config error');\r\n                }\r\n            });\r\n    }\r\n\r\n    /**\r\n     * setup shell task.\r\n     *\r\n     * @param {ITaskContext} ctx\r\n     * @param {Gulp} [gulp]\r\n     * @returns\r\n     *\r\n     * @memberOf ShellTask\r\n     */\r\n    setup(ctx: ITaskContext, gulp?: Gulp) {\r\n        gulp = gulp || coregulp;\r\n        let tk = ctx.taskName(this.getInfo());\r\n        console.log(`register shell task:`, chalk.cyan(tk));\r\n\r\n        gulp.task(tk, () => {\r\n            return this.execute(ctx, gulp);\r\n        });\r\n\r\n        this.info.taskName = tk;\r\n\r\n        return tk;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * exec file Task\r\n *\r\n * @class ExecFileTask\r\n * @implements {ITask}\r\n */\r\nclass ExecFileTask implements ITask {\r\n    constructor(protected info: ITaskInfo, protected files: AsyncTaskSource) {\r\n\r\n    }\r\n\r\n    /**\r\n     * get task info.\r\n     */\r\n    public getInfo(): ITaskInfo {\r\n        return this.info;\r\n    }\r\n\r\n    execute(ctx: ITaskContext, gulp?: Gulp): Promise<any> {\r\n        let option = ctx.option as IExecFileOption;\r\n        let files = ctx.to<AsyncSrc>(this.files);\r\n        return Promise.resolve(files)\r\n            .then(files => {\r\n                if (_.isString(files)) {\r\n                    return ctx.execFile(files, option.args, option.execFileOptions, option.allowError !== false);\r\n                } else if (_.isArray(files)) {\r\n                    if (option.fileRunWay === RunWay.sequence) {\r\n                        let pip = Promise.resolve();\r\n                        _.each(files, file => {\r\n                            pip = pip.then(() => ctx.execFile(file, option.args, option.execFileOptions, option.allowError !== false));\r\n                        });\r\n                        return pip;\r\n                    } else {\r\n                        return Promise.all(_.map(files, file => ctx.execFile(file, option.args, option.execFileOptions, option.allowError !== false)));\r\n                    }\r\n                } else {\r\n                    return Promise.reject('exec file task config error');\r\n                }\r\n            });\r\n    }\r\n\r\n    /**\r\n     * setup shell task.\r\n     *\r\n     * @param {ITaskContext} ctx\r\n     * @param {Gulp} [gulp]\r\n     * @returns\r\n     *\r\n     * @memberOf ShellTask\r\n     */\r\n    setup(ctx: ITaskContext, gulp?: Gulp) {\r\n        gulp = gulp || coregulp;\r\n\r\n        let tk = ctx.taskName(this.getInfo());\r\n        console.log(`register exec file task:`, chalk.cyan(tk));\r\n\r\n        gulp.task(tk, () => {\r\n            return this.execute(ctx, gulp);\r\n        });\r\n\r\n        this.info.taskName = tk;\r\n\r\n        return tk;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * custom dynamic task.\r\n *\r\n * @class DynamicTask\r\n * @implements {ITask}\r\n */\r\nclass DynamicTask implements ITask {\r\n    constructor(protected info: ITaskInfo, protected dt: IDynamicTaskOption) {\r\n    }\r\n\r\n    /**\r\n     * get task info.\r\n     *\r\n     * @type {ITaskInfo}\r\n     * @memberOf PipeTask\r\n     */\r\n    public getInfo(): ITaskInfo {\r\n        return this.info;\r\n    }\r\n\r\n    execute(ctx: ITaskContext, gulp?: Gulp): Promise<any> {\r\n        let rt = this.dt.task(ctx, this.dt, gulp);\r\n        if (rt && rt['then']) {\r\n            return rt as Promise<any>;\r\n        } else {\r\n            return Promise.resolve(rt);\r\n        }\r\n    }\r\n\r\n    setup(ctx: ITaskContext, gulp?: Gulp) {\r\n        let tk = ctx.taskName(this.getInfo());\r\n        console.log('register custom dynamic task:', chalk.cyan(tk));\r\n        gulp.task(tk, () => {\r\n            return this.execute(ctx, gulp);\r\n        });\r\n\r\n        this.info.taskName = tk;\r\n\r\n        return tk;\r\n    }\r\n}\r\n\r\n/**\r\n * custom dynamic watch task.\r\n *\r\n * @class DynamicWatchTask\r\n * @implements {ITask}\r\n */\r\nclass DynamicWatchTask implements ITask {\r\n    constructor(protected info: ITaskInfo, protected dt: IDynamicTaskOption) {\r\n    }\r\n\r\n    /**\r\n     * get task info.\r\n     *\r\n     * @type {ITaskInfo}\r\n     * @memberOf PipeTask\r\n     */\r\n    public getInfo(): ITaskInfo {\r\n        return this.info;\r\n    }\r\n\r\n    execute(ctx: ITaskContext, gulp?: Gulp): Promise<any> {\r\n        return Promise.resolve();\r\n    }\r\n\r\n    setup(ctx: ITaskContext, gulp?: Gulp) {\r\n        let dt = this.dt;\r\n        let watchs = _.isFunction(dt.watchTasks) ? dt.watchTasks(ctx, dt) : dt.watchTasks;\r\n        let callback;\r\n        if (!_.isFunction(_.last(watchs))) {\r\n            callback = (event: WatchEvent) => {\r\n                dt.watchChanged && dt.watchChanged(event, ctx);\r\n            };\r\n        } else {\r\n            callback = watchs.pop();\r\n        }\r\n\r\n        watchs = _.map(watchs, w => {\r\n            if (_.isString(w)) {\r\n                return ctx.taskName(w);\r\n            }\r\n            return w;\r\n        })\r\n        let info = this.getInfo();\r\n        let tk = ctx.taskName(info);\r\n        console.log('register watch  dynamic task:', chalk.cyan(tk));\r\n        gulp.task(tk, () => {\r\n            let src = ctx.getSrc(info);\r\n            console.log('watch, src:', chalk.cyan.call(chalk, src));\r\n            // watch(src, watchs);\r\n            watch(src, () => {\r\n                runSequence(gulp, <string[]>watchs)\r\n                    .then(() => {\r\n                        callback && callback();\r\n                    });\r\n            });\r\n        });\r\n\r\n        return tk;\r\n    }\r\n}\r\n\r\n/**\r\n * pipe task for dynamic task.\r\n *\r\n * @class DynamicPipeTask\r\n * @extends {PipeTask}\r\n */\r\nclass DynamicPipeTask extends PipeTask {\r\n    constructor(private dt: IDynamicTaskOption, info?: ITaskInfo) {\r\n        super(info || dt);\r\n        this.info.assert = dt;\r\n    }\r\n\r\n    protected getOption(ctx: ITaskContext) {\r\n        this.name = this.name || ctx.toStr(this.dt.name);\r\n        return this.dt || ctx.option;\r\n    }\r\n\r\n    protected customPipe(source: ITransform, ctx: ITaskContext, dist: IAssertDist, gulp: Gulp) {\r\n        if (this.dt.pipe) {\r\n            return Promise.resolve(super.customPipe(source, ctx, dist, gulp))\r\n                .then(stream => this.cpipe2Promise(stream, this.dt, ctx, dist, gulp));\r\n        } else {\r\n            return super.customPipe(source, ctx, dist, gulp)\r\n        }\r\n    }\r\n\r\n    pipes(ctx: ITaskContext, dist: IAssertDist, gulp?: Gulp): IPipe[] {\r\n        let pipes = _.isFunction(this.dt.pipes) ? this.dt.pipes(ctx, dist, gulp) : this.dt.pipes;\r\n        pipes = pipes || [];\r\n        return pipes.concat(super.pipes(ctx, dist, gulp));\r\n    }\r\n\r\n    output(ctx: ITaskContext, dist: IAssertDist, gulp?: Gulp): IOutputPipe[] {\r\n        if (this.dt.output === null) {\r\n            return [stream => stream];\r\n        }\r\n        let outputs = _.isFunction(this.dt.output) ? this.dt.output(ctx, dist, gulp) : this.dt.output;\r\n        outputs = outputs || [];\r\n        return outputs.concat(super.output(ctx, dist, gulp));\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * dynamic build tasks.\r\n *\r\n * @export\r\n * @param {ITaskContext} ctx\r\n * @param {(IDynamicTaskOption | IDynamicTaskOption[])} tasks\r\n * @param {ITaskInfo} [match]\r\n * @param {boolean} [isDynamic]\r\n * @returns {ITask[]}\r\n */\r\nexport function generateTask(ctx: ITaskContext, tasks: IDynamicTaskOption | IDynamicTaskOption[], match?: ITaskInfo, isDynamic?: boolean): ITask[] {\r\n    let taskseq: ITask[] = [];\r\n    _.each(_.isArray(tasks) ? tasks : [tasks], dt => {\r\n        dt.oper = dt.oper ? ctx.to(dt.oper) : Operation.default;\r\n        if (dt.watchTasks) {\r\n            dt.oper = dt.oper | Operation.watch;\r\n        }\r\n\r\n        if (!matchCompare(ctx, dt, match)) {\r\n            return;\r\n        }\r\n\r\n        if (dt.watch && !(dt.oper & Operation.watch)) {\r\n            dt.oper = dt.oper | Operation.autoWatch;\r\n        }\r\n        taskseq.push(createTask(ctx, dt, isDynamic));\r\n\r\n    });\r\n\r\n    return taskseq;\r\n}\r\n\r\n/**\r\n * create task by dynamic option.\r\n *\r\n * @param {ITaskContext} ctx\r\n * @param {IDynamicTaskOption} dt\r\n * @param {boolean} [isDynamic]\r\n * @returns {ITask}\r\n */\r\nfunction createTask(ctx: ITaskContext, dt: IDynamicTaskOption, isDynamic?: boolean): ITask {\r\n    let task: ITask;\r\n    if (ctx.to(dt.oper) & Operation.watch) {\r\n        task = isDynamic ? createPipesTask(dt) : createWatchTask(dt);\r\n    } else if (dt.shell) {\r\n        task = new ShellTask(dt, dt.shell);\r\n    } else if (dt.execFiles) {\r\n        task = new ExecFileTask(dt, dt.execFiles);\r\n    } else if (_.isFunction(dt.task)) {\r\n        // custom task\r\n        task = createCustomTask(dt);\r\n    } else {\r\n        // pipe stream task.\r\n        task = createPipesTask(dt);\r\n    }\r\n    return task;\r\n}\r\n\r\n\r\n/**\r\n * create custom task.\r\n *\r\n * @param {IDynamicTaskOption} dt\r\n * @returns {ITask}\r\n */\r\nfunction createCustomTask(dt: IDynamicTaskOption): ITask {\r\n    // let factory = (ctx: ITaskContext, info: ITaskInfo, gulp: Gulp) => {\r\n    //     let tk = ctx.taskName(info);\r\n    //     console.log('register custom dynamic task:', chalk.cyan(tk));\r\n    //     gulp.task(tk, () => {\r\n    //         return dt.task(ctx, dt, gulp);\r\n    //     });\r\n\r\n    //     return tk\r\n    // };\r\n\r\n    return new DynamicTask({ name: dt.name, order: dt.order, oper: dt.oper, group: dt.group, assert: dt }, dt);\r\n}\r\n\r\n\r\n/**\r\n * create dynamic watch task.\r\n *\r\n * @export\r\n * @param {IDynamicTaskOption} dt\r\n * @returns {ITask}\r\n */\r\nfunction createWatchTask(dt: IDynamicTaskOption): ITask {\r\n    // let factory = (ctx: ITaskContext, info: ITaskInfo, gulp: Gulp) => {\r\n    //     let watchs = _.isFunction(dt.watchTasks) ? dt.watchTasks(ctx, dt) : dt.watchTasks;\r\n    //     let callback;\r\n    //     if (!_.isFunction(_.last(watchs))) {\r\n    //         callback = (event: WatchEvent) => {\r\n    //             dt.watchChanged && dt.watchChanged(event, ctx);\r\n    //         };\r\n    //     } else {\r\n    //         callback = watchs.pop();\r\n    //     }\r\n\r\n    //     watchs = _.map(watchs, w => {\r\n    //         if (_.isString(w)) {\r\n    //             return ctx.taskName(w);\r\n    //         }\r\n    //         return w;\r\n    //     })\r\n    //     let tk = ctx.taskName(info);\r\n    //     console.log('register watch  dynamic task:', chalk.cyan(tk));\r\n    //     gulp.task(tk, () => {\r\n    //         let src = ctx.getSrc(info);\r\n    //         console.log('watch, src:', chalk.cyan.call(chalk, src));\r\n    //         // watch(src, watchs);\r\n    //         watch(src, () => {\r\n    //             runSequence(gulp, <string[]>watchs)\r\n    //                 .then(() => {\r\n    //                     callback && callback();\r\n    //                 });\r\n    //         });\r\n    //     });\r\n\r\n    //     return tk;\r\n    // };\r\n\r\n    return new DynamicWatchTask({ name: dt.name, order: dt.order, oper: dt.oper, group: dt.group, assert: dt }, dt);\r\n}\r\n\r\n/**\r\n * create pipe task.\r\n *\r\n * @export\r\n * @param {IDynamicTaskOption} dt\r\n * @returns {ITask}\r\n */\r\nfunction createPipesTask(dt: IDynamicTaskOption): ITask {\r\n    return new DynamicPipeTask(dt);\r\n}\r\n"]}