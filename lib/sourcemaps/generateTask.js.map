{"version":3,"sources":["generateTask.ts"],"names":["generateTask","ctx","tasks","match","taskseq","_","each","isArray","dt","oper","to","TaskConfig_1","Operation","default","watchTasks","watch","utils_1","matchCompare","autoWatch","push","createTask","task","createWatchTask","shell","ShellTask","execFiles","ExecFileTask","isFunction","createCustomTask","createPipesTask","factory","info","gulp","tk","taskName","console","log","chalk","cyan","DynamicTask","name","order","group","assert","callback","watchs","last","pop","event","watchChanged","map","w","isString","src","getSrc","call","taskSequence_1","runSequence","then","DynamicPipeTask","require","coregulp","PipeTask_1","cmd","this","prototype","getInfo","setup","_this","option","Promise","resolve","cmds","execShell","execOptions","allowError","shellRunWay","RunWay","sequence","pip_1","all","reject","files","execFile","args","execFileOptions","fileRunWay","pip_2","file","_super","__extends","getOption","toStr","customPipe","source","dist","pipe","stream","cpipe2Promise","pipes","concat","output","outputs","PipeTask","exports"],"mappings":"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","file":"../generateTask.js","sourcesContent":["import * as _ from 'lodash';\r\nimport { Gulp, WatchEvent } from 'gulp';\r\nimport * as coregulp from 'gulp';\r\nimport * as chalk from 'chalk';\r\n\r\nimport { IAssertDist, IShellOption, IExecFileOption, IOutputPipe, Operation, AsyncSrc, ITaskInfo, ITransform, RunWay, AsyncTaskSource, TaskResult, IPipe, IDynamicTaskOption, ITaskContext, ITask } from './TaskConfig';\r\nimport { matchCompare } from './utils';\r\nimport { PipeTask } from './PipeTask';\r\nimport { runSequence } from './taskSequence';\r\nimport * as watch from 'gulp-watch';\r\n\r\ntype factory = (ctx: ITaskContext, info: ITaskInfo, gulp: Gulp) => TaskResult;\r\n\r\n/**\r\n * Shell Task\r\n *\r\n * @class ShellTask\r\n * @implements {ITask}\r\n */\r\nclass ShellTask implements ITask {\r\n    constructor(protected info: ITaskInfo, protected cmd: AsyncTaskSource) {\r\n\r\n    }\r\n\r\n    /**\r\n     * get task info.\r\n     */\r\n    public getInfo(): ITaskInfo {\r\n        return this.info;\r\n    }\r\n\r\n    /**\r\n     * setup shell task.\r\n     *\r\n     * @param {ITaskContext} ctx\r\n     * @param {Gulp} [gulp]\r\n     * @returns\r\n     *\r\n     * @memberOf ShellTask\r\n     */\r\n    setup(ctx: ITaskContext, gulp?: Gulp) {\r\n        gulp = gulp || coregulp;\r\n        let option = ctx.option as IShellOption;\r\n        let tk = ctx.taskName(this.getInfo());\r\n        console.log(`register shell task:`, chalk.cyan(tk));\r\n\r\n        gulp.task(tk, () => {\r\n            let cmd = ctx.to<AsyncSrc>(this.cmd);\r\n            return Promise.resolve(cmd)\r\n                .then(cmds => {\r\n                    if (_.isString(cmds)) {\r\n                        return ctx.execShell(cmds, option.execOptions, option.allowError !== false);\r\n                    } else if (_.isArray(cmds)) {\r\n                        if (option.shellRunWay === RunWay.sequence) {\r\n                            let pip = Promise.resolve();\r\n                            _.each(cmds, cmd => {\r\n                                pip = pip.then(() => ctx.execShell(cmd, option.execOptions));\r\n                            });\r\n                            return pip;\r\n                        } else {\r\n                            return Promise.all(_.map(cmds, cmd => ctx.execShell(cmd, option.execOptions, option.allowError !== false)));\r\n                        }\r\n                    } else {\r\n\r\n                        return Promise.reject('shell task config error');\r\n                    }\r\n                });\r\n\r\n        });\r\n\r\n        this.info.taskName = tk;\r\n\r\n        return tk;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * exec file Task\r\n *\r\n * @class ExecFileTask\r\n * @implements {ITask}\r\n */\r\nclass ExecFileTask implements ITask {\r\n    constructor(protected info: ITaskInfo, protected files: AsyncTaskSource) {\r\n\r\n    }\r\n\r\n    /**\r\n     * get task info.\r\n     */\r\n    public getInfo(): ITaskInfo {\r\n        return this.info;\r\n    }\r\n\r\n    /**\r\n     * setup shell task.\r\n     *\r\n     * @param {ITaskContext} ctx\r\n     * @param {Gulp} [gulp]\r\n     * @returns\r\n     *\r\n     * @memberOf ShellTask\r\n     */\r\n    setup(ctx: ITaskContext, gulp?: Gulp) {\r\n        gulp = gulp || coregulp;\r\n        let option = ctx.option as IExecFileOption;\r\n        let tk = ctx.taskName(this.getInfo());\r\n        console.log(`register exec file task:`, chalk.cyan(tk));\r\n\r\n        gulp.task(tk, () => {\r\n            let files = ctx.to<AsyncSrc>(this.files);\r\n            return Promise.resolve(files)\r\n                .then(files => {\r\n                    if (_.isString(files)) {\r\n                        return ctx.execFile(files, option.args, option.execFileOptions, option.allowError !== false);\r\n                    } else if (_.isArray(files)) {\r\n                        if (option.fileRunWay === RunWay.sequence) {\r\n                            let pip = Promise.resolve();\r\n                            _.each(files, file => {\r\n                                pip = pip.then(() => ctx.execFile(file, option.args, option.execFileOptions, option.allowError !== false));\r\n                            });\r\n                            return pip;\r\n                        } else {\r\n                            return Promise.all(_.map(files, file => ctx.execFile(file, option.args, option.execFileOptions, option.allowError !== false)));\r\n                        }\r\n                    } else {\r\n                        return Promise.reject('exec file task config error');\r\n                    }\r\n                });\r\n\r\n        });\r\n\r\n        this.info.taskName = tk;\r\n\r\n        return tk;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * custom dynamic task.\r\n *\r\n * @class DynamicTask\r\n * @implements {ITask}\r\n */\r\nclass DynamicTask implements ITask {\r\n    constructor(protected info: ITaskInfo, private factory: factory) {\r\n    }\r\n\r\n    /**\r\n     * get task info.\r\n     *\r\n     * @type {ITaskInfo}\r\n     * @memberOf PipeTask\r\n     */\r\n    public getInfo(): ITaskInfo {\r\n        return this.info;\r\n    }\r\n\r\n    setup(ctx: ITaskContext, gulp?: Gulp) {\r\n        let name = this.factory(ctx, this.getInfo(), gulp || coregulp);\r\n        if (name) {\r\n            this.info.taskName = name;\r\n        }\r\n        return name;\r\n    }\r\n}\r\n\r\n/**\r\n * pipe task for dynamic task.\r\n *\r\n * @class DynamicPipeTask\r\n * @extends {PipeTask}\r\n */\r\nclass DynamicPipeTask extends PipeTask {\r\n    constructor(private dt: IDynamicTaskOption, info?: ITaskInfo) {\r\n        super(info || dt);\r\n        this.info.assert = dt;\r\n    }\r\n\r\n    protected getOption(ctx: ITaskContext) {\r\n        this.name = this.name || ctx.toStr(this.dt.name);\r\n        return this.dt || ctx.option;\r\n    }\r\n\r\n    protected customPipe(source: ITransform, ctx: ITaskContext, dist: IAssertDist, gulp: Gulp) {\r\n        if (this.dt.pipe) {\r\n            return Promise.resolve(super.customPipe(source, ctx, dist, gulp))\r\n                .then(stream => this.cpipe2Promise(stream, this.dt, ctx, dist, gulp));\r\n        } else {\r\n            return super.customPipe(source, ctx, dist, gulp)\r\n        }\r\n    }\r\n\r\n    pipes(ctx: ITaskContext, dist: IAssertDist, gulp?: Gulp): IPipe[] {\r\n        let pipes = _.isFunction(this.dt.pipes) ? this.dt.pipes(ctx, dist, gulp) : this.dt.pipes;\r\n        pipes = pipes || [];\r\n        return pipes.concat(super.pipes(ctx, dist, gulp));\r\n    }\r\n\r\n    output(ctx: ITaskContext, dist: IAssertDist, gulp?: Gulp): IOutputPipe[] {\r\n        if (this.dt.output === null) {\r\n            return [stream => stream];\r\n        }\r\n        let outputs = _.isFunction(this.dt.output) ? this.dt.output(ctx, dist, gulp) : this.dt.output;\r\n        outputs = outputs || [];\r\n        return outputs.concat(super.output(ctx, dist, gulp));\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * dynamic build tasks.\r\n *\r\n * @export\r\n * @param {ITaskContext} ctx\r\n * @param {(IDynamicTaskOption | IDynamicTaskOption[])} tasks\r\n * @param {ITaskInfo} [match]\r\n * @returns {ITask[]}\r\n */\r\nexport function generateTask(ctx: ITaskContext, tasks: IDynamicTaskOption | IDynamicTaskOption[], match?: ITaskInfo): ITask[] {\r\n    let taskseq: ITask[] = [];\r\n    _.each(_.isArray(tasks) ? tasks : [tasks], dt => {\r\n        dt.oper = dt.oper ? ctx.to(dt.oper) : Operation.default;\r\n        if (dt.watchTasks) {\r\n            dt.oper = dt.oper | Operation.watch;\r\n        }\r\n\r\n        if (!matchCompare(ctx, dt, match)) {\r\n            return;\r\n        }\r\n\r\n        if (dt.watch && !(dt.oper & Operation.watch)) {\r\n            dt.oper = dt.oper | Operation.autoWatch;\r\n        }\r\n        taskseq.push(createTask(ctx, dt));\r\n\r\n    });\r\n\r\n    return taskseq;\r\n}\r\n\r\n/**\r\n * create task by dynamic option.\r\n *\r\n * @param {ITaskContext} ctx\r\n * @param {IDynamicTaskOption} dt\r\n * @returns {ITask}\r\n */\r\nfunction createTask(ctx: ITaskContext, dt: IDynamicTaskOption): ITask {\r\n    let task: ITask;\r\n    if (ctx.to(dt.oper) & Operation.watch) {\r\n        task = createWatchTask(dt);\r\n    } else if (dt.shell) {\r\n        task = new ShellTask(dt, dt.shell);\r\n    } else if (dt.execFiles) {\r\n        task = new ExecFileTask(dt, dt.execFiles);\r\n    } else if (_.isFunction(dt.task)) {\r\n        // custom task\r\n        task = createCustomTask(dt);\r\n    } else {\r\n        // pipe stream task.\r\n        task = createPipesTask(dt);\r\n    }\r\n    return task;\r\n}\r\n\r\n\r\n/**\r\n * create custom task.\r\n *\r\n * @param {IDynamicTaskOption} dt\r\n * @returns {ITask}\r\n */\r\nfunction createCustomTask(dt: IDynamicTaskOption): ITask {\r\n    let factory = (ctx: ITaskContext, info: ITaskInfo, gulp: Gulp) => {\r\n        let tk = ctx.taskName(info);\r\n        console.log('register custom dynamic task:', chalk.cyan(tk));\r\n        gulp.task(tk, () => {\r\n            return dt.task(ctx, dt, gulp);\r\n        });\r\n\r\n        return tk\r\n    };\r\n\r\n    return new DynamicTask({ name: dt.name, order: dt.order, oper: dt.oper, group: dt.group, assert: dt }, factory);\r\n}\r\n\r\n\r\n/**\r\n * create dynamic watch task.\r\n *\r\n * @export\r\n * @param {IDynamicTaskOption} dt\r\n * @returns {ITask}\r\n */\r\nfunction createWatchTask(dt: IDynamicTaskOption): ITask {\r\n    let factory = (ctx: ITaskContext, info: ITaskInfo, gulp: Gulp) => {\r\n        let watchs = _.isFunction(dt.watchTasks) ? dt.watchTasks(ctx, dt) : dt.watchTasks;\r\n        // if (!_.isFunction(_.last(watchs))) {\r\n        //     watchs.push(<WatchCallback>(event: WatchEvent) => {\r\n        //         dt.watchChanged && dt.watchChanged(event, ctx);\r\n        //     });\r\n        // }\r\n        let callback;\r\n        if (!_.isFunction(_.last(watchs))) {\r\n            callback = (event: WatchEvent) => {\r\n                dt.watchChanged && dt.watchChanged(event, ctx);\r\n            };\r\n        } else {\r\n            callback = watchs.pop();\r\n        }\r\n\r\n        watchs = _.map(watchs, w => {\r\n            if (_.isString(w)) {\r\n                return ctx.taskName(w);\r\n            }\r\n            return w;\r\n        })\r\n        let tk = ctx.taskName(info);\r\n        console.log('register watch  dynamic task:', chalk.cyan(tk));\r\n        gulp.task(tk, () => {\r\n            let src = ctx.getSrc(info);\r\n            console.log('watch, src:', chalk.cyan.call(chalk, src));\r\n            // watch(src, watchs);\r\n            watch(src, () => {\r\n                runSequence(gulp, <string[]>watchs)\r\n                    .then(() => {\r\n                        callback && callback();\r\n                    });\r\n            });\r\n        });\r\n\r\n        return tk;\r\n    };\r\n\r\n    return new DynamicTask({ name: dt.name, order: dt.order, oper: dt.oper, group: dt.group, assert: dt }, factory);\r\n}\r\n\r\n/**\r\n * create pipe task.\r\n *\r\n * @export\r\n * @param {IDynamicTaskOption} dt\r\n * @returns {ITask}\r\n */\r\nfunction createPipesTask(dt: IDynamicTaskOption): ITask {\r\n    return new DynamicPipeTask(dt);\r\n}\r\n"]}