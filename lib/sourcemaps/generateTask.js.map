{"version":3,"sources":["generateTask.js","generateTask.ts"],"names":["generateTask","tasks","match","ctx","taskseq","_","each","isArray","dt","watchTasks","oper","TaskConfig_1","Operation","default","watch","utils_1","matchCompare","autoWatch","push","createTask","task","createWatchTask","isFunction","createCustomTask","createPipesTask","factory","info","gulp","tk","subTaskName","console","log","chalk","cyan","DynamicTask","name","order","group","assert","watchs","callback","last","pop","event","watchChanged","map","w","isString","src","getSrc","call","taskSequence_1","runSequence","then","DynamicPipeTask","require","coregulp","PipeTask_1","_classCallCheck","this","getInfo","taskName","_this","_possibleConstructorReturn","__proto__","Object","getPrototypeOf","toStr","option","source","dist","_this2","pipe","Promise","resolve","_get","prototype","stream","cpipe2Promise","pipes","concat","output","outputs","PipeTask","exports"],"mappings":"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","file":"../generateTask.js","sourcesContent":["\"use strict\";\nconst _ = require('lodash');\nconst coregulp = require('gulp');\nconst chalk = require('chalk');\nconst TaskConfig_1 = require('./TaskConfig');\nconst utils_1 = require('./utils');\nconst PipeTask_1 = require('./PipeTask');\nconst taskSequence_1 = require('./taskSequence');\nconst watch = require('gulp-watch');\n/**\n * custom dynamic task.\n *\n * @class DynamicTask\n * @implements {ITask}\n */\nclass DynamicTask {\n    constructor(info, factory) {\n        this.info = info;\n        this.factory = factory;\n    }\n    /**\n     * get task info.\n     *\n     * @type {ITaskInfo}\n     * @memberOf PipeTask\n     */\n    getInfo() {\n        return this.info;\n    }\n    setup(ctx, gulp) {\n        let name = this.factory(ctx, this.getInfo(), gulp || coregulp);\n        if (name) {\n            this.info.taskName = name;\n        }\n        return name;\n    }\n}\n/**\n * pipe task for dynamic task.\n *\n * @class DynamicPipeTask\n * @extends {PipeTask}\n */\nclass DynamicPipeTask extends PipeTask_1.PipeTask {\n    constructor(dt, info) {\n        super(info || dt);\n        this.dt = dt;\n        this.info.assert = dt;\n    }\n    getOption(ctx) {\n        this.name = this.name || ctx.toStr(this.dt.name);\n        return this.dt || ctx.option;\n    }\n    customPipe(source, ctx, dist, gulp) {\n        if (this.dt.pipe) {\n            return Promise.resolve(super.customPipe(source, ctx, dist, gulp))\n                .then(stream => this.cpipe2Promise(stream, this.dt, ctx, dist, gulp));\n        }\n        else {\n            return super.customPipe(source, ctx, dist, gulp);\n        }\n    }\n    pipes(ctx, dist, gulp) {\n        let pipes = _.isFunction(this.dt.pipes) ? this.dt.pipes(ctx, dist, gulp) : this.dt.pipes;\n        pipes = pipes || [];\n        return pipes.concat(super.pipes(ctx, dist, gulp));\n    }\n    output(ctx, dist, gulp) {\n        if (this.dt.output === null) {\n            return [stream => stream];\n        }\n        let outputs = _.isFunction(this.dt.output) ? this.dt.output(ctx, dist, gulp) : this.dt.output;\n        outputs = outputs || [];\n        return outputs.concat(super.output(ctx, dist, gulp));\n    }\n}\n/**\n * dynamic build tasks.\n *\n * @export\n * @param {(IDynamicTaskOption | IDynamicTaskOption[])} tasks\n * @param {ITaskInfo} [match]\n * @param {ITaskContext} [ctx]\n * @returns {ITask[]}\n */\nfunction generateTask(tasks, match, ctx) {\n    let taskseq = [];\n    _.each(_.isArray(tasks) ? tasks : [tasks], dt => {\n        if (dt.watchTasks) {\n            dt.oper = (dt.oper || TaskConfig_1.Operation.default) | TaskConfig_1.Operation.watch;\n        }\n        if (!utils_1.matchCompare(dt, match, ctx)) {\n            return;\n        }\n        if (dt.watch && !(dt.oper & TaskConfig_1.Operation.watch)) {\n            dt.oper = dt.oper | TaskConfig_1.Operation.autoWatch;\n        }\n        taskseq.push(createTask(dt));\n    });\n    return taskseq;\n}\nexports.generateTask = generateTask;\n/**\n * create task by dynamic option.\n *\n * @export\n * @param {IDynamicTaskOption} dt\n * @returns {ITask}\n */\nfunction createTask(dt) {\n    let task;\n    if (dt.oper & TaskConfig_1.Operation.watch) {\n        task = createWatchTask(dt);\n    }\n    else if (_.isFunction(dt.task)) {\n        // custom task\n        task = createCustomTask(dt);\n    }\n    else {\n        // pipe stream task.\n        task = createPipesTask(dt);\n    }\n    return task;\n}\nexports.createTask = createTask;\n/**\n * create custom task.\n *\n * @param {IDynamicTaskOption} dt\n * @returns {ITask}\n */\nfunction createCustomTask(dt) {\n    let factory = (ctx, info, gulp) => {\n        let tk = ctx.subTaskName(info);\n        console.log('register custom dynamic task:', chalk.cyan(tk));\n        gulp.task(tk, () => {\n            return dt.task(ctx, dt, gulp);\n        });\n        return tk;\n    };\n    return new DynamicTask({ name: dt.name, order: dt.order, oper: dt.oper, group: dt.group, assert: dt }, factory);\n}\n/**\n * create dynamic watch task.\n *\n * @export\n * @param {IDynamicTaskOption} dt\n * @returns {ITask}\n */\nfunction createWatchTask(dt) {\n    let factory = (ctx, info, gulp) => {\n        let watchs = _.isFunction(dt.watchTasks) ? dt.watchTasks(ctx, dt) : dt.watchTasks;\n        // if (!_.isFunction(_.last(watchs))) {\n        //     watchs.push(<WatchCallback>(event: WatchEvent) => {\n        //         dt.watchChanged && dt.watchChanged(event, ctx);\n        //     });\n        // }\n        let callback;\n        if (!_.isFunction(_.last(watchs))) {\n            callback = (event) => {\n                dt.watchChanged && dt.watchChanged(event, ctx);\n            };\n        }\n        else {\n            callback = watchs.pop();\n        }\n        watchs = _.map(watchs, w => {\n            if (_.isString(w)) {\n                return ctx.subTaskName(w);\n            }\n            return w;\n        });\n        let tk = ctx.subTaskName(info);\n        console.log('register watch  dynamic task:', chalk.cyan(tk));\n        gulp.task(tk, () => {\n            let src = ctx.getSrc(info);\n            console.log('watch, src:', chalk.cyan.call(chalk, src));\n            // watch(src, watchs);\n            watch(src, () => {\n                taskSequence_1.runSequence(gulp, watchs)\n                    .then(() => {\n                    callback && callback();\n                });\n            });\n        });\n        return tk;\n    };\n    return new DynamicTask({ name: dt.name, order: dt.order, oper: dt.oper, group: dt.group, assert: dt }, factory);\n}\n/**\n * create pipe task.\n *\n * @export\n * @param {IDynamicTaskOption} dt\n * @returns {ITask}\n */\nfunction createPipesTask(dt) {\n    return new DynamicPipeTask(dt);\n}\n","import * as _ from 'lodash';\r\nimport { Gulp, WatchEvent } from 'gulp';\r\nimport * as coregulp from 'gulp';\r\nimport * as chalk from 'chalk';\r\n\r\nimport { IAssertDist, IOutputPipe, Operation, ITaskInfo, ITransform, TaskResult, IPipe, IDynamicTaskOption, ITaskContext, ITask } from './TaskConfig';\r\nimport { matchCompare } from './utils';\r\nimport { PipeTask } from './PipeTask';\r\nimport { runSequence } from './taskSequence';\r\n\r\nimport * as watch from 'gulp-watch';\r\n\r\ntype factory = (ctx: ITaskContext, info: ITaskInfo, gulp: Gulp) => TaskResult;\r\n/**\r\n * custom dynamic task.\r\n * \r\n * @class DynamicTask\r\n * @implements {ITask}\r\n */\r\nclass DynamicTask implements ITask {\r\n    constructor(protected info: ITaskInfo, private factory: factory) {\r\n    }\r\n\r\n    /**\r\n     * get task info.\r\n     * \r\n     * @type {ITaskInfo}\r\n     * @memberOf PipeTask\r\n     */\r\n    public getInfo(): ITaskInfo {\r\n        return this.info;\r\n    }\r\n\r\n    setup(ctx: ITaskContext, gulp?: Gulp) {\r\n        let name = this.factory(ctx, this.getInfo(), gulp || coregulp);\r\n        if (name) {\r\n            this.info.taskName = name;\r\n        }\r\n        return name;\r\n    }\r\n}\r\n\r\n/**\r\n * pipe task for dynamic task.\r\n * \r\n * @class DynamicPipeTask\r\n * @extends {PipeTask}\r\n */\r\nclass DynamicPipeTask extends PipeTask {\r\n    constructor(private dt: IDynamicTaskOption, info?: ITaskInfo) {\r\n        super(info || dt);\r\n        this.info.assert = dt;\r\n    }\r\n\r\n    protected getOption(ctx: ITaskContext) {\r\n        this.name = this.name || ctx.toStr(this.dt.name);\r\n        return this.dt || ctx.option;\r\n    }\r\n\r\n    protected customPipe(source: ITransform, ctx: ITaskContext, dist: IAssertDist, gulp: Gulp) {\r\n        if (this.dt.pipe) {\r\n            return Promise.resolve(super.customPipe(source, ctx, dist, gulp))\r\n                .then(stream => this.cpipe2Promise(stream, this.dt, ctx, dist, gulp));\r\n        } else {\r\n            return super.customPipe(source, ctx, dist, gulp)\r\n        }\r\n    }\r\n\r\n    pipes(ctx: ITaskContext, dist: IAssertDist, gulp?: Gulp): IPipe[] {\r\n        let pipes = _.isFunction(this.dt.pipes) ? this.dt.pipes(ctx, dist, gulp) : this.dt.pipes;\r\n        pipes = pipes || [];\r\n        return pipes.concat(super.pipes(ctx, dist, gulp));\r\n    }\r\n\r\n    output(ctx: ITaskContext, dist: IAssertDist, gulp?: Gulp): IOutputPipe[] {\r\n        if (this.dt.output === null) {\r\n            return [stream => stream];\r\n        }\r\n        let outputs = _.isFunction(this.dt.output) ? this.dt.output(ctx, dist, gulp) : this.dt.output;\r\n        outputs = outputs || [];\r\n        return outputs.concat(super.output(ctx, dist, gulp));\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * dynamic build tasks.\r\n * \r\n * @export\r\n * @param {(IDynamicTaskOption | IDynamicTaskOption[])} tasks\r\n * @param {ITaskInfo} [match]\r\n * @param {ITaskContext} [ctx]\r\n * @returns {ITask[]}\r\n */\r\nexport function generateTask(tasks: IDynamicTaskOption | IDynamicTaskOption[], match?: ITaskInfo, ctx?: ITaskContext): ITask[] {\r\n    let taskseq: ITask[] = [];\r\n    _.each(_.isArray(tasks) ? tasks : [tasks], dt => {\r\n\r\n        if (dt.watchTasks) {\r\n            dt.oper = (dt.oper || Operation.default) | Operation.watch;\r\n        }\r\n\r\n        if (!matchCompare(dt, match, ctx)) {\r\n            return;\r\n        }\r\n\r\n        if (dt.watch && !(dt.oper & Operation.watch)) {\r\n            dt.oper = dt.oper | Operation.autoWatch;\r\n        }\r\n        taskseq.push(createTask(dt));\r\n\r\n    });\r\n\r\n    return taskseq;\r\n}\r\n\r\n/**\r\n * create task by dynamic option.\r\n * \r\n * @export\r\n * @param {IDynamicTaskOption} dt\r\n * @returns {ITask}\r\n */\r\nexport function createTask(dt: IDynamicTaskOption): ITask {\r\n    let task: ITask;\r\n    if (dt.oper & Operation.watch) {\r\n        task = createWatchTask(dt);\r\n    } else if (_.isFunction(dt.task)) {\r\n        // custom task\r\n        task = createCustomTask(dt);\r\n    } else {\r\n        // pipe stream task.\r\n        task = createPipesTask(dt);\r\n    }\r\n    return task;\r\n}\r\n\r\n\r\n/**\r\n * create custom task.\r\n * \r\n * @param {IDynamicTaskOption} dt\r\n * @returns {ITask}\r\n */\r\nfunction createCustomTask(dt: IDynamicTaskOption): ITask {\r\n    let factory = (ctx: ITaskContext, info: ITaskInfo, gulp: Gulp) => {\r\n        let tk = ctx.subTaskName(info);\r\n        console.log('register custom dynamic task:', chalk.cyan(tk));\r\n        gulp.task(tk, () => {\r\n            return dt.task(ctx, dt, gulp);\r\n        });\r\n\r\n        return tk\r\n    };\r\n\r\n    return new DynamicTask({ name: dt.name, order: dt.order, oper: dt.oper, group: dt.group, assert: dt }, factory);\r\n}\r\n\r\n\r\n/**\r\n * create dynamic watch task.\r\n * \r\n * @export\r\n * @param {IDynamicTaskOption} dt\r\n * @returns {ITask}\r\n */\r\nfunction createWatchTask(dt: IDynamicTaskOption): ITask {\r\n    let factory = (ctx: ITaskContext, info: ITaskInfo, gulp: Gulp) => {\r\n        let watchs = _.isFunction(dt.watchTasks) ? dt.watchTasks(ctx, dt) : dt.watchTasks;\r\n        // if (!_.isFunction(_.last(watchs))) {\r\n        //     watchs.push(<WatchCallback>(event: WatchEvent) => {\r\n        //         dt.watchChanged && dt.watchChanged(event, ctx);\r\n        //     });\r\n        // }\r\n        let callback;\r\n        if (!_.isFunction(_.last(watchs))) {\r\n            callback = (event: WatchEvent) => {\r\n                dt.watchChanged && dt.watchChanged(event, ctx);\r\n            };\r\n        } else {\r\n            callback = watchs.pop();\r\n        }\r\n\r\n        watchs = _.map(watchs, w => {\r\n            if (_.isString(w)) {\r\n                return ctx.subTaskName(w);\r\n            }\r\n            return w;\r\n        })\r\n        let tk = ctx.subTaskName(info);\r\n        console.log('register watch  dynamic task:', chalk.cyan(tk));\r\n        gulp.task(tk, () => {\r\n            let src = ctx.getSrc(info);\r\n            console.log('watch, src:', chalk.cyan.call(chalk, src));\r\n            // watch(src, watchs);\r\n            watch(src, () => {\r\n                runSequence(gulp, <string[]>watchs)\r\n                    .then(() => {\r\n                        callback && callback();\r\n                    });\r\n            });\r\n        });\r\n\r\n        return tk;\r\n    };\r\n\r\n    return new DynamicTask({ name: dt.name, order: dt.order, oper: dt.oper, group: dt.group, assert: dt }, factory);\r\n}\r\n\r\n/**\r\n * create pipe task.\r\n * \r\n * @export\r\n * @param {IDynamicTaskOption} dt\r\n * @returns {ITask}\r\n */\r\nfunction createPipesTask(dt: IDynamicTaskOption): ITask {\r\n    return new DynamicPipeTask(dt);\r\n}\r\n"]}