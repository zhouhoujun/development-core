{"version":3,"sources":["generateTask.js","generateTask.ts"],"names":["generateTask","tasks","match","taskseq","_","each","isArray","dt","oper","group","watchTasks","watch","push","createWatchTask","isFunction","task","createTask","createPipesTask","factory","cfg","gulp","tk","subTaskName","name","console","log","chalk","cyan","DynamicTask","order","watchs","last","event","watchChanged","map","w","isString","call","option","src","getSrc","taskPromise","Promise","resolve","pipes","then","psrc","all","p","streams","stream","pipe","reject","err","output","outputs","once","dest","getDist","catch","red","process","exit","require","coregulp","decorator","_classCallCheck","this","config","taskName","exports"],"mappings":"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","file":"../generateTask.js","sourcesContent":["\"use strict\";\nconst _ = require('lodash');\nconst coregulp = require('gulp');\nconst chalk = require('chalk');\nclass DynamicTask {\n    constructor(decorator, factory) {\n        this.decorator = decorator;\n        this.factory = factory;\n    }\n    setup(config, gulp) {\n        let name = this.factory(config, gulp || coregulp);\n        if (name) {\n            this.decorator.taskName = name;\n        }\n        return name;\n    }\n}\nfunction generateTask(tasks, match) {\n    let taskseq = [];\n    _.each(_.isArray(tasks) ? tasks : [tasks], dt => {\n        if (match) {\n            if (match.oper && dt.oper && (dt.oper & match.oper) <= 0) {\n                return;\n            }\n            if (match.group && dt.group !== match.group) {\n                return;\n            }\n        }\n        if (dt.watchTasks) {\n            dt.watch = dt.watch || !!dt.watchTasks;\n        }\n        if (dt.watch) {\n            if (!match || !match.watch) {\n                return;\n            }\n            if (dt.watch === match.watch) {\n                taskseq.push(createWatchTask(dt));\n            }\n        }\n        else if (_.isFunction(dt.task)) {\n            taskseq.push(createTask(dt));\n        }\n        else {\n            taskseq.push(createPipesTask(dt));\n        }\n    });\n    return taskseq;\n}\nexports.generateTask = generateTask;\nfunction createTask(dt) {\n    let factory = (cfg, gulp) => {\n        let tk = cfg.subTaskName(dt.name);\n        console.log('register custom dynamic task:', chalk.cyan(tk));\n        gulp.task(tk, () => {\n            return dt.task(cfg, dt, gulp);\n        });\n        return tk;\n    };\n    return new DynamicTask({ order: dt.order, oper: dt.oper, watch: dt.watch }, factory);\n}\nfunction createWatchTask(dt) {\n    let factory = (cfg, gulp) => {\n        let watchs = _.isFunction(dt.watchTasks) ? dt.watchTasks(cfg) : dt.watchTasks;\n        if (!_.isFunction(_.last(watchs))) {\n            watchs.push((event) => {\n                dt.watchChanged && dt.watchChanged(event, cfg);\n            });\n        }\n        watchs = _.map(watchs, w => {\n            if (_.isString(w)) {\n                return cfg.subTaskName(w);\n            }\n            return w;\n        });\n        let tk = cfg.subTaskName(dt);\n        console.log('register watch  dynamic task:', chalk.cyan(tk));\n        gulp.task(tk, () => {\n            console.log('watch, src:', chalk.cyan.call(chalk, cfg.option.src));\n            gulp.watch(cfg.getSrc(dt), watchs);\n        });\n        return tk;\n    };\n    return new DynamicTask({ order: dt.order, oper: dt.oper, watch: dt.watch }, factory);\n}\nfunction createPipesTask(dt) {\n    let factory = (cfg, gulp) => {\n        let tk = cfg.subTaskName(dt);\n        console.log('register pipes  dynamic task:', chalk.cyan(tk));\n        gulp.task(tk, () => {\n            let taskPromise = Promise.resolve(gulp.src(cfg.getSrc(dt)));\n            if (dt.pipes) {\n                let pipes = _.isFunction(dt.pipes) ? dt.pipes(cfg, dt, gulp) : dt.pipes;\n                taskPromise = taskPromise.then(psrc => {\n                    return Promise.all(_.map(pipes, (p) => {\n                        return _.isFunction(p) ? p(cfg, dt, gulp) : p;\n                    }))\n                        .then(streams => {\n                        _.each(streams, stream => {\n                            psrc = psrc.pipe(stream);\n                        });\n                        return psrc;\n                    });\n                });\n            }\n            else if (dt.pipe) {\n                taskPromise = taskPromise.then((stream => {\n                    return new Promise((resolve, reject) => {\n                        return dt.pipe(stream, cfg, dt, (err) => {\n                            if (err) {\n                                reject(err);\n                            }\n                            else {\n                                resolve(stream);\n                            }\n                        });\n                    });\n                }));\n            }\n            if (dt.output !== null) {\n                taskPromise = taskPromise.then(stream => {\n                    if (dt.output) {\n                        let outputs = _.isFunction(dt.output) ? dt.output(cfg, dt) : dt.output;\n                        return Promise.all(_.map(outputs, output => {\n                            return Promise.resolve((_.isFunction(output) ? output(stream, cfg, dt, gulp) : output))\n                                .then(output => {\n                                return new Promise((resolve, reject) => {\n                                    output\n                                        .once('end', () => {\n                                        resolve(output);\n                                    })\n                                        .once('error', reject);\n                                });\n                            });\n                        }));\n                    }\n                    else {\n                        return new Promise((resolve, reject) => {\n                            let output = gulp.dest(cfg.getDist(dt));\n                            stream.pipe(output)\n                                .once('end', () => {\n                                resolve(output);\n                            })\n                                .once('error', reject);\n                        });\n                    }\n                });\n            }\n            else {\n                taskPromise = taskPromise.then(stream => {\n                    return new Promise((resolve, reject) => {\n                        stream\n                            .once('end', () => {\n                            resolve(stream);\n                        })\n                            .once('error', reject);\n                    });\n                });\n            }\n            return taskPromise.catch(err => {\n                console.log(chalk.red(err));\n                process.exit(0);\n            });\n        });\n        return tk;\n    };\n    return new DynamicTask({ order: dt.order, oper: dt.oper, watch: !!dt.watch }, factory);\n}\n","import * as _ from 'lodash';\r\nimport { Gulp, WatchEvent } from 'gulp';\r\nimport * as coregulp from 'gulp';\r\nimport * as chalk from 'chalk';\r\n\r\nimport { ITaskInfo, TaskResult, Pipe, IDynamicTask, IEnvOption, Operation, ITaskConfig, ITask } from './TaskConfig';\r\n\r\ntype factory = (config: ITaskConfig, gulp: Gulp) => TaskResult;\r\nclass DynamicTask implements ITask {\r\n    constructor(public decorator: ITaskInfo, private factory: factory) {\r\n    }\r\n    setup(config: ITaskConfig, gulp?: Gulp) {\r\n        let name = this.factory(config, gulp || coregulp);\r\n        if (name) {\r\n            this.decorator.taskName = name;\r\n        }\r\n        return name;\r\n    }\r\n}\r\n\r\n/**\r\n * dynamic build tasks.\r\n * \r\n * @export\r\n * @param {(IDynamicTask | IDynamicTask[])} tasks\r\n * @param {ITaskInfo} [match]\r\n * @returns {ITask[]}\r\n */\r\nexport function generateTask(tasks: IDynamicTask | IDynamicTask[], match?: ITaskInfo): ITask[] {\r\n    let taskseq: ITask[] = [];\r\n    _.each(_.isArray(tasks) ? tasks : [tasks], dt => {\r\n        if (match) {\r\n            if (match.oper && dt.oper && (dt.oper & match.oper) <= 0) {\r\n                return;\r\n            }\r\n\r\n            if (match.group && dt.group !== match.group) {\r\n                return;\r\n            }\r\n        }\r\n        if (dt.watchTasks) {\r\n            dt.watch = dt.watch || !!dt.watchTasks;\r\n        }\r\n\r\n        if (dt.watch) {\r\n            if (!match || !match.watch) {\r\n                return;\r\n            }\r\n            if (dt.watch === match.watch) {\r\n                taskseq.push(createWatchTask(dt));\r\n            }\r\n        } else if (_.isFunction(dt.task)) {\r\n            // custom task\r\n            taskseq.push(createTask(dt));\r\n        } else {\r\n            // pipe stream task.\r\n            taskseq.push(createPipesTask(dt));\r\n        }\r\n    });\r\n\r\n    return taskseq;\r\n}\r\n\r\n\r\n\r\n/**\r\n * promise task.\r\n * \r\n * @param {DynamicTask} dt\r\n * @returns\r\n */\r\nfunction createTask(dt: IDynamicTask) {\r\n    let factory = (cfg: ITaskConfig, gulp: Gulp) => {\r\n        let tk = cfg.subTaskName(dt.name);\r\n        console.log('register custom dynamic task:', chalk.cyan(tk));\r\n        gulp.task(tk, () => {\r\n            return dt.task(cfg, dt, gulp);\r\n        });\r\n\r\n        return tk\r\n    };\r\n\r\n    return new DynamicTask({ order: dt.order, oper: dt.oper, watch: dt.watch }, factory);\r\n}\r\n/**\r\n * create dynamic watch task.\r\n * \r\n * @param {DynamicTask} dt\r\n * @returns\r\n */\r\nfunction createWatchTask(dt: IDynamicTask) {\r\n    let factory = (cfg: ITaskConfig, gulp: Gulp) => {\r\n        let watchs = _.isFunction(dt.watchTasks) ? dt.watchTasks(cfg) : dt.watchTasks;\r\n        if (!_.isFunction(_.last(watchs))) {\r\n            watchs.push(<WatchCallback>(event: WatchEvent) => {\r\n                dt.watchChanged && dt.watchChanged(event, cfg);\r\n            });\r\n        }\r\n        watchs = _.map(watchs, w => {\r\n            if (_.isString(w)) {\r\n                return cfg.subTaskName(w);\r\n            }\r\n            return w;\r\n        })\r\n        let tk = cfg.subTaskName(dt);\r\n        console.log('register watch  dynamic task:', chalk.cyan(tk));\r\n        gulp.task(tk, () => {\r\n            console.log('watch, src:', chalk.cyan.call(chalk, cfg.option.src));\r\n            gulp.watch(cfg.getSrc(dt), watchs)\r\n        });\r\n\r\n        return tk;\r\n    };\r\n\r\n    return new DynamicTask({ order: dt.order, oper: dt.oper, watch: dt.watch }, factory);\r\n}\r\nfunction createPipesTask(dt: IDynamicTask) {\r\n    let factory = (cfg: ITaskConfig, gulp: Gulp) => {\r\n\r\n        let tk = cfg.subTaskName(dt);\r\n        console.log('register pipes  dynamic task:', chalk.cyan(tk));\r\n        gulp.task(tk, () => {\r\n            let taskPromise = Promise.resolve(gulp.src(cfg.getSrc(dt)));\r\n            if (dt.pipes) {\r\n                let pipes = _.isFunction(dt.pipes) ? dt.pipes(cfg, dt, gulp) : dt.pipes;\r\n                taskPromise = taskPromise.then(psrc => {\r\n                    return Promise.all(_.map(pipes, (p: Pipe) => {\r\n                        return _.isFunction(p) ? p(cfg, dt, gulp) : p;\r\n                    }))\r\n                        .then(streams => {\r\n                            _.each(streams, stream => {\r\n                                psrc = psrc.pipe(stream);\r\n                            });\r\n                            return psrc;\r\n                        })\r\n                });\r\n\r\n            } else if (dt.pipe) {\r\n                taskPromise = taskPromise.then((stream => {\r\n                    return new Promise((resolve, reject) => {\r\n                        return dt.pipe(stream, cfg, dt, (err) => {\r\n                            if (err) {\r\n                                reject(err);\r\n                            } else {\r\n                                resolve(stream);\r\n                            }\r\n                        });\r\n                    });\r\n                }));\r\n            }\r\n\r\n            if (dt.output !== null) {\r\n                taskPromise = taskPromise.then(stream => {\r\n                    if (dt.output) {\r\n                        let outputs = _.isFunction(dt.output) ? dt.output(cfg, dt) : dt.output;\r\n                        return Promise.all(_.map(outputs, output => {\r\n                            return Promise.resolve<NodeJS.ReadWriteStream>((_.isFunction(output) ? output(stream, cfg, dt, gulp) : output))\r\n                                .then(output => {\r\n                                    return new Promise((resolve, reject) => {\r\n                                        output\r\n                                            .once('end', () => {\r\n                                                resolve(output);\r\n                                            })\r\n                                            .once('error', reject);\r\n                                    });\r\n                                });\r\n                        }));\r\n                    } else {\r\n                        return new Promise((resolve, reject) => {\r\n                            let output = gulp.dest(cfg.getDist(dt));\r\n                            stream.pipe(output)\r\n                                .once('end', () => {\r\n                                    resolve(output)\r\n                                })\r\n                                .once('error', reject);\r\n                        });\r\n                    }\r\n                });\r\n            } else {\r\n                taskPromise = taskPromise.then(stream => {\r\n                    return new Promise((resolve, reject) => {\r\n                        stream\r\n                            .once('end', () => {\r\n                                resolve(stream);\r\n                            })\r\n                            .once('error', reject);\r\n                    });\r\n                });\r\n            }\r\n\r\n            // return taskPromise;\r\n            return taskPromise.catch(err => {\r\n                console.log(chalk.red(err));\r\n                process.exit(0);\r\n            });\r\n        });\r\n\r\n        return tk;\r\n    }\r\n\r\n    return new DynamicTask({ order: dt.order, oper: dt.oper, watch: !!dt.watch }, factory);\r\n}\r\n\r\n\r\n"]}