{"version":3,"sources":["generateTask.js","generateTask.ts"],"names":["_","require","coregulp","chalk","TaskConfig_1","utils_1","PipeTask_1","DynamicTask","info","factory","config","gulp","name","taskName","DynamicPipeTask","dt","assert","ctx","taskStringVal","oper","env","option","source","dist","pipe","Promise","resolve","then","cpipe2Promise","stream","pipes","isFunction","concat","output","outputs","PipeTask","generateTask","tasks","match","taskseq","each","isArray","watchTasks","Operation","default","watch","matchTaskInfo","matchTaskGroup","push","createTask","createWatchTask","defaultWatch","exports","task","createCustomTask","createPipesTask","cfg","tk","subTaskName","console","log","cyan","order","group","watchs","last","event","watchChanged","map","isString","w","src","getSrc","call"],"mappings":"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","file":"../generateTask.js","sourcesContent":["\"use strict\";\nconst _ = require('lodash');\nconst coregulp = require('gulp');\nconst chalk = require('chalk');\nconst TaskConfig_1 = require('./TaskConfig');\nconst utils_1 = require('./utils');\nconst PipeTask_1 = require('./PipeTask');\n/**\n * custom dynamic task.\n *\n * @class DynamicTask\n * @implements {ITask}\n */\nclass DynamicTask {\n    constructor(info, factory) {\n        this.info = info;\n        this.factory = factory;\n    }\n    /**\n     * get task info.\n     *\n     * @type {ITaskInfo}\n     * @memberOf PipeTask\n     */\n    getInfo() {\n        return this.info;\n    }\n    setup(config, gulp) {\n        let name = this.factory(config, gulp || coregulp);\n        if (name) {\n            this.info.taskName = name;\n        }\n        return name;\n    }\n}\n/**\n * pipe task for dynamic task.\n *\n * @class DynamicPipeTask\n * @extends {PipeTask}\n */\nclass DynamicPipeTask extends PipeTask_1.PipeTask {\n    constructor(dt, info) {\n        super(info || dt);\n        this.dt = dt;\n        this.info.assert = dt;\n    }\n    getOption(ctx) {\n        this.name = this.name || utils_1.taskStringVal(this.dt.name, ctx.oper, ctx.env);\n        return this.dt || ctx.option;\n    }\n    customPipe(source, ctx, dist, gulp) {\n        if (this.dt.pipe) {\n            return Promise.resolve(super.customPipe(source, ctx, dist, gulp))\n                .then(stream => this.cpipe2Promise(stream, this.dt, ctx, dist, gulp));\n        }\n        else {\n            return super.customPipe(source, ctx, dist, gulp);\n        }\n    }\n    pipes(ctx, dist, gulp) {\n        let pipes = _.isFunction(this.dt.pipes) ? this.dt.pipes(ctx, dist, gulp) : this.dt.pipes;\n        pipes = pipes || [];\n        return pipes.concat(super.pipes(ctx, dist, gulp));\n    }\n    output(ctx, dist, gulp) {\n        if (this.dt.output === null) {\n            return [stream => stream];\n        }\n        let outputs = _.isFunction(this.dt.output) ? this.dt.output(ctx, dist, gulp) : this.dt.output;\n        outputs = outputs || [];\n        return outputs.concat(super.output(ctx, dist, gulp));\n    }\n}\n/**\n * dynamic build tasks.\n *\n * @export\n * @param {(IDynamicTaskOption | IDynamicTaskOption[])} tasks\n * @param {ITaskInfo} [match]\n * @returns {ITask[]}\n */\nfunction generateTask(tasks, match) {\n    let taskseq = [];\n    _.each(_.isArray(tasks) ? tasks : [tasks], dt => {\n        if (dt.watchTasks) {\n            dt.oper = (dt.oper || TaskConfig_1.Operation.default) | TaskConfig_1.Operation.watch;\n        }\n        if (!utils_1.matchTaskInfo(dt, match)) {\n            return;\n        }\n        if (!utils_1.matchTaskGroup(dt, match)) {\n            return;\n        }\n        taskseq.push(createTask(dt));\n        if (dt.watch && match && (match.oper & TaskConfig_1.Operation.watch)) {\n            taskseq.push(createWatchTask({\n                oper: TaskConfig_1.Operation.defaultWatch,\n                name: (oper, env) => utils_1.taskStringVal(dt.name, oper, env) + '-watch',\n                watchTasks: (ctx) => [utils_1.taskStringVal(dt.name, ctx.oper, ctx.env)]\n            }));\n        }\n    });\n    return taskseq;\n}\nexports.generateTask = generateTask;\n/**\n * create task by dynamic option.\n *\n * @export\n * @param {IDynamicTaskOption} dt\n * @returns {ITask}\n */\nfunction createTask(dt) {\n    let task;\n    if (dt.oper & TaskConfig_1.Operation.watch) {\n        task = createWatchTask(dt);\n    }\n    else if (_.isFunction(dt.task)) {\n        // custom task\n        task = createCustomTask(dt);\n    }\n    else {\n        // pipe stream task.\n        task = createPipesTask(dt);\n    }\n    return task;\n}\nexports.createTask = createTask;\n/**\n * create custom task.\n *\n * @param {IDynamicTaskOption} dt\n * @returns {ITask}\n */\nfunction createCustomTask(dt) {\n    let factory = (cfg, gulp) => {\n        let tk = cfg.subTaskName(dt);\n        console.log('register custom dynamic task:', chalk.cyan(tk));\n        gulp.task(tk, () => {\n            return dt.task(cfg, dt, gulp);\n        });\n        return tk;\n    };\n    return new DynamicTask({ order: dt.order, oper: dt.oper, group: dt.group, assert: dt }, factory);\n}\n/**\n * create dynamic watch task.\n *\n * @export\n * @param {IDynamicTaskOption} dt\n * @returns {ITask}\n */\nfunction createWatchTask(dt) {\n    let factory = (ctx, gulp) => {\n        let watchs = _.isFunction(dt.watchTasks) ? dt.watchTasks(ctx, dt) : dt.watchTasks;\n        if (!_.isFunction(_.last(watchs))) {\n            watchs.push((event) => {\n                dt.watchChanged && dt.watchChanged(event, ctx);\n            });\n        }\n        watchs = _.map(watchs, w => {\n            if (_.isString(w)) {\n                return ctx.subTaskName(w);\n            }\n            return w;\n        });\n        let tk = ctx.subTaskName(dt);\n        console.log('register watch  dynamic task:', chalk.cyan(tk));\n        gulp.task(tk, () => {\n            let src = ctx.getSrc(dt);\n            console.log('watch, src:', chalk.cyan.call(chalk, src));\n            gulp.watch(src, watchs);\n        });\n        return tk;\n    };\n    return new DynamicTask({ order: dt.order, oper: dt.oper, group: dt.group, assert: dt }, factory);\n}\n/**\n * create pipe task.\n *\n * @export\n * @param {IDynamicTaskOption} dt\n * @returns {ITask}\n */\nfunction createPipesTask(dt) {\n    return new DynamicPipeTask(dt);\n}\n","import * as _ from 'lodash';\r\nimport { Gulp, WatchEvent } from 'gulp';\r\nimport * as coregulp from 'gulp';\r\nimport * as chalk from 'chalk';\r\n\r\nimport { IAssertDist, IOutputPipe, Operation, ITaskInfo, ITransform, TaskResult, IPipe, IDynamicTaskOption, ITaskContext, ITask } from './TaskConfig';\r\nimport { matchTaskGroup, matchTaskInfo, taskStringVal, taskSourceVal } from './utils';\r\nimport { PipeTask } from './PipeTask';\r\n\r\ntype factory = (config: ITaskContext, gulp: Gulp) => TaskResult;\r\n/**\r\n * custom dynamic task.\r\n * \r\n * @class DynamicTask\r\n * @implements {ITask}\r\n */\r\nclass DynamicTask implements ITask {\r\n    constructor(protected info: ITaskInfo, private factory: factory) {\r\n    }\r\n\r\n    /**\r\n     * get task info.\r\n     * \r\n     * @type {ITaskInfo}\r\n     * @memberOf PipeTask\r\n     */\r\n    public getInfo(): ITaskInfo {\r\n        return this.info;\r\n    }\r\n\r\n    setup(config: ITaskContext, gulp?: Gulp) {\r\n        let name = this.factory(config, gulp || coregulp);\r\n        if (name) {\r\n            this.info.taskName = name;\r\n        }\r\n        return name;\r\n    }\r\n}\r\n\r\n/**\r\n * pipe task for dynamic task.\r\n * \r\n * @class DynamicPipeTask\r\n * @extends {PipeTask}\r\n */\r\nclass DynamicPipeTask extends PipeTask {\r\n    constructor(private dt: IDynamicTaskOption, info?: ITaskInfo) {\r\n        super(info || dt);\r\n        this.info.assert = dt;\r\n    }\r\n\r\n    protected getOption(ctx: ITaskContext) {\r\n        this.name = this.name || taskStringVal(this.dt.name, ctx.oper, ctx.env);\r\n        return this.dt || ctx.option;\r\n    }\r\n\r\n    protected customPipe(source: ITransform, ctx: ITaskContext, dist: IAssertDist, gulp: Gulp) {\r\n        if (this.dt.pipe) {\r\n            return Promise.resolve(super.customPipe(source, ctx, dist, gulp))\r\n                .then(stream => this.cpipe2Promise(stream, this.dt, ctx, dist, gulp));\r\n        } else {\r\n            return super.customPipe(source, ctx, dist, gulp)\r\n        }\r\n    }\r\n\r\n    pipes(ctx: ITaskContext, dist: IAssertDist, gulp?: Gulp): IPipe[] {\r\n        let pipes = _.isFunction(this.dt.pipes) ? this.dt.pipes(ctx, dist, gulp) : this.dt.pipes;\r\n        pipes = pipes || [];\r\n        return pipes.concat(super.pipes(ctx, dist, gulp));\r\n    }\r\n\r\n    output(ctx: ITaskContext, dist: IAssertDist, gulp?: Gulp): IOutputPipe[] {\r\n        if (this.dt.output === null) {\r\n            return [stream => stream];\r\n        }\r\n        let outputs = _.isFunction(this.dt.output) ? this.dt.output(ctx, dist, gulp) : this.dt.output;\r\n        outputs = outputs || [];\r\n        return outputs.concat(super.output(ctx, dist, gulp));\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * dynamic build tasks.\r\n * \r\n * @export\r\n * @param {(IDynamicTaskOption | IDynamicTaskOption[])} tasks\r\n * @param {ITaskInfo} [match]\r\n * @returns {ITask[]}\r\n */\r\nexport function generateTask(tasks: IDynamicTaskOption | IDynamicTaskOption[], match?: ITaskInfo): ITask[] {\r\n    let taskseq: ITask[] = [];\r\n    _.each(_.isArray(tasks) ? tasks : [tasks], dt => {\r\n\r\n        if (dt.watchTasks) {\r\n            dt.oper = (dt.oper || Operation.default) | Operation.watch;\r\n        }\r\n        if (!matchTaskInfo(dt, match)) {\r\n            return;\r\n        }\r\n\r\n        if (!matchTaskGroup(dt, match)) {\r\n            return;\r\n        }\r\n\r\n        taskseq.push(createTask(dt));\r\n        if (dt.watch && match && (match.oper & Operation.watch)) {\r\n            taskseq.push(createWatchTask({\r\n                oper: Operation.defaultWatch,\r\n                name: (oper, env) => taskStringVal(dt.name, oper, env) + '-watch',\r\n                watchTasks: (ctx) => [taskStringVal(dt.name, ctx.oper, ctx.env)]\r\n            }));\r\n        }\r\n    });\r\n\r\n    return taskseq;\r\n}\r\n\r\n/**\r\n * create task by dynamic option.\r\n * \r\n * @export\r\n * @param {IDynamicTaskOption} dt\r\n * @returns {ITask}\r\n */\r\nexport function createTask(dt: IDynamicTaskOption): ITask {\r\n    let task: ITask;\r\n    if (dt.oper & Operation.watch) {\r\n        task = createWatchTask(dt);\r\n    } else if (_.isFunction(dt.task)) {\r\n        // custom task\r\n        task = createCustomTask(dt);\r\n    } else {\r\n        // pipe stream task.\r\n        task = createPipesTask(dt);\r\n    }\r\n    return task;\r\n}\r\n\r\n\r\n/**\r\n * create custom task.\r\n * \r\n * @param {IDynamicTaskOption} dt\r\n * @returns {ITask}\r\n */\r\nfunction createCustomTask(dt: IDynamicTaskOption): ITask {\r\n    let factory = (cfg: ITaskContext, gulp: Gulp) => {\r\n        let tk = cfg.subTaskName(dt);\r\n        console.log('register custom dynamic task:', chalk.cyan(tk));\r\n        gulp.task(tk, () => {\r\n            return dt.task(cfg, dt, gulp);\r\n        });\r\n\r\n        return tk\r\n    };\r\n\r\n    return new DynamicTask({ order: dt.order, oper: dt.oper, group: dt.group, assert: dt }, factory);\r\n}\r\n\r\n\r\n/**\r\n * create dynamic watch task.\r\n * \r\n * @export\r\n * @param {IDynamicTaskOption} dt\r\n * @returns {ITask}\r\n */\r\nfunction createWatchTask(dt: IDynamicTaskOption): ITask {\r\n    let factory = (ctx: ITaskContext, gulp: Gulp) => {\r\n        let watchs = _.isFunction(dt.watchTasks) ? dt.watchTasks(ctx, dt) : dt.watchTasks;\r\n        if (!_.isFunction(_.last(watchs))) {\r\n            watchs.push(<WatchCallback>(event: WatchEvent) => {\r\n                dt.watchChanged && dt.watchChanged(event, ctx);\r\n            });\r\n        }\r\n        watchs = _.map(watchs, w => {\r\n            if (_.isString(w)) {\r\n                return ctx.subTaskName(w);\r\n            }\r\n            return w;\r\n        })\r\n        let tk = ctx.subTaskName(dt);\r\n        console.log('register watch  dynamic task:', chalk.cyan(tk));\r\n        gulp.task(tk, () => {\r\n            let src = ctx.getSrc(dt);\r\n            console.log('watch, src:', chalk.cyan.call(chalk, src));\r\n            gulp.watch(src, watchs)\r\n        });\r\n\r\n        return tk;\r\n    };\r\n\r\n    return new DynamicTask({ order: dt.order, oper: dt.oper, group: dt.group, assert: dt }, factory);\r\n}\r\n\r\n/**\r\n * create pipe task.\r\n * \r\n * @export\r\n * @param {IDynamicTaskOption} dt\r\n * @returns {ITask}\r\n */\r\nfunction createPipesTask(dt: IDynamicTaskOption): ITask {\r\n    return new DynamicPipeTask(dt);\r\n}\r\n"]}