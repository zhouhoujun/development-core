{"version":3,"sources":["generateTask.js","generateTask.ts"],"names":["generateTask","tasks","match","taskseq","_","each","isArray","dt","watchTasks","oper","TaskConfig_1","Operation","default","watch","utils_1","matchTaskInfo","matchTaskGroup","push","createWatchTask","isFunction","task","createTask","createPipesTask","factory","cfg","gulp","tk","subTaskName","name","console","log","chalk","cyan","DynamicTask","order","group","assert","watchs","last","event","watchChanged","map","w","isString","src","getSrc","call","DynamicPipeTask","require","coregulp","PipeTask_1","decorator","_classCallCheck","this","config","taskName","info","_this","_possibleConstructorReturn","__proto__","Object","getPrototypeOf","taskStringVal","option","source","dist","_this2","pipe","Promise","resolve","_get","prototype","then","stream","cpipe2Promise","pipes","concat","output","outputs","PipeTask","exports"],"mappings":"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","file":"../generateTask.js","sourcesContent":["\"use strict\";\nconst _ = require('lodash');\nconst coregulp = require('gulp');\nconst chalk = require('chalk');\nconst TaskConfig_1 = require('./TaskConfig');\nconst utils_1 = require('./utils');\nconst PipeTask_1 = require('./PipeTask');\nclass DynamicTask {\n    constructor(decorator, factory) {\n        this.decorator = decorator;\n        this.factory = factory;\n    }\n    setup(config, gulp) {\n        let name = this.factory(config, gulp || coregulp);\n        if (name) {\n            this.decorator.taskName = name;\n        }\n        return name;\n    }\n}\nclass DynamicPipeTask extends PipeTask_1.PipeTask {\n    constructor(dt, info) {\n        super(info);\n        this.dt = dt;\n        this.decorator = info || dt;\n        this.decorator.assert = dt;\n    }\n    getOption(config) {\n        this.name = this.name || utils_1.taskStringVal(this.dt.name, config.oper);\n        return this.dt || config.option;\n    }\n    customPipe(source, config, dist, gulp) {\n        if (this.dt.pipe) {\n            return Promise.resolve(super.customPipe(source, config, dist, gulp))\n                .then(stream => this.cpipe2Promise(stream, this.dt, config, dist, gulp));\n        }\n        else {\n            return super.customPipe(source, config, dist, gulp);\n        }\n    }\n    pipes(config, dist, gulp) {\n        let pipes = _.isFunction(this.dt.pipes) ? this.dt.pipes(config, dist, gulp) : this.dt.pipes;\n        pipes = pipes || [];\n        return pipes.concat(super.pipes(config, dist, gulp));\n    }\n    output(config, dist, gulp) {\n        if (this.dt.output === null) {\n            return [stream => stream];\n        }\n        let outputs = _.isFunction(this.dt.output) ? this.dt.output(config, dist, gulp) : this.dt.output;\n        outputs = outputs || [];\n        return outputs.concat(super.output(config, dist, gulp));\n    }\n}\n/**\n * dynamic build tasks.\n *\n * @export\n * @param {(IDynamicTaskOption | IDynamicTaskOption[])} tasks\n * @param {ITaskInfo} [match]\n * @returns {ITask[]}\n */\nfunction generateTask(tasks, match) {\n    let taskseq = [];\n    _.each(_.isArray(tasks) ? tasks : [tasks], dt => {\n        if (dt.watchTasks) {\n            dt.oper = (dt.oper || TaskConfig_1.Operation.default) | TaskConfig_1.Operation.watch;\n        }\n        if (!utils_1.matchTaskInfo(dt, match)) {\n            return;\n        }\n        if (!utils_1.matchTaskGroup(dt, match)) {\n            return;\n        }\n        if ((dt.oper & TaskConfig_1.Operation.watch) > 0) {\n            taskseq.push(createWatchTask(dt));\n        }\n        else if (_.isFunction(dt.task)) {\n            // custom task\n            taskseq.push(createTask(dt));\n        }\n        else {\n            // pipe stream task.\n            taskseq.push(createPipesTask(dt));\n        }\n    });\n    return taskseq;\n}\nexports.generateTask = generateTask;\n/**\n * promise task.\n *\n * @param {DynamicTask} dt\n * @returns\n */\nfunction createTask(dt) {\n    let factory = (cfg, gulp) => {\n        let tk = cfg.subTaskName(dt.name);\n        console.log('register custom dynamic task:', chalk.cyan(tk));\n        gulp.task(tk, () => {\n            return dt.task(cfg, dt, gulp);\n        });\n        return tk;\n    };\n    return new DynamicTask({ order: dt.order, oper: dt.oper, watch: dt.watch, group: dt.group, assert: dt }, factory);\n}\n/**\n * create dynamic watch task.\n *\n * @param {DynamicTask} dt\n * @returns\n */\nfunction createWatchTask(dt) {\n    let factory = (cfg, gulp) => {\n        let watchs = _.isFunction(dt.watchTasks) ? dt.watchTasks(cfg) : dt.watchTasks;\n        if (!_.isFunction(_.last(watchs))) {\n            watchs.push((event) => {\n                dt.watchChanged && dt.watchChanged(event, cfg);\n            });\n        }\n        watchs = _.map(watchs, w => {\n            if (_.isString(w)) {\n                return cfg.subTaskName(w);\n            }\n            return w;\n        });\n        let tk = cfg.subTaskName(dt);\n        console.log('register watch  dynamic task:', chalk.cyan(tk));\n        gulp.task(tk, () => {\n            let src = cfg.getSrc(dt);\n            console.log('watch, src:', chalk.cyan.call(chalk, src));\n            gulp.watch(src, watchs);\n        });\n        return tk;\n    };\n    return new DynamicTask({ order: dt.order, oper: dt.oper, watch: dt.watch, group: dt.group, assert: dt }, factory);\n}\nfunction createPipesTask(dt) {\n    return new DynamicPipeTask(dt);\n}\n","import * as _ from 'lodash';\r\nimport { Gulp, WatchEvent } from 'gulp';\r\nimport * as coregulp from 'gulp';\r\nimport * as chalk from 'chalk';\r\n\r\nimport { IAssertDist, IOutputPipe, Operation, ITaskInfo, ITransform, TaskResult, IPipe, IDynamicTaskOption, ITaskContext, ITask } from './TaskConfig';\r\nimport { matchTaskGroup, matchTaskInfo, taskStringVal } from './utils';\r\nimport { PipeTask } from './PipeTask';\r\n\r\ntype factory = (config: ITaskContext, gulp: Gulp) => TaskResult;\r\nclass DynamicTask implements ITask {\r\n    constructor(public decorator: ITaskInfo, private factory: factory) {\r\n    }\r\n    setup(config: ITaskContext, gulp?: Gulp) {\r\n        let name = this.factory(config, gulp || coregulp);\r\n        if (name) {\r\n            this.decorator.taskName = name;\r\n        }\r\n        return name;\r\n    }\r\n}\r\n\r\nclass DynamicPipeTask extends PipeTask {\r\n    constructor(private dt: IDynamicTaskOption, info?: ITaskInfo) {\r\n        super(info);\r\n        this.decorator = info || dt;\r\n        this.decorator.assert = dt;\r\n    }\r\n\r\n    protected getOption(config: ITaskContext) {\r\n        this.name = this.name || taskStringVal(this.dt.name, config.oper);\r\n        return this.dt || config.option;\r\n    }\r\n\r\n    protected customPipe(source: ITransform, config: ITaskContext, dist: IAssertDist, gulp: Gulp) {\r\n        if (this.dt.pipe) {\r\n            return Promise.resolve(super.customPipe(source, config, dist, gulp))\r\n                .then(stream => this.cpipe2Promise(stream, this.dt, config, dist, gulp));\r\n        } else {\r\n            return super.customPipe(source, config, dist, gulp)\r\n        }\r\n    }\r\n\r\n    pipes(config: ITaskContext, dist: IAssertDist, gulp?: Gulp): IPipe[] {\r\n        let pipes = _.isFunction(this.dt.pipes) ? this.dt.pipes(config, dist, gulp) : this.dt.pipes;\r\n        pipes = pipes || [];\r\n        return pipes.concat(super.pipes(config, dist, gulp));\r\n    }\r\n\r\n    output(config: ITaskContext, dist: IAssertDist, gulp?: Gulp): IOutputPipe[] {\r\n        if (this.dt.output === null) {\r\n            return [stream => stream];\r\n        }\r\n        let outputs = _.isFunction(this.dt.output) ? this.dt.output(config, dist, gulp) : this.dt.output;\r\n        outputs = outputs || [];\r\n        return outputs.concat(super.output(config, dist, gulp));\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * dynamic build tasks.\r\n * \r\n * @export\r\n * @param {(IDynamicTaskOption | IDynamicTaskOption[])} tasks\r\n * @param {ITaskInfo} [match]\r\n * @returns {ITask[]}\r\n */\r\nexport function generateTask(tasks: IDynamicTaskOption | IDynamicTaskOption[], match?: ITaskInfo): ITask[] {\r\n    let taskseq: ITask[] = [];\r\n    _.each(_.isArray(tasks) ? tasks : [tasks], dt => {\r\n\r\n        if (dt.watchTasks) {\r\n            dt.oper = (dt.oper || Operation.default) | Operation.watch;\r\n        }\r\n        if (!matchTaskInfo(dt, match)) {\r\n            return;\r\n        }\r\n\r\n        if (!matchTaskGroup(dt, match)) {\r\n            return;\r\n        }\r\n\r\n        if ((dt.oper & Operation.watch) > 0) {\r\n            taskseq.push(createWatchTask(dt))\r\n        } else if (_.isFunction(dt.task)) {\r\n            // custom task\r\n            taskseq.push(createTask(dt));\r\n        } else {\r\n            // pipe stream task.\r\n            taskseq.push(createPipesTask(dt));\r\n        }\r\n    });\r\n\r\n    return taskseq;\r\n}\r\n\r\n\r\n\r\n/**\r\n * promise task.\r\n * \r\n * @param {DynamicTask} dt\r\n * @returns\r\n */\r\nfunction createTask(dt: IDynamicTaskOption) {\r\n    let factory = (cfg: ITaskContext, gulp: Gulp) => {\r\n        let tk = cfg.subTaskName(dt.name);\r\n        console.log('register custom dynamic task:', chalk.cyan(tk));\r\n        gulp.task(tk, () => {\r\n            return dt.task(cfg, dt, gulp);\r\n        });\r\n\r\n        return tk\r\n    };\r\n\r\n    return new DynamicTask({ order: dt.order, oper: dt.oper, watch: dt.watch, group: dt.group, assert: dt }, factory);\r\n}\r\n/**\r\n * create dynamic watch task.\r\n * \r\n * @param {DynamicTask} dt\r\n * @returns\r\n */\r\nfunction createWatchTask(dt: IDynamicTaskOption) {\r\n    let factory = (cfg: ITaskContext, gulp: Gulp) => {\r\n        let watchs = _.isFunction(dt.watchTasks) ? dt.watchTasks(cfg) : dt.watchTasks;\r\n        if (!_.isFunction(_.last(watchs))) {\r\n            watchs.push(<WatchCallback>(event: WatchEvent) => {\r\n                dt.watchChanged && dt.watchChanged(event, cfg);\r\n            });\r\n        }\r\n        watchs = _.map(watchs, w => {\r\n            if (_.isString(w)) {\r\n                return cfg.subTaskName(w);\r\n            }\r\n            return w;\r\n        })\r\n        let tk = cfg.subTaskName(dt);\r\n        console.log('register watch  dynamic task:', chalk.cyan(tk));\r\n        gulp.task(tk, () => {\r\n            let src = cfg.getSrc(dt);\r\n            console.log('watch, src:', chalk.cyan.call(chalk, src));\r\n            gulp.watch(src, watchs)\r\n        });\r\n\r\n        return tk;\r\n    };\r\n\r\n    return new DynamicTask({ order: dt.order, oper: dt.oper, watch: dt.watch, group: dt.group, assert: dt }, factory);\r\n}\r\n\r\nfunction createPipesTask(dt: IDynamicTaskOption) {\r\n    return new DynamicPipeTask(dt);\r\n}\r\n"]}