{"version":3,"sources":["generateTask.ts"],"names":["generateTask","tasks","match","ctx","taskseq","_","each","isArray","dt","watchTasks","oper","TaskConfig_1","Operation","default","watch","utils_1","matchCompare","autoWatch","push","createTask","task","createWatchTask","shell","ShellTask","isFunction","createCustomTask","createPipesTask","factory","info","gulp","tk","subTaskName","console","log","chalk","cyan","DynamicTask","name","order","group","assert","callback","watchs","last","pop","event","watchChanged","map","w","isString","src","getSrc","call","taskSequence_1","runSequence","then","DynamicPipeTask","require","coregulp","PipeTask_1","child_process_1","cmd","this","prototype","getInfo","setup","_this","to","Promise","resolve","cmds","execShell","option","shellRunWay","RunWay","sequence","pip_1","all","reject","taskName","exec","err","stdout","stderr","on","data","_super","__extends","getOption","toStr","customPipe","source","dist","pipe","stream","cpipe2Promise","pipes","concat","output","outputs","PipeTask","exports"],"mappings":"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","file":"../generateTask.js","sourcesContent":["import * as _ from 'lodash';\r\nimport { Gulp, WatchEvent } from 'gulp';\r\nimport * as coregulp from 'gulp';\r\nimport * as chalk from 'chalk';\r\n\r\nimport { IAssertDist, IOutputPipe, Operation, AsyncSrc, ITaskInfo, ITransform, RunWay, AsyncTaskSource, TaskResult, IPipe, IDynamicTaskOption, ITaskContext, ITask } from './TaskConfig';\r\nimport { matchCompare } from './utils';\r\nimport { PipeTask } from './PipeTask';\r\nimport { runSequence } from './taskSequence';\r\nimport * as watch from 'gulp-watch';\r\nimport { exec } from 'child_process';\r\n\r\ntype factory = (ctx: ITaskContext, info: ITaskInfo, gulp: Gulp) => TaskResult;\r\n\r\n/**\r\n * Shell Task\r\n *\r\n * @class ShellTask\r\n * @implements {ITask}\r\n */\r\nclass ShellTask implements ITask {\r\n    constructor(protected info: ITaskInfo, protected cmd: AsyncTaskSource) {\r\n\r\n    }\r\n\r\n    /**\r\n     * get task info.\r\n     */\r\n    public getInfo(): ITaskInfo {\r\n        return this.info;\r\n    }\r\n\r\n    /**\r\n     * setup shell task.\r\n     *\r\n     * @param {ITaskContext} ctx\r\n     * @param {Gulp} [gulp]\r\n     * @returns\r\n     *\r\n     * @memberOf ShellTask\r\n     */\r\n    setup(ctx: ITaskContext, gulp?: Gulp) {\r\n        gulp = gulp || coregulp;\r\n        // let option = this.getOption(context);\r\n        let tk = ctx.subTaskName(this.getInfo());\r\n        console.log(`register shell task:`, chalk.cyan(tk));\r\n\r\n        gulp.task(tk, () => {\r\n            let cmd = ctx.to<AsyncSrc>(this.cmd);\r\n            return Promise.resolve(cmd)\r\n                .then(cmds => {\r\n                    if (_.isString(cmds)) {\r\n                        return this.execShell(cmds);\r\n                    } else if (_.isArray(cmds)) {\r\n                        if (ctx.option.shellRunWay === RunWay.sequence) {\r\n                            let pip = Promise.resolve();\r\n                            _.each(cmds, cmd => {\r\n                                pip = pip.then(() => this.execShell(cmd));\r\n                            });\r\n                            return pip;\r\n                        } else {\r\n                            return Promise.all(_.map(cmds, cmd => this.execShell(cmd)));\r\n                        }\r\n                    } else {\r\n\r\n                        return Promise.reject('shell task config error');\r\n                    }\r\n                });\r\n\r\n        });\r\n\r\n        this.info.taskName = tk;\r\n\r\n        return tk;\r\n    }\r\n\r\n\r\n    execShell(cmd: string): Promise<any> {\r\n        if (!cmd) {\r\n            return Promise.resolve();\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            console.log('execute shell:', chalk.cyan(cmd));\r\n            let shell = exec(cmd, (err, stdout, stderr) => {\r\n                if (err) {\r\n                    reject(err);\r\n                } else {\r\n                    resolve(stdout);\r\n                }\r\n            });\r\n\r\n            shell.stdout.on('data', data => {\r\n                console.log(data);\r\n            });\r\n\r\n            shell.stderr.on('data', data => {\r\n                console.log(data);\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * custom dynamic task.\r\n *\r\n * @class DynamicTask\r\n * @implements {ITask}\r\n */\r\nclass DynamicTask implements ITask {\r\n    constructor(protected info: ITaskInfo, private factory: factory) {\r\n    }\r\n\r\n    /**\r\n     * get task info.\r\n     *\r\n     * @type {ITaskInfo}\r\n     * @memberOf PipeTask\r\n     */\r\n    public getInfo(): ITaskInfo {\r\n        return this.info;\r\n    }\r\n\r\n    setup(ctx: ITaskContext, gulp?: Gulp) {\r\n        let name = this.factory(ctx, this.getInfo(), gulp || coregulp);\r\n        if (name) {\r\n            this.info.taskName = name;\r\n        }\r\n        return name;\r\n    }\r\n}\r\n\r\n/**\r\n * pipe task for dynamic task.\r\n *\r\n * @class DynamicPipeTask\r\n * @extends {PipeTask}\r\n */\r\nclass DynamicPipeTask extends PipeTask {\r\n    constructor(private dt: IDynamicTaskOption, info?: ITaskInfo) {\r\n        super(info || dt);\r\n        this.info.assert = dt;\r\n    }\r\n\r\n    protected getOption(ctx: ITaskContext) {\r\n        this.name = this.name || ctx.toStr(this.dt.name);\r\n        return this.dt || ctx.option;\r\n    }\r\n\r\n    protected customPipe(source: ITransform, ctx: ITaskContext, dist: IAssertDist, gulp: Gulp) {\r\n        if (this.dt.pipe) {\r\n            return Promise.resolve(super.customPipe(source, ctx, dist, gulp))\r\n                .then(stream => this.cpipe2Promise(stream, this.dt, ctx, dist, gulp));\r\n        } else {\r\n            return super.customPipe(source, ctx, dist, gulp)\r\n        }\r\n    }\r\n\r\n    pipes(ctx: ITaskContext, dist: IAssertDist, gulp?: Gulp): IPipe[] {\r\n        let pipes = _.isFunction(this.dt.pipes) ? this.dt.pipes(ctx, dist, gulp) : this.dt.pipes;\r\n        pipes = pipes || [];\r\n        return pipes.concat(super.pipes(ctx, dist, gulp));\r\n    }\r\n\r\n    output(ctx: ITaskContext, dist: IAssertDist, gulp?: Gulp): IOutputPipe[] {\r\n        if (this.dt.output === null) {\r\n            return [stream => stream];\r\n        }\r\n        let outputs = _.isFunction(this.dt.output) ? this.dt.output(ctx, dist, gulp) : this.dt.output;\r\n        outputs = outputs || [];\r\n        return outputs.concat(super.output(ctx, dist, gulp));\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * dynamic build tasks.\r\n *\r\n * @export\r\n * @param {(IDynamicTaskOption | IDynamicTaskOption[])} tasks\r\n * @param {ITaskInfo} [match]\r\n * @param {ITaskContext} [ctx]\r\n * @returns {ITask[]}\r\n */\r\nexport function generateTask(tasks: IDynamicTaskOption | IDynamicTaskOption[], match?: ITaskInfo, ctx?: ITaskContext): ITask[] {\r\n    let taskseq: ITask[] = [];\r\n    _.each(_.isArray(tasks) ? tasks : [tasks], dt => {\r\n\r\n        if (dt.watchTasks) {\r\n            dt.oper = (dt.oper || Operation.default) | Operation.watch;\r\n        }\r\n\r\n        if (!matchCompare(dt, match, ctx)) {\r\n            return;\r\n        }\r\n\r\n        if (dt.watch && !(dt.oper & Operation.watch)) {\r\n            dt.oper = dt.oper | Operation.autoWatch;\r\n        }\r\n        taskseq.push(createTask(dt));\r\n\r\n    });\r\n\r\n    return taskseq;\r\n}\r\n\r\n/**\r\n * create task by dynamic option.\r\n *\r\n * @export\r\n * @param {IDynamicTaskOption} dt\r\n * @returns {ITask}\r\n */\r\nfunction createTask(dt: IDynamicTaskOption): ITask {\r\n    let task: ITask;\r\n    if (dt.oper & Operation.watch) {\r\n        task = createWatchTask(dt);\r\n    } else if (dt.shell) {\r\n        task = new ShellTask(dt, dt.shell);\r\n    } else if (_.isFunction(dt.task)) {\r\n        // custom task\r\n        task = createCustomTask(dt);\r\n    } else {\r\n        // pipe stream task.\r\n        task = createPipesTask(dt);\r\n    }\r\n    return task;\r\n}\r\n\r\n\r\n/**\r\n * create custom task.\r\n *\r\n * @param {IDynamicTaskOption} dt\r\n * @returns {ITask}\r\n */\r\nfunction createCustomTask(dt: IDynamicTaskOption): ITask {\r\n    let factory = (ctx: ITaskContext, info: ITaskInfo, gulp: Gulp) => {\r\n        let tk = ctx.subTaskName(info);\r\n        console.log('register custom dynamic task:', chalk.cyan(tk));\r\n        gulp.task(tk, () => {\r\n            return dt.task(ctx, dt, gulp);\r\n        });\r\n\r\n        return tk\r\n    };\r\n\r\n    return new DynamicTask({ name: dt.name, order: dt.order, oper: dt.oper, group: dt.group, assert: dt }, factory);\r\n}\r\n\r\n\r\n/**\r\n * create dynamic watch task.\r\n *\r\n * @export\r\n * @param {IDynamicTaskOption} dt\r\n * @returns {ITask}\r\n */\r\nfunction createWatchTask(dt: IDynamicTaskOption): ITask {\r\n    let factory = (ctx: ITaskContext, info: ITaskInfo, gulp: Gulp) => {\r\n        let watchs = _.isFunction(dt.watchTasks) ? dt.watchTasks(ctx, dt) : dt.watchTasks;\r\n        // if (!_.isFunction(_.last(watchs))) {\r\n        //     watchs.push(<WatchCallback>(event: WatchEvent) => {\r\n        //         dt.watchChanged && dt.watchChanged(event, ctx);\r\n        //     });\r\n        // }\r\n        let callback;\r\n        if (!_.isFunction(_.last(watchs))) {\r\n            callback = (event: WatchEvent) => {\r\n                dt.watchChanged && dt.watchChanged(event, ctx);\r\n            };\r\n        } else {\r\n            callback = watchs.pop();\r\n        }\r\n\r\n        watchs = _.map(watchs, w => {\r\n            if (_.isString(w)) {\r\n                return ctx.subTaskName(w);\r\n            }\r\n            return w;\r\n        })\r\n        let tk = ctx.subTaskName(info);\r\n        console.log('register watch  dynamic task:', chalk.cyan(tk));\r\n        gulp.task(tk, () => {\r\n            let src = ctx.getSrc(info);\r\n            console.log('watch, src:', chalk.cyan.call(chalk, src));\r\n            // watch(src, watchs);\r\n            watch(src, () => {\r\n                runSequence(gulp, <string[]>watchs)\r\n                    .then(() => {\r\n                        callback && callback();\r\n                    });\r\n            });\r\n        });\r\n\r\n        return tk;\r\n    };\r\n\r\n    return new DynamicTask({ name: dt.name, order: dt.order, oper: dt.oper, group: dt.group, assert: dt }, factory);\r\n}\r\n\r\n/**\r\n * create pipe task.\r\n *\r\n * @export\r\n * @param {IDynamicTaskOption} dt\r\n * @returns {ITask}\r\n */\r\nfunction createPipesTask(dt: IDynamicTaskOption): ITask {\r\n    return new DynamicPipeTask(dt);\r\n}\r\n"]}