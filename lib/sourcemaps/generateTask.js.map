{"version":3,"sources":["generateTask.ts"],"names":["generateTask","tasks","match","ctx","taskseq","_","each","isArray","dt","watchTasks","oper","TaskConfig_1","Operation","default","watch","utils_1","matchCompare","autoWatch","push","createTask","task","createWatchTask","isFunction","createCustomTask","createPipesTask","factory","info","gulp","tk","subTaskName","console","log","chalk","cyan","DynamicTask","name","order","group","assert","callback","watchs","last","pop","event","watchChanged","map","w","isString","src","getSrc","call","taskSequence_1","runSequence","then","DynamicPipeTask","require","coregulp","PipeTask_1","this","prototype","getInfo","setup","taskName","_super","_this","__extends","getOption","toStr","option","customPipe","source","dist","pipe","Promise","resolve","stream","cpipe2Promise","pipes","concat","output","outputs","PipeTask","exports"],"mappings":"YA8FA,SAAAA,cAA6BC,EAAkDC,EAAmBC,GAC9F,GAAIC,KAkBJ,OAjBAC,GAAEC,KAAKD,EAAEE,QAAQN,GAASA,GAASA,GAAQ,SAAAO,GAEnCA,EAAGC,aACHD,EAAGE,MAAQF,EAAGE,MAAQC,aAAAC,UAAUC,SAAWF,aAAAC,UAAUE,OAGpDC,QAAAC,aAAaR,EAAIN,EAAOC,MAIzBK,EAAGM,OAAWN,EAAGE,KAAOC,aAAAC,UAAUE,QAClCN,EAAGE,KAAOF,EAAGE,KAAOC,aAAAC,UAAUK,WAElCb,EAAQc,KAAKC,WAAWX,OAIrBJ,EAUX,QAAAe,YAA2BX,GACvB,GAAIY,EAUJ,OARIA,GADAZ,EAAGE,KAAOC,aAAAC,UAAUE,MACbO,gBAAgBb,GAChBH,EAAEiB,WAAWd,EAAGY,MAEhBG,iBAAiBf,GAGjBgB,gBAAgBhB,GAY/B,QAAAe,kBAA0Bf,GACtB,GAAIiB,GAAU,SAACtB,EAAmBuB,EAAiBC,GAC/C,GAAIC,GAAKzB,EAAI0B,YAAYH,EAMzB,OALAI,SAAQC,IAAI,gCAAiCC,MAAMC,KAAKL,IACxDD,EAAKP,KAAKQ,EAAI,WACV,MAAOpB,GAAGY,KAAKjB,EAAKK,EAAImB,KAGrBC,EAGX,OAAO,IAAIM,cAAcC,KAAM3B,EAAG2B,KAAMC,MAAO5B,EAAG4B,MAAO1B,KAAMF,EAAGE,KAAM2B,MAAO7B,EAAG6B,MAAOC,OAAQ9B,GAAMiB,GAW3G,QAAAJ,iBAAyBb,GACrB,GAAIiB,GAAU,SAACtB,EAAmBuB,EAAiBC,GAC/C,GAMIY,GANAC,EAASnC,EAAEiB,WAAWd,EAAGC,YAAcD,EAAGC,WAAWN,EAAKK,GAAMA,EAAGC,UAYnE8B,GALClC,EAAEiB,WAAWjB,EAAEoC,KAAKD,IAKVA,EAAOE,MAJP,SAACC,GACRnC,EAAGoC,cAAgBpC,EAAGoC,aAAaD,EAAOxC,IAMlDqC,EAASnC,EAAEwC,IAAIL,EAAQ,SAAAM,GACnB,MAAIzC,GAAE0C,SAASD,GACJ3C,EAAI0B,YAAYiB,GAEpBA,GAEX,IAAIlB,GAAKzB,EAAI0B,YAAYH,EAczB,OAbAI,SAAQC,IAAI,gCAAiCC,MAAMC,KAAKL,IACxDD,EAAKP,KAAKQ,EAAI,WACV,GAAIoB,GAAM7C,EAAI8C,OAAOvB,EACrBI,SAAQC,IAAI,cAAeC,MAAMC,KAAKiB,KAAKlB,MAAOgB,IAElDlC,MAAMkC,EAAK,WACPG,eAAAC,YAAYzB,EAAgBa,GACvBa,KAAK,WACFd,GAAYA,UAKrBX,EAGX,OAAO,IAAIM,cAAcC,KAAM3B,EAAG2B,KAAMC,MAAO5B,EAAG4B,MAAO1B,KAAMF,EAAGE,KAAM2B,MAAO7B,EAAG6B,MAAOC,OAAQ9B,GAAMiB,GAU3G,QAAAD,iBAAyBhB,GACrB,MAAO,IAAI8C,iBAAgB9C,4MAzN/BH,EAAAkD,QAAA,UAEAC,SAAAD,QAAA,QACAvB,MAAAuB,QAAA,SAEA5C,aAAA4C,QAAA,gBACAxC,QAAAwC,QAAA,WACAE,WAAAF,QAAA,cACAJ,eAAAI,QAAA,kBAEAzC,MAAAyC,QAAA,cASArB,YAAA,WACI,QAAAA,GAAsBR,EAAyBD,GAAzBiC,KAAAhC,KAAAA,EAAyBgC,KAAAjC,QAAAA,EAoBnD,MAXWS,GAAAyB,UAAAC,QAAP,WACI,MAAOF,MAAKhC,MAGhBQ,EAAAyB,UAAAE,MAAA,SAAM1D,EAAmBwB,GACrB,GAAIQ,GAAOuB,KAAKjC,QAAQtB,EAAKuD,KAAKE,UAAWjC,GAAQ6B,SAIrD,OAHIrB,KACAuB,KAAKhC,KAAKoC,SAAW3B,GAElBA,GAEfD,KAQAoB,gBAAA,SAAAS,GACI,QAAAT,GAAoB9C,EAAwBkB,GAA5C,GAAAsC,GACID,EAAAb,KAAAQ,KAAMhC,GAAQlB,IAAGkD,WADDM,GAAAxD,GAAAA,EAEhBwD,EAAKtC,KAAKY,OAAS9B,IAgC3B,MAnC8ByD,WAAAX,EAAAS,GAMhBT,EAAAK,UAAAO,UAAV,SAAoB/D,GAEhB,MADAuD,MAAKvB,KAAOuB,KAAKvB,MAAQhC,EAAIgE,MAAMT,KAAKlD,GAAG2B,MACpCuB,KAAKlD,IAAML,EAAIiE,QAGhBd,EAAAK,UAAAU,WAAV,SAAqBC,EAAoBnE,EAAmBoE,EAAmB5C,GAA/E,GAAAqC,GAAAN,IACI,OAAIA,MAAKlD,GAAGgE,KACDC,QAAQC,QAAQX,EAAAJ,UAAMU,WAAUnB,KAAAQ,KAACY,EAAQnE,EAAKoE,EAAM5C,IACtD0B,KAAK,SAAAsB,GAAU,MAAAX,GAAKY,cAAcD,EAAQX,EAAKxD,GAAIL,EAAKoE,EAAM5C,KAE5DoC,EAAAJ,UAAMU,WAAUnB,KAAAQ,KAACY,EAAQnE,EAAKoE,EAAM5C,IAInD2B,EAAAK,UAAAkB,MAAA,SAAM1E,EAAmBoE,EAAmB5C,GACxC,GAAIkD,GAAQxE,EAAEiB,WAAWoC,KAAKlD,GAAGqE,OAASnB,KAAKlD,GAAGqE,MAAM1E,EAAKoE,EAAM5C,GAAQ+B,KAAKlD,GAAGqE,KAEnF,OADAA,GAAQA,MACDA,EAAMC,OAAOf,EAAAJ,UAAMkB,MAAK3B,KAAAQ,KAACvD,EAAKoE,EAAM5C,KAG/C2B,EAAAK,UAAAoB,OAAA,SAAO5E,EAAmBoE,EAAmB5C,GACzC,GAAuB,OAAnB+B,KAAKlD,GAAGuE,OACR,OAAQ,SAAAJ,GAAU,MAAAA,IAEtB,IAAIK,GAAU3E,EAAEiB,WAAWoC,KAAKlD,GAAGuE,QAAUrB,KAAKlD,GAAGuE,OAAO5E,EAAKoE,EAAM5C,GAAQ+B,KAAKlD,GAAGuE,MAEvF,OADAC,GAAUA,MACHA,EAAQF,OAAOf,EAAAJ,UAAMoB,OAAM7B,KAAAQ,KAACvD,EAAKoE,EAAM5C,KAGtD2B,GAnC8BG,WAAAwB,SA8C9BC,SAAAlF,aAAAA,aA6BAkF,QAAA/D,WAAAA","file":"../generateTask.js","sourcesContent":["import * as _ from 'lodash';\r\nimport { Gulp, WatchEvent } from 'gulp';\r\nimport * as coregulp from 'gulp';\r\nimport * as chalk from 'chalk';\r\n\r\nimport { IAssertDist, IOutputPipe, Operation, ITaskInfo, ITransform, TaskResult, IPipe, IDynamicTaskOption, ITaskContext, ITask } from './TaskConfig';\r\nimport { matchCompare } from './utils';\r\nimport { PipeTask } from './PipeTask';\r\nimport { runSequence } from './taskSequence';\r\n\r\nimport * as watch from 'gulp-watch';\r\n\r\ntype factory = (ctx: ITaskContext, info: ITaskInfo, gulp: Gulp) => TaskResult;\r\n/**\r\n * custom dynamic task.\r\n * \r\n * @class DynamicTask\r\n * @implements {ITask}\r\n */\r\nclass DynamicTask implements ITask {\r\n    constructor(protected info: ITaskInfo, private factory: factory) {\r\n    }\r\n\r\n    /**\r\n     * get task info.\r\n     * \r\n     * @type {ITaskInfo}\r\n     * @memberOf PipeTask\r\n     */\r\n    public getInfo(): ITaskInfo {\r\n        return this.info;\r\n    }\r\n\r\n    setup(ctx: ITaskContext, gulp?: Gulp) {\r\n        let name = this.factory(ctx, this.getInfo(), gulp || coregulp);\r\n        if (name) {\r\n            this.info.taskName = name;\r\n        }\r\n        return name;\r\n    }\r\n}\r\n\r\n/**\r\n * pipe task for dynamic task.\r\n * \r\n * @class DynamicPipeTask\r\n * @extends {PipeTask}\r\n */\r\nclass DynamicPipeTask extends PipeTask {\r\n    constructor(private dt: IDynamicTaskOption, info?: ITaskInfo) {\r\n        super(info || dt);\r\n        this.info.assert = dt;\r\n    }\r\n\r\n    protected getOption(ctx: ITaskContext) {\r\n        this.name = this.name || ctx.toStr(this.dt.name);\r\n        return this.dt || ctx.option;\r\n    }\r\n\r\n    protected customPipe(source: ITransform, ctx: ITaskContext, dist: IAssertDist, gulp: Gulp) {\r\n        if (this.dt.pipe) {\r\n            return Promise.resolve(super.customPipe(source, ctx, dist, gulp))\r\n                .then(stream => this.cpipe2Promise(stream, this.dt, ctx, dist, gulp));\r\n        } else {\r\n            return super.customPipe(source, ctx, dist, gulp)\r\n        }\r\n    }\r\n\r\n    pipes(ctx: ITaskContext, dist: IAssertDist, gulp?: Gulp): IPipe[] {\r\n        let pipes = _.isFunction(this.dt.pipes) ? this.dt.pipes(ctx, dist, gulp) : this.dt.pipes;\r\n        pipes = pipes || [];\r\n        return pipes.concat(super.pipes(ctx, dist, gulp));\r\n    }\r\n\r\n    output(ctx: ITaskContext, dist: IAssertDist, gulp?: Gulp): IOutputPipe[] {\r\n        if (this.dt.output === null) {\r\n            return [stream => stream];\r\n        }\r\n        let outputs = _.isFunction(this.dt.output) ? this.dt.output(ctx, dist, gulp) : this.dt.output;\r\n        outputs = outputs || [];\r\n        return outputs.concat(super.output(ctx, dist, gulp));\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * dynamic build tasks.\r\n * \r\n * @export\r\n * @param {(IDynamicTaskOption | IDynamicTaskOption[])} tasks\r\n * @param {ITaskInfo} [match]\r\n * @param {ITaskContext} [ctx]\r\n * @returns {ITask[]}\r\n */\r\nexport function generateTask(tasks: IDynamicTaskOption | IDynamicTaskOption[], match?: ITaskInfo, ctx?: ITaskContext): ITask[] {\r\n    let taskseq: ITask[] = [];\r\n    _.each(_.isArray(tasks) ? tasks : [tasks], dt => {\r\n\r\n        if (dt.watchTasks) {\r\n            dt.oper = (dt.oper || Operation.default) | Operation.watch;\r\n        }\r\n\r\n        if (!matchCompare(dt, match, ctx)) {\r\n            return;\r\n        }\r\n\r\n        if (dt.watch && !(dt.oper & Operation.watch)) {\r\n            dt.oper = dt.oper | Operation.autoWatch;\r\n        }\r\n        taskseq.push(createTask(dt));\r\n\r\n    });\r\n\r\n    return taskseq;\r\n}\r\n\r\n/**\r\n * create task by dynamic option.\r\n * \r\n * @export\r\n * @param {IDynamicTaskOption} dt\r\n * @returns {ITask}\r\n */\r\nexport function createTask(dt: IDynamicTaskOption): ITask {\r\n    let task: ITask;\r\n    if (dt.oper & Operation.watch) {\r\n        task = createWatchTask(dt);\r\n    } else if (_.isFunction(dt.task)) {\r\n        // custom task\r\n        task = createCustomTask(dt);\r\n    } else {\r\n        // pipe stream task.\r\n        task = createPipesTask(dt);\r\n    }\r\n    return task;\r\n}\r\n\r\n\r\n/**\r\n * create custom task.\r\n * \r\n * @param {IDynamicTaskOption} dt\r\n * @returns {ITask}\r\n */\r\nfunction createCustomTask(dt: IDynamicTaskOption): ITask {\r\n    let factory = (ctx: ITaskContext, info: ITaskInfo, gulp: Gulp) => {\r\n        let tk = ctx.subTaskName(info);\r\n        console.log('register custom dynamic task:', chalk.cyan(tk));\r\n        gulp.task(tk, () => {\r\n            return dt.task(ctx, dt, gulp);\r\n        });\r\n\r\n        return tk\r\n    };\r\n\r\n    return new DynamicTask({ name: dt.name, order: dt.order, oper: dt.oper, group: dt.group, assert: dt }, factory);\r\n}\r\n\r\n\r\n/**\r\n * create dynamic watch task.\r\n * \r\n * @export\r\n * @param {IDynamicTaskOption} dt\r\n * @returns {ITask}\r\n */\r\nfunction createWatchTask(dt: IDynamicTaskOption): ITask {\r\n    let factory = (ctx: ITaskContext, info: ITaskInfo, gulp: Gulp) => {\r\n        let watchs = _.isFunction(dt.watchTasks) ? dt.watchTasks(ctx, dt) : dt.watchTasks;\r\n        // if (!_.isFunction(_.last(watchs))) {\r\n        //     watchs.push(<WatchCallback>(event: WatchEvent) => {\r\n        //         dt.watchChanged && dt.watchChanged(event, ctx);\r\n        //     });\r\n        // }\r\n        let callback;\r\n        if (!_.isFunction(_.last(watchs))) {\r\n            callback = (event: WatchEvent) => {\r\n                dt.watchChanged && dt.watchChanged(event, ctx);\r\n            };\r\n        } else {\r\n            callback = watchs.pop();\r\n        }\r\n\r\n        watchs = _.map(watchs, w => {\r\n            if (_.isString(w)) {\r\n                return ctx.subTaskName(w);\r\n            }\r\n            return w;\r\n        })\r\n        let tk = ctx.subTaskName(info);\r\n        console.log('register watch  dynamic task:', chalk.cyan(tk));\r\n        gulp.task(tk, () => {\r\n            let src = ctx.getSrc(info);\r\n            console.log('watch, src:', chalk.cyan.call(chalk, src));\r\n            // watch(src, watchs);\r\n            watch(src, () => {\r\n                runSequence(gulp, <string[]>watchs)\r\n                    .then(() => {\r\n                        callback && callback();\r\n                    });\r\n            });\r\n        });\r\n\r\n        return tk;\r\n    };\r\n\r\n    return new DynamicTask({ name: dt.name, order: dt.order, oper: dt.oper, group: dt.group, assert: dt }, factory);\r\n}\r\n\r\n/**\r\n * create pipe task.\r\n * \r\n * @export\r\n * @param {IDynamicTaskOption} dt\r\n * @returns {ITask}\r\n */\r\nfunction createPipesTask(dt: IDynamicTaskOption): ITask {\r\n    return new DynamicPipeTask(dt);\r\n}\r\n"]}