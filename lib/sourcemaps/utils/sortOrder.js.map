{"version":3,"sources":["utils/sortOrder.ts"],"names":["sortOrder","sequence","orderBy","ctx","forceSequence","parall","_","filter","t","rseq","isArray","order","isFunction","length","orderVal","isNumber","value","runWay","RunWay_1","RunWay","parallel","push","each","values","pals","first","splice","indexOf","require","exports"],"mappings":"YAiBA,SAAAA,WAA6BC,EAAeC,EAA6BC,EAAmBC,GAAA,SAAAA,IAAAA,GAAA,EACxF,IAAIC,KACJJ,GAAWK,EAAEC,OAAON,EAAU,SAAAO,GAAK,QAAEA,GACrC,IAAIC,GAAuBH,EAAEJ,QAAQD,EAAU,SAACO,GAC5C,GAAIF,EAAEI,QAAQF,GACV,MAAO,EAEP,IAAIG,GAAQT,EAAQM,EAChBF,GAAEM,WAAWD,KACbA,EAAQA,EAAMV,EAASY,OAAQV,GAGnC,IAAIW,GAAQ,MAcZ,OAbIR,GAAES,SAASJ,GACXG,EAAWH,EACJA,GACPA,EAAMK,MAAQV,EAAES,SAASJ,EAAMK,OAASL,EAAMK,MAAQ,GACjDZ,GAAiBO,EAAMM,SAAWC,SAAAC,OAAOC,WAC1Cf,EAAOM,EAAMK,OAASX,EAAOM,EAAMK,WACnCX,EAAOM,EAAMK,OAAOK,KAAKb,IAE7BM,EAAWH,EAAMK,OAEjBF,EAAW,GAGXA,EAAW,EACHA,EAAWb,EAASY,OAAUZ,EAASY,QACxCC,EAAW,IAClBA,EAAW,GAGRA,IAUf,OAPKV,IACDE,EAAEgB,KAAKhB,EAAEiB,OAAOlB,GAAS,SAAAmB,GACrB,GAAIC,GAAQnB,EAAEmB,MAAMD,EACpBf,GAAKiB,OAAOjB,EAAKkB,QAAQF,GAAQD,EAAKX,OAAQW,KAI/Cf,wDA3DX,IAAAH,GAAAsB,QAAA,UAGAV,SAAAU,QAAA,YAcAC,SAAA7B,UAAAA","file":"../../utils/sortOrder.js","sourcesContent":["import * as _ from 'lodash';\r\nimport { IMap } from './IMap';\r\nimport { Order } from '../types';\r\nimport { RunWay } from '../RunWay';\r\nimport { ITaskContext } from '../ITaskContext';\r\n\r\n/**\r\n * sorting via order.\r\n *\r\n * @export\r\n * @template T\r\n * @param {T[]} sequence\r\n * @param {(item: T) => Order} orderBy\r\n * @param {ITaskContext} ctx\r\n * @param {boolean} [forceSequence=false]\r\n * @returns {(Array<T | T[]>)}\r\n */\r\nexport function sortOrder<T>(sequence: T[], orderBy: (item: T) => Order, ctx: ITaskContext, forceSequence = false): Array<T | T[]> {\r\n    let parall: IMap<T[]> = {};\r\n    sequence = _.filter(sequence, t => !!t);\r\n    let rseq: Array<T | T[]> = _.orderBy(sequence, (t: T) => {\r\n        if (_.isArray(t)) {\r\n            return 0.5;\r\n        } else {\r\n            let order = orderBy(t);\r\n            if (_.isFunction(order)) {\r\n                order = order(sequence.length, ctx);\r\n            }\r\n\r\n            let orderVal: number;\r\n            if (_.isNumber(order)) {\r\n                orderVal = order;\r\n            } else if (order) {\r\n                order.value = _.isNumber(order.value) ? order.value : 0.5;\r\n                if (!forceSequence && order.runWay === RunWay.parallel) {\r\n                    parall[order.value] = parall[order.value] || [];\r\n                    parall[order.value].push(t);\r\n                }\r\n                orderVal = order.value;\r\n            } else {\r\n                orderVal = 0.5;\r\n            }\r\n\r\n            if (orderVal > 1) {\r\n                return (orderVal % sequence.length) / sequence.length;\r\n            } else if (orderVal < 0) {\r\n                orderVal = 0;\r\n            }\r\n\r\n            return orderVal;\r\n        }\r\n    });\r\n    if (!forceSequence) {\r\n        _.each(_.values(parall), pals => {\r\n            let first = _.first(pals);\r\n            rseq.splice(rseq.indexOf(first), pals.length, pals);\r\n        });\r\n    }\r\n\r\n    return rseq;\r\n}\r\n"]}