{"version":3,"sources":["tasks/ShellTask.ts"],"names":["coregulp","require","chalk","_","RunWay_1","ShellTask","info","cmd","this","prototype","getInfo","execute","ctx","gulp","option","to","Promise","resolve","then","cmds","isString","execShell","execOptions","allowError","isArray","shellRunWay","RunWay","sequence","pip_1","each","all","map","reject","setup","_this","tk","taskName","console","log","cyan","task","exports"],"mappings":"mEACA,IAAAA,UAAAC,QAAA,QACAC,MAAAD,QAAA,SACAE,EAAAF,QAAA,UAEAG,SAAAH,QAAA,aA6CAI,UAAA,WACI,QAAAA,GAAsBC,EAA2BC,GAA3BC,KAAAF,KAAAA,EAA2BE,KAAAD,IAAAA,EA0DrD,MAnDWF,GAAAI,UAAAC,QAAP,WACI,MAAOF,MAAKF,MAGhBD,EAAAI,UAAAE,QAAA,SAAQC,EAAmBC,GACvB,GAAIC,GAASF,EAAIE,OACbP,EAAMK,EAAIG,GAAaP,KAAKD,IAChC,OAAOS,SAAQC,QAAQV,GAClBW,KAAK,SAAAC,GACF,GAAIhB,EAAEiB,SAASD,GACX,MAAOP,GAAIS,UAAUF,EAAML,EAAOQ,YAAaR,EAAOS,cAAe,EAClE,IAAIpB,EAAEqB,QAAQL,GAAO,CACxB,GAAIL,EAAOW,cAAgBrB,SAAAsB,OAAOC,SAAU,CACxC,GAAIC,GAAMZ,QAAQC,SAIlB,OAHAd,GAAE0B,KAAKV,EAAM,SAAAZ,GACTqB,EAAMA,EAAIV,KAAK,WAAM,MAAAN,GAAIS,UAAUd,EAAKO,EAAOQ,iBAE5CM,EAEP,MAAOZ,SAAQc,IAAI3B,EAAE4B,IAAIZ,EAAM,SAAAZ,GAAO,MAAAK,GAAIS,UAAUd,EAAKO,EAAOQ,YAAaR,EAAOS,cAAe,MAIvG,MAAOP,SAAQgB,OAAO,8BActC3B,EAAAI,UAAAwB,MAAA,SAAMrB,EAAmBC,GAAzB,GAAAqB,GAAA1B,IACIK,GAAOA,GAAQb,QACf,IAAImC,GAAKvB,EAAIwB,SAAS5B,KAAKE,UAS3B,OARA2B,SAAQC,IAAI,uBAAwBpC,MAAMqC,KAAKJ,IAE/CtB,EAAK2B,KAAKL,EAAI,WACV,MAAOD,GAAKvB,QAAQC,EAAKC,KAG7BL,KAAKF,KAAK8B,SAAWD,EAEdA,GAGf9B,IA3DaoC,SAAApC,UAAAA","file":"../../tasks/ShellTask.js","sourcesContent":["import { Gulp } from 'gulp';\r\nimport * as coregulp from 'gulp';\r\nimport * as chalk from 'chalk';\r\nimport * as _ from 'lodash';\r\nimport { IAssertOption } from '../IAssertOption';\r\nimport { RunWay } from '../RunWay';\r\nimport { ExecOptions } from 'child_process';\r\nimport { ITask, ITaskInfo } from '../ITask';\r\nimport { AsyncTaskSource, AsyncSrc } from '../types';\r\nimport { ITaskContext } from '../ITaskContext';\r\n\r\n\r\n\r\n/**\r\n * shell option.\r\n *\r\n * @export\r\n * @interface IShellOption\r\n * @extends {IAssertOption}\r\n */\r\nexport interface IShellOption extends IAssertOption {\r\n    /**\r\n     * the shell command run way. default parallel.\r\n     *\r\n     * @type {RunWay}\r\n     * @memberof IShellOption\r\n     */\r\n    shellRunWay?: RunWay;\r\n\r\n    /**\r\n     * exec options.\r\n     *\r\n     * @type {ExecOptions}\r\n     * @memberof IShellOption\r\n     */\r\n    execOptions?: ExecOptions;\r\n\r\n    /**\r\n     * all child process has error.\r\n     */\r\n    allowError?: boolean;\r\n\r\n}\r\n\r\n/**\r\n * Shell Task\r\n *\r\n * @class ShellTask\r\n * @implements {ITask}\r\n */\r\nexport class ShellTask implements ITask {\r\n    constructor(protected info: ITaskInfo, protected cmd: AsyncTaskSource) {\r\n\r\n    }\r\n\r\n    /**\r\n     * get task info.\r\n     */\r\n    public getInfo(): ITaskInfo {\r\n        return this.info;\r\n    }\r\n\r\n    execute(ctx: ITaskContext, gulp?: Gulp): Promise<any> {\r\n        let option = ctx.option as IShellOption;\r\n        let cmd = ctx.to<AsyncSrc>(this.cmd);\r\n        return Promise.resolve(cmd)\r\n            .then(cmds => {\r\n                if (_.isString(cmds)) {\r\n                    return ctx.execShell(cmds, option.execOptions, option.allowError !== false);\r\n                } else if (_.isArray(cmds)) {\r\n                    if (option.shellRunWay === RunWay.sequence) {\r\n                        let pip = Promise.resolve();\r\n                        _.each(cmds, cmd => {\r\n                            pip = pip.then(() => ctx.execShell(cmd, option.execOptions));\r\n                        });\r\n                        return pip;\r\n                    } else {\r\n                        return Promise.all(_.map(cmds, cmd => ctx.execShell(cmd, option.execOptions, option.allowError !== false)));\r\n                    }\r\n                } else {\r\n\r\n                    return Promise.reject('shell task config error');\r\n                }\r\n            });\r\n    }\r\n\r\n    /**\r\n     * setup shell task.\r\n     *\r\n     * @param {ITaskContext} ctx\r\n     * @param {Gulp} [gulp]\r\n     * @returns\r\n     *\r\n     * @memberOf ShellTask\r\n     */\r\n    setup(ctx: ITaskContext, gulp?: Gulp) {\r\n        gulp = gulp || coregulp;\r\n        let tk = ctx.taskName(this.getInfo());\r\n        console.log(`register shell task:`, chalk.cyan(tk));\r\n\r\n        gulp.task(tk, () => {\r\n            return this.execute(ctx, gulp);\r\n        });\r\n\r\n        this.info.taskName = tk;\r\n\r\n        return tk;\r\n    }\r\n\r\n}\r\n"]}