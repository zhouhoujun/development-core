{"version":3,"sources":["taskSequence.js","taskSequence.ts"],"names":["_","require","chalk","TaskConfig_1","utils_1","toSequence","gulp","tasks","ctx","zipName","seq","len","length","taskseq","sortOrder","t","getInfo","order","hasWatchtasks","callback","push","watch","each","isArray","tk","pallSeq","setupTask","ps","flattenSequence","concat","watchname","taskSequenceWatch","it","indexOf","registerTasks","exports","info","oper","tname","setup","Operation","autoWatch","wname","task","src","getSrc","console","log","cyan","call","globals","registerGlobals","hasRegistered","error","red","express","option","wats","name","isBoolean","toWatchSeq","filterTaskSequence","zipSequence","registerZipTask","i","taskname","runSequence","first","last","RunWay","sequence","fs","ls","parallel","result","zipSrc","some","addToSequence","taskSequence","rst","taskName","isNumber","isFunction","val","value","parseInt","toFixed","seqMax","splice","rseq","isString","filter","itm","run","Promise","resolve","reject","then","startTask","catch","err","taskErr","taskStop","reslove","tskmap","process","exit","e","values","on","start","runTaskSequence"],"mappings":"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","file":"../taskSequence.js","sourcesContent":["\"use strict\";\nconst _ = require('lodash');\nconst chalk = require('chalk');\nconst TaskConfig_1 = require('./TaskConfig');\nconst utils_1 = require('./utils');\n/**\n * convert setup task result to run sequence src.\n *\n * @export\n * @param {Gulp} gulp\n * @param {ITask[]} tasks\n * @param {ITaskContext} ctx\n * @param {ZipTaskName} [zipName]\n * @returns {Src[]}\n */\nfunction toSequence(gulp, tasks, ctx, zipName) {\n    let seq = [];\n    let len = tasks.length;\n    if (len < 1) {\n        return seq;\n    }\n    let taskseq = utils_1.sortOrder(tasks, t => t.getInfo().order, ctx);\n    let hasWatchtasks = [];\n    let callback = watch => hasWatchtasks.push(watch);\n    _.each(taskseq, tk => {\n        if (_.isArray(tk)) {\n            let pallSeq = [];\n            _.each(tk, t => {\n                pallSeq.push(setupTask(gulp, t, ctx, callback));\n            });\n            let ps = flattenSequence(gulp, pallSeq, ctx, zipName);\n            if (ps && ps.length > 0) {\n                seq.push(ps);\n            }\n        }\n        else {\n            seq = seq.concat(setupTask(gulp, tk, ctx, callback));\n        }\n    });\n    let watchname = taskSequenceWatch(gulp, seq, ctx, it => {\n        if (!it) {\n            return false;\n        }\n        if (hasWatchtasks.length > 0) {\n            return hasWatchtasks.indexOf(it) < 0;\n        }\n        return true;\n    }, zipName);\n    if (watchname) {\n        registerTasks(ctx, watchname);\n        seq.push(watchname);\n    }\n    return seq;\n}\nexports.toSequence = toSequence;\nfunction setupTask(gulp, t, ctx, callback) {\n    let seq = [];\n    let info = t.getInfo();\n    if (info.oper & ctx.oper) {\n        let tname = ctx.setup(t, gulp); // t.setup(ctx, gulp);\n        if (tname) {\n            // is watch task.\n            if ((info.oper & TaskConfig_1.Operation.watch)) {\n                callback(tname);\n            }\n            registerTasks(ctx, tname);\n            if (_.isArray(tname)) {\n                seq = tname;\n            }\n            else {\n                seq.push(tname);\n            }\n            // autoWatch\n            if ((ctx.oper & TaskConfig_1.Operation.watch) && (info.oper & TaskConfig_1.Operation.autoWatch)) {\n                let wname = tname + '-twatch';\n                registerTasks(ctx, wname);\n                gulp.task(wname, () => {\n                    let src = ctx.getSrc(info);\n                    console.log('watch, src:', chalk.cyan.call(chalk, src));\n                    gulp.watch(src, _.isArray(tname) ? tname : [tname]);\n                });\n                callback(wname);\n                seq.push(wname);\n            }\n        }\n    }\n    return seq;\n}\nfunction registerTasks(ctx, tasks) {\n    ctx.globals.tasks = ctx.globals.tasks || {};\n    if (_.isArray(tasks)) {\n        _.each(tasks, t => registerGlobals(ctx, t));\n    }\n    else {\n        registerGlobals(ctx, tasks);\n    }\n}\nfunction hasRegistered(ctx, task) {\n    ctx.globals.tasks = ctx.globals.tasks || {};\n    return (ctx.globals.tasks[task]) ? true : false;\n}\nfunction registerGlobals(ctx, task) {\n    if (ctx.globals.tasks[task]) {\n        console.error(chalk.red('has same task:'), chalk.cyan(task));\n    }\n    else {\n        ctx.globals.tasks[task] = task;\n    }\n}\n/**\n * generate watch task for sequence\n *\n * @export\n * @param {Gulp} gulp\n * @param {Src[]} tasks\n * @param {ITaskContext} ctx\n * @param {(str: string) => boolean} [express]\n * @param {ZipTaskName} [zipName]\n * @returns {string}\n */\nfunction taskSequenceWatch(gulp, tasks, ctx, express, zipName) {\n    // create watch task.\n    if ((ctx.oper & TaskConfig_1.Operation.watch) && ctx.option.watch) {\n        let wats = [];\n        let name = '';\n        if (_.isBoolean(ctx.option.watch)) {\n            let toWatchSeq = filterTaskSequence(tasks, express);\n            name = zipSequence(gulp, toWatchSeq, ctx, zipName);\n            name && wats.push(name);\n        }\n        else {\n            wats = ctx.option.watch;\n        }\n        if (wats.length > 0) {\n            name = name ? name + '-owatch' : 'owatch';\n            gulp.task(name, () => {\n                let src = ctx.getSrc();\n                console.log('watch, src:', chalk.cyan.call(chalk, src));\n                gulp.watch(src, wats);\n            });\n            return name;\n        }\n    }\n    return '';\n}\nexports.taskSequenceWatch = taskSequenceWatch;\nfunction registerZipTask(gulp, name, tasks, ctx) {\n    let i = 0;\n    let taskname = name;\n    while (hasRegistered(ctx, taskname) && i < 50) {\n        taskname = name + i;\n        console.log('try register name: ', chalk.cyan(taskname));\n        i++;\n    }\n    if (i >= 50) {\n        console.error(chalk.red('has same task:'), chalk.cyan(name), 'too many times.');\n        return '';\n    }\n    registerGlobals(ctx, taskname);\n    gulp.task(taskname, () => {\n        return runSequence(gulp, tasks);\n    });\n    return taskname;\n}\n/**\n * zip tasks to a single task.\n *\n * @export\n * @param {Gulp} gulp\n * @param {Src[]} tasks\n * @param {ITaskContext} ctx\n * @param {ZipTaskName} [zipName]\n * @returns {string}\n */\nfunction zipSequence(gulp, tasks, ctx, zipName) {\n    if (tasks.length > 1) {\n        let first = _.first(tasks);\n        first = _.isArray(first) ? _.first(first) : first;\n        let last = _.last(tasks);\n        last = _.isArray(last) ? _.last(last) : last;\n        let name = `${first}-${last}`;\n        name = zipName ? zipName(name, TaskConfig_1.RunWay.sequence, ctx) : name + '-seq';\n        return registerZipTask(gulp, name, tasks, ctx);\n    }\n    else if (tasks.length === 1) {\n        let first = _.first(tasks);\n        if (_.isArray(first)) {\n            if (first.length > 1) {\n                let fs = _.first(first);\n                let ls = _.last(first);\n                let name = `${fs}-${ls}`;\n                name = zipName ? zipName(name, TaskConfig_1.RunWay.parallel, ctx) : name + '-paral';\n                return registerZipTask(gulp, name, tasks, ctx);\n            }\n            else {\n                return _.first(first) || '';\n            }\n        }\n        else {\n            return first || '';\n        }\n    }\n    return '';\n}\nexports.zipSequence = zipSequence;\n/**\n * flatten task Sequence.\n *\n * @export\n * @param {Gulp} gulp\n * @param {Src[]} tasks\n * @param {ITaskContext} ctx\n * @param {ZipTaskName} [zipName]\n * @returns {string[]}\n */\nfunction flattenSequence(gulp, tasks, ctx, zipName) {\n    let result = [];\n    _.each(tasks, tk => {\n        if (_.isArray(tk)) {\n            let zipSrc = (_.some(tk, t => _.isArray(t))) ? tk : [tk];\n            let taskname = zipSequence(gulp, zipSrc, ctx, zipName);\n            taskname && result.push(taskname);\n        }\n        else {\n            result.push(tk);\n        }\n    });\n    return result;\n}\nexports.flattenSequence = flattenSequence;\n/**\n * add task to task sequence.\n *\n * @export\n * @param {Src[]} taskSequence\n * @param {ITaskInfo} rst\n * @param {ITaskContext} [ctx]\n * @returns {Src[]}\n */\nfunction addToSequence(taskSequence, rst, ctx) {\n    if (!rst) {\n        return taskSequence;\n    }\n    if (rst.taskName) {\n        let order = 1;\n        let len = taskSequence.length + 1;\n        if (_.isNumber(rst.order)) {\n            order = rst.order;\n        }\n        else if (_.isFunction(rst.order)) {\n            let val = rst.order(len, ctx);\n            order = _.isNumber(val) ? val : val.value;\n        }\n        else if (rst.order && _.isNumber(rst.order.value)) {\n            order = rst.order.value;\n        }\n        if (order > 0 && order < 1) {\n            order = order * len;\n        }\n        else if (order === 1) {\n            order = len;\n        }\n        else if (order > len) {\n            order = order % len;\n        }\n        order = parseInt(order.toFixed(0));\n        if (order < 0) {\n            order = 0;\n        }\n        let seqMax = len - 2;\n        console.log(order);\n        if (order >= 0 && order <= seqMax) {\n            taskSequence.splice(order, 0, rst.taskName);\n        }\n        else if (order > seqMax && order < len) {\n            taskSequence.splice(seqMax - (seqMax - order), 0, rst.taskName);\n        }\n        else {\n            taskSequence.push(rst.taskName);\n        }\n    }\n    return taskSequence;\n}\nexports.addToSequence = addToSequence;\n/**\n * filter task sequence. make sure no empty.\n *\n * @param {Src[]} seq\n * @param {(str: string) => boolean} [filter]\n * @returns {Src[]}\n */\nfunction filterTaskSequence(seq, express) {\n    let rseq = [];\n    express = express || ((it) => !!it);\n    _.each(seq, it => {\n        if (!it) {\n            return;\n        }\n        if (_.isString(it) && express(it)) {\n            rseq.push(it);\n        }\n        else if (_.isArray(it)) {\n            rseq.push(_.filter(it, itm => express(itm)));\n        }\n    });\n    return rseq;\n}\n/**\n * run task sequence.\n *\n * @protected\n * @param {Gulp} gulp\n * @param {Src[]} tasks\n * @returns {Promise<any>}\n *\n * @memberOf Development\n */\nfunction runSequence(gulp, tasks) {\n    tasks = filterTaskSequence(tasks);\n    console.log(chalk.cyan('run tasks : '), tasks);\n    let run = new Promise((resolve, reject) => {\n        let ps = null;\n        if (tasks && tasks.length > 0) {\n            _.each(tasks, task => {\n                if (ps) {\n                    ps = ps.then(() => {\n                        return startTask(gulp, task);\n                    });\n                }\n                else {\n                    ps = startTask(gulp, task);\n                }\n            });\n        }\n        else {\n            ps = Promise.resolve();\n        }\n        return ps\n            .then(resolve)\n            .catch(reject);\n    });\n    return run.catch(err => {\n        console.error(chalk.red(err));\n        // process.exit(0);\n    });\n}\nexports.runSequence = runSequence;\n/**\n * start task.\n *\n * @param {Gulp} gulp\n * @param {Src} task\n * @returns {Promise<any>}\n */\nfunction startTask(gulp, task) {\n    let taskErr = null, taskStop = null;\n    return new Promise((reslove, reject) => {\n        let tskmap = {};\n        _.each(_.isArray(task) ? task : [task], t => {\n            tskmap[t] = false;\n        });\n        taskErr = (err) => {\n            process.exit(err);\n            console.error(chalk.red(err));\n            reject(err);\n        };\n        taskStop = (e) => {\n            if (tskmap[e.task] === false) {\n                tskmap[e.task] = true;\n            }\n            if (!_.some(_.values(tskmap), it => !it)) {\n                reslove();\n            }\n        };\n        if (gulp['setMaxListeners']) {\n            gulp['setMaxListeners'](100);\n        }\n        gulp.on('task_stop', taskStop)\n            .on('task_err', taskErr);\n        gulp.start(task);\n    })\n        .then(() => {\n        if (gulp['removeListener']) {\n            gulp['removeListener']('task_stop', taskStop);\n            gulp['removeListener']('task_err', taskErr);\n        }\n    }, err => {\n        if (gulp['removeListener']) {\n            gulp['removeListener']('task_stop', taskStop);\n            gulp['removeListener']('task_err', taskErr);\n        }\n        // process.exit(0);\n    });\n}\n// function start(gulp: Gulp, taskname: string): Promise<any> {\n//     let taskErr = null, taskStop = null;\n//     return new Promise((reslove, reject) => {\n//         taskErr = (err) => {\n//             process.exit(err);\n//             console.error(chalk.red(err));\n//             reject(err);\n//         };\n//         taskStop = (e: any) => {\n//             if (e.task === taskname) {\n//                 reslove();\n//             }\n//         }\n//         gulp.on('task_stop', taskStop)\n//             .on('task_err', taskErr);\n//         gulp.start(taskname);\n//     })\n//         .then(() => {\n//             if (gulp['removeListener']) {\n//                 gulp['removeListener']('task_stop', taskStop);\n//                 gulp['removeListener']('task_err', taskErr);\n//             }\n//         }, err => {\n//             if (gulp['removeListener']) {\n//                 gulp['removeListener']('task_stop', taskStop);\n//                 gulp['removeListener']('task_err', taskErr);\n//             }\n//             // process.exit(0);\n//         });\n// }\n/**\n * run task sequence\n *\n * @export\n * @param {Gulp} gulp\n * @param {(ITask[] | Promise<ITask[]>)} tasks\n * @param {ITaskContext} ctx\n * @param {ZipTaskName} [zipName]\n * @returns {Promise<any>}\n */\nfunction runTaskSequence(gulp, tasks, ctx, zipName) {\n    return Promise.resolve(tasks)\n        .then(tasks => {\n        let taskseq = toSequence(gulp, tasks, ctx, zipName);\n        return runSequence(gulp, taskseq);\n    });\n}\nexports.runTaskSequence = runTaskSequence;\n","import * as _ from 'lodash';\r\nimport { Gulp } from 'gulp';\r\nimport * as chalk from 'chalk';\r\nimport { Src, RunWay, ITaskInfo, ITaskContext, ITask, Operation } from './TaskConfig';\r\nimport { sortOrder } from './utils';\r\n\r\n\r\nexport type ZipTaskName = (name: string, runWay?: RunWay, ctx?: ITaskContext) => string\r\n/**\r\n * convert setup task result to run sequence src.\r\n * \r\n * @export\r\n * @param {Gulp} gulp\r\n * @param {ITask[]} tasks\r\n * @param {ITaskContext} ctx\r\n * @param {ZipTaskName} [zipName]\r\n * @returns {Src[]}\r\n */\r\nexport function toSequence(gulp: Gulp, tasks: ITask[], ctx: ITaskContext, zipName?: ZipTaskName): Src[] {\r\n    let seq: Src[] = [];\r\n    let len = tasks.length;\r\n    if (len < 1) {\r\n        return seq;\r\n    }\r\n    let taskseq = sortOrder<ITask>(tasks, t => t.getInfo().order, ctx);\r\n\r\n    let hasWatchtasks = [];\r\n    let callback = watch => hasWatchtasks.push(watch);\r\n    _.each(taskseq, tk => {\r\n        if (_.isArray(tk)) {\r\n            let pallSeq: Src[] = [];\r\n            _.each(tk, t => {\r\n                pallSeq.push(setupTask(gulp, t, ctx, callback));\r\n            });\r\n            let ps: Src = flattenSequence(gulp, pallSeq, ctx, zipName);\r\n            if (ps && ps.length > 0) {\r\n                seq.push(ps);\r\n            }\r\n        } else {\r\n            seq = seq.concat(setupTask(gulp, tk, ctx, callback));\r\n        }\r\n    });\r\n\r\n    let watchname = taskSequenceWatch(gulp, seq, ctx, it => {\r\n        if (!it) {\r\n            return false;\r\n        }\r\n        if (hasWatchtasks.length > 0) {\r\n            return hasWatchtasks.indexOf(it) < 0;\r\n        }\r\n        return true;\r\n    }, zipName);\r\n    if (watchname) {\r\n        registerTasks(ctx, watchname);\r\n        seq.push(watchname);\r\n    }\r\n\r\n    return seq;\r\n}\r\n\r\nfunction setupTask(gulp: Gulp, t: ITask, ctx: ITaskContext, callback: (name: Src) => void): string[] {\r\n    let seq: string[] = [];\r\n    let info = t.getInfo();\r\n    if (info.oper & ctx.oper) {\r\n        let tname = ctx.setup(t, gulp); // t.setup(ctx, gulp);\r\n        if (tname) {\r\n            // is watch task.\r\n            if ((info.oper & Operation.watch)) {\r\n                callback(tname);\r\n            }\r\n            registerTasks(ctx, tname);\r\n            if (_.isArray(tname)) {\r\n                seq = tname;\r\n            } else {\r\n                seq.push(tname);\r\n            }\r\n            // autoWatch\r\n            if ((ctx.oper & Operation.watch) && (info.oper & Operation.autoWatch)) {\r\n                let wname = tname + '-twatch';\r\n                registerTasks(ctx, wname);\r\n                gulp.task(wname, () => {\r\n                    let src = ctx.getSrc(info);\r\n                    console.log('watch, src:', chalk.cyan.call(chalk, src));\r\n                    gulp.watch(src, _.isArray(tname) ? tname : [<string>tname]);\r\n                });\r\n\r\n                callback(wname);\r\n                seq.push(wname);\r\n            }\r\n        }\r\n    }\r\n    return seq;\r\n}\r\n\r\nfunction registerTasks(ctx: ITaskContext, tasks: Src) {\r\n    ctx.globals.tasks = ctx.globals.tasks || {};\r\n    if (_.isArray(tasks)) {\r\n        _.each(tasks, t => registerGlobals(ctx, t));\r\n    } else {\r\n        registerGlobals(ctx, tasks);\r\n    }\r\n}\r\n\r\nfunction hasRegistered(ctx: ITaskContext, task: string) {\r\n    ctx.globals.tasks = ctx.globals.tasks || {};\r\n    return (ctx.globals.tasks[task]) ? true : false;\r\n}\r\n\r\nfunction registerGlobals(ctx: ITaskContext, task: string) {\r\n    if (ctx.globals.tasks[task]) {\r\n        console.error(chalk.red('has same task:'), chalk.cyan(task));\r\n    } else {\r\n        ctx.globals.tasks[task] = task;\r\n    }\r\n}\r\n\r\n/**\r\n * generate watch task for sequence\r\n * \r\n * @export\r\n * @param {Gulp} gulp\r\n * @param {Src[]} tasks\r\n * @param {ITaskContext} ctx\r\n * @param {(str: string) => boolean} [express]\r\n * @param {ZipTaskName} [zipName]\r\n * @returns {string}\r\n */\r\nexport function taskSequenceWatch(gulp: Gulp, tasks: Src[], ctx: ITaskContext, express?: (str: string) => boolean, zipName?: ZipTaskName): string {\r\n    // create watch task.\r\n    if ((ctx.oper & Operation.watch) && ctx.option.watch) {\r\n        let wats = [];\r\n        let name = '';\r\n        if (_.isBoolean(ctx.option.watch)) {\r\n            let toWatchSeq = filterTaskSequence(tasks, express);\r\n            name = zipSequence(gulp, toWatchSeq, ctx, zipName);\r\n            name && wats.push(name);\r\n        } else {\r\n            wats = ctx.option.watch;\r\n        }\r\n\r\n        if (wats.length > 0) {\r\n            name = name ? name + '-owatch' : 'owatch';\r\n            gulp.task(name, () => {\r\n                let src = ctx.getSrc();\r\n                console.log('watch, src:', chalk.cyan.call(chalk, src));\r\n                gulp.watch(src, wats)\r\n            });\r\n            return name;\r\n        }\r\n    }\r\n    return '';\r\n}\r\n\r\nfunction registerZipTask(gulp: Gulp, name: string, tasks: Src[], ctx: ITaskContext) {\r\n    let i = 0;\r\n    let taskname = name;\r\n    while (hasRegistered(ctx, taskname) && i < 50) {\r\n        taskname = name + i;\r\n        console.log('try register name: ', chalk.cyan(taskname));\r\n        i++;\r\n    }\r\n    if (i >= 50) {\r\n        console.error(chalk.red('has same task:'), chalk.cyan(name), 'too many times.');\r\n        return '';\r\n    }\r\n\r\n    registerGlobals(ctx, taskname);\r\n    gulp.task(taskname, () => {\r\n        return runSequence(gulp, tasks);\r\n    });\r\n    return taskname;\r\n}\r\n\r\n/**\r\n * zip tasks to a single task.\r\n * \r\n * @export\r\n * @param {Gulp} gulp\r\n * @param {Src[]} tasks\r\n * @param {ITaskContext} ctx\r\n * @param {ZipTaskName} [zipName]\r\n * @returns {string}\r\n */\r\nexport function zipSequence(gulp: Gulp, tasks: Src[], ctx: ITaskContext, zipName?: ZipTaskName): string {\r\n    if (tasks.length > 1) {\r\n        let first = _.first(tasks);\r\n        first = _.isArray(first) ? _.first(first) : first;\r\n        let last = _.last(tasks);\r\n        last = _.isArray(last) ? _.last(last) : last;\r\n        let name = `${first}-${last}`;\r\n        name = zipName ? zipName(name, RunWay.sequence, ctx) : name + '-seq';\r\n        return registerZipTask(gulp, name, tasks, ctx);\r\n\r\n    } else if (tasks.length === 1) {\r\n        let first = _.first(tasks);\r\n        if (_.isArray(first)) {\r\n            if (first.length > 1) {\r\n                let fs = _.first(first);\r\n                let ls = _.last(first);\r\n                let name = `${fs}-${ls}`;\r\n                name = zipName ? zipName(name, RunWay.parallel, ctx) : name + '-paral';\r\n                return registerZipTask(gulp, name, tasks, ctx);\r\n            } else {\r\n                return _.first(first) || '';\r\n            }\r\n        } else {\r\n            return first || '';\r\n        }\r\n    }\r\n\r\n    return '';\r\n}\r\n\r\n/**\r\n * flatten task Sequence.\r\n * \r\n * @export\r\n * @param {Gulp} gulp\r\n * @param {Src[]} tasks\r\n * @param {ITaskContext} ctx\r\n * @param {ZipTaskName} [zipName]\r\n * @returns {string[]}\r\n */\r\nexport function flattenSequence(gulp: Gulp, tasks: Src[], ctx: ITaskContext, zipName?: ZipTaskName): string[] {\r\n    let result: string[] = [];\r\n    _.each(tasks, tk => {\r\n        if (_.isArray(tk)) {\r\n            let zipSrc: Src[] = (_.some(tk, t => _.isArray(t))) ? tk : [tk];\r\n            let taskname = zipSequence(gulp, zipSrc, ctx, zipName);\r\n            taskname && result.push(taskname);\r\n        } else {\r\n            result.push(tk);\r\n        }\r\n    });\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * add task to task sequence.\r\n * \r\n * @export\r\n * @param {Src[]} taskSequence\r\n * @param {ITaskInfo} rst\r\n * @param {ITaskContext} [ctx]\r\n * @returns {Src[]}\r\n */\r\nexport function addToSequence(taskSequence: Src[], rst: ITaskInfo, ctx?: ITaskContext): Src[] {\r\n    if (!rst) {\r\n        return taskSequence;\r\n    }\r\n    if (rst.taskName) {\r\n        let order = 1;\r\n        let len = taskSequence.length + 1;\r\n        if (_.isNumber(rst.order)) {\r\n            order = rst.order;\r\n        } else if (_.isFunction(rst.order)) {\r\n            let val = rst.order(len, ctx);\r\n            order = _.isNumber(val) ? val : val.value\r\n        } else if (rst.order && _.isNumber(rst.order.value)) {\r\n            order = rst.order.value;\r\n        }\r\n\r\n\r\n        if (order > 0 && order < 1) {\r\n            order = order * len;\r\n        } else if (order === 1) {\r\n            order = len;\r\n        } else if (order > len) {\r\n            order = order % len;\r\n        }\r\n\r\n        order = parseInt(order.toFixed(0));\r\n\r\n        if (order < 0) {\r\n            order = 0;\r\n        }\r\n\r\n        let seqMax = len - 2;\r\n        console.log(order);\r\n        if (order >= 0 && order <= seqMax) {\r\n            taskSequence.splice(order, 0, rst.taskName);\r\n        } else if (order > seqMax && order < len) {\r\n            taskSequence.splice(seqMax - (seqMax - order), 0, rst.taskName);\r\n        } else {\r\n            taskSequence.push(rst.taskName);\r\n        }\r\n    }\r\n    return taskSequence;\r\n}\r\n\r\n\r\n/**\r\n * filter task sequence. make sure no empty.\r\n * \r\n * @param {Src[]} seq\r\n * @param {(str: string) => boolean} [filter]\r\n * @returns {Src[]}\r\n */\r\nfunction filterTaskSequence(seq: Src[], express?: (str: string) => boolean): Src[] {\r\n    let rseq: Src[] = [];\r\n    express = express || ((it) => !!it);\r\n    _.each(seq, it => {\r\n        if (!it) {\r\n            return;\r\n        }\r\n        if (_.isString(it) && express(it)) {\r\n            rseq.push(it);\r\n        } else if (_.isArray(it)) {\r\n            rseq.push(_.filter(it, itm => express(itm)));\r\n        }\r\n    });\r\n    return rseq;\r\n}\r\n/**\r\n * run task sequence.\r\n * \r\n * @protected\r\n * @param {Gulp} gulp\r\n * @param {Src[]} tasks\r\n * @returns {Promise<any>}\r\n * \r\n * @memberOf Development\r\n */\r\nexport function runSequence(gulp: Gulp, tasks: Src[]): Promise<any> {\r\n    tasks = filterTaskSequence(tasks);\r\n    console.log(chalk.cyan('run tasks : '), tasks);\r\n    let run = new Promise((resolve, reject) => {\r\n        let ps: Promise<any> = null;\r\n        if (tasks && tasks.length > 0) {\r\n            _.each(tasks, task => {\r\n                if (ps) {\r\n                    ps = ps.then(() => {\r\n                        return startTask(gulp, task);\r\n                    })\r\n                } else {\r\n                    ps = startTask(gulp, task);\r\n                }\r\n            });\r\n        } else {\r\n            ps = Promise.resolve();\r\n        }\r\n        return ps\r\n            .then(resolve)\r\n            .catch(reject);\r\n    });\r\n    return run.catch(err => {\r\n        console.error(chalk.red(err));\r\n        // process.exit(0);\r\n    });\r\n}\r\n\r\n/**\r\n * start task.\r\n * \r\n * @param {Gulp} gulp\r\n * @param {Src} task\r\n * @returns {Promise<any>}\r\n */\r\nfunction startTask(gulp: Gulp, task: Src): Promise<any> {\r\n    let taskErr = null, taskStop = null;\r\n    return new Promise((reslove, reject) => {\r\n        let tskmap: any = {};\r\n        _.each(_.isArray(task) ? task : [task], t => {\r\n            tskmap[t] = false;\r\n        });\r\n        taskErr = (err) => {\r\n            process.exit(err);\r\n            console.error(chalk.red(err));\r\n            reject(err);\r\n        };\r\n        taskStop = (e: any) => {\r\n            if (tskmap[e.task] === false) {\r\n                tskmap[e.task] = true;\r\n            }\r\n            if (!_.some(_.values(tskmap), it => !it)) {\r\n                reslove();\r\n            }\r\n        }\r\n        if (gulp['setMaxListeners']) {\r\n            gulp['setMaxListeners'](100);\r\n        }\r\n        gulp.on('task_stop', taskStop)\r\n            .on('task_err', taskErr);\r\n        gulp.start(task);\r\n    })\r\n        .then(() => {\r\n            if (gulp['removeListener']) {\r\n                gulp['removeListener']('task_stop', taskStop);\r\n                gulp['removeListener']('task_err', taskErr);\r\n            }\r\n        }, err => {\r\n            if (gulp['removeListener']) {\r\n                gulp['removeListener']('task_stop', taskStop);\r\n                gulp['removeListener']('task_err', taskErr);\r\n            }\r\n            // process.exit(0);\r\n        });\r\n}\r\n\r\n\r\n// function start(gulp: Gulp, taskname: string): Promise<any> {\r\n//     let taskErr = null, taskStop = null;\r\n//     return new Promise((reslove, reject) => {\r\n//         taskErr = (err) => {\r\n//             process.exit(err);\r\n//             console.error(chalk.red(err));\r\n//             reject(err);\r\n//         };\r\n//         taskStop = (e: any) => {\r\n//             if (e.task === taskname) {\r\n//                 reslove();\r\n//             }\r\n//         }\r\n//         gulp.on('task_stop', taskStop)\r\n//             .on('task_err', taskErr);\r\n//         gulp.start(taskname);\r\n//     })\r\n//         .then(() => {\r\n//             if (gulp['removeListener']) {\r\n//                 gulp['removeListener']('task_stop', taskStop);\r\n//                 gulp['removeListener']('task_err', taskErr);\r\n//             }\r\n//         }, err => {\r\n//             if (gulp['removeListener']) {\r\n//                 gulp['removeListener']('task_stop', taskStop);\r\n//                 gulp['removeListener']('task_err', taskErr);\r\n//             }\r\n//             // process.exit(0);\r\n//         });\r\n// }\r\n\r\n/**\r\n * run task sequence\r\n * \r\n * @export\r\n * @param {Gulp} gulp\r\n * @param {(ITask[] | Promise<ITask[]>)} tasks\r\n * @param {ITaskContext} ctx\r\n * @param {ZipTaskName} [zipName]\r\n * @returns {Promise<any>}\r\n */\r\nexport function runTaskSequence(gulp: Gulp, tasks: ITask[] | Promise<ITask[]>, ctx: ITaskContext, zipName?: ZipTaskName): Promise<any> {\r\n    return Promise.resolve(tasks)\r\n        .then(tasks => {\r\n            let taskseq = toSequence(gulp, tasks, ctx, zipName);\r\n            return runSequence(gulp, taskseq);\r\n        });\r\n}\r\n"]}