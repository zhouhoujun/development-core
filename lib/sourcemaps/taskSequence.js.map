{"version":3,"sources":["taskSequence.js","taskSequence.ts"],"names":["_","require","chalk","TaskConfig_1","generateTask_1","toSequence","gulp","tasks","ctx","seq","len","length","orderBy","isArray","t","info","getInfo","isNumber","order","hasWatchtasks","each","oper","tname","setup","Operation","watch","push","console","log","watchname","taskSequenceWatch","it","indexOf","exports","express","option","wats","name","isBoolean","toWatchSeq","filterTaskSequence","first","last","taskname","task","subTaskName","runSequence","fs","ls","watchtask","createTask","defaultWatch","watchTasks","addToSequence","taskSequence","rst","taskName","splice","rseq","isString","filter","itm","cyan","run","Promise","resolve","reject","ps","then","startTask","catch","error","red","err","process","exit","taskErr","taskStop","reslove","tskmap","e","some","values","on","start","runTaskSequence","taskseq"],"mappings":"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","file":"../taskSequence.js","sourcesContent":["\"use strict\";\nconst _ = require('lodash');\nconst chalk = require('chalk');\nconst TaskConfig_1 = require('./TaskConfig');\nconst generateTask_1 = require('./generateTask');\n/**\n * convert setup task result to run sequence src.\n *\n * @export\n * @param {Gulp} gulp\n * @param {ITask[]} tasks\n * @param {ITaskContext} ctx\n * @returns {Src[]}\n */\nfunction toSequence(gulp, tasks, ctx) {\n    let seq = [];\n    let len = tasks.length;\n    if (len < 1) {\n        return seq;\n    }\n    tasks = _.orderBy(tasks, t => {\n        if (_.isArray(t)) {\n            return len;\n        }\n        else {\n            let info = t.getInfo();\n            if (_.isNumber(info.order)) {\n                return info.order;\n            }\n            return len;\n        }\n    });\n    let hasWatchtasks = [];\n    _.each(tasks, t => {\n        let info = t.getInfo();\n        if (info.oper & ctx.oper) {\n            let tname = t.setup(ctx, gulp);\n            if (tname) {\n                if ((info.oper & TaskConfig_1.Operation.watch)) {\n                    hasWatchtasks.push(tname);\n                }\n                seq.push(tname);\n            }\n        }\n    });\n    console.log();\n    let watchname = taskSequenceWatch(gulp, seq, ctx, it => {\n        if (!it) {\n            return false;\n        }\n        if (hasWatchtasks.length > 0) {\n            return hasWatchtasks.indexOf(it) < 0;\n        }\n        return true;\n    });\n    if (watchname) {\n        seq.push(watchname);\n    }\n    return seq;\n}\nexports.toSequence = toSequence;\n/**\n * generate watch task for sequence\n *\n * @export\n * @param {Gulp} gulp\n * @param {Src[]} tasks\n * @param {ITaskContext} ctx\n * @param {(str: string) => boolean} [express]\n * @returns\n */\nfunction taskSequenceWatch(gulp, tasks, ctx, express) {\n    // create watch task.\n    if ((ctx.oper & TaskConfig_1.Operation.watch) && ctx.option.watch) {\n        let wats = [];\n        let name = '';\n        if (_.isBoolean(ctx.option.watch)) {\n            let toWatchSeq = filterTaskSequence(tasks, express);\n            if (toWatchSeq.length > 1) {\n                let first = _.first(toWatchSeq);\n                first = _.isArray(first) ? _.first(first) : first;\n                let last = _.last(toWatchSeq);\n                last = _.isArray(last) ? _.last(last) : last;\n                name = `${first}-${last}`;\n                let taskname = name + '-seq';\n                gulp.task(ctx.subTaskName(taskname), () => {\n                    return runSequence(gulp, toWatchSeq);\n                });\n                wats.push(taskname);\n            }\n            else if (toWatchSeq.length === 1) {\n                let first = _.first(toWatchSeq);\n                if (_.isArray(first)) {\n                    let fs = _.first(first);\n                    let ls = _.last(first);\n                    name = `${fs}-${ls}`;\n                    wats = first;\n                }\n                else if (first) {\n                    name = first;\n                    wats.push(first);\n                }\n            }\n        }\n        else {\n            wats = ctx.option.watch;\n        }\n        if (wats.length > 0) {\n            name = name ? name + '-watch' : 'watch';\n            let watchtask = generateTask_1.createTask({ oper: TaskConfig_1.Operation.defaultWatch, name: name, watchTasks: wats });\n            return watchtask.setup(ctx, gulp);\n        }\n    }\n    return '';\n}\nexports.taskSequenceWatch = taskSequenceWatch;\n/**\n * add task to task sequence.\n *\n * @export\n * @param {Src[]} taskSequence\n * @param {ITaskInfo} rst\n * @returns\n */\nfunction addToSequence(taskSequence, rst) {\n    if (!rst) {\n        return taskSequence;\n    }\n    if (rst.taskName) {\n        if (_.isNumber(rst.order) && rst.order >= 0 && rst.order < taskSequence.length) {\n            taskSequence.splice(rst.order, 0, rst.taskName);\n            return taskSequence;\n        }\n        taskSequence.push(rst.taskName);\n    }\n    return taskSequence;\n}\nexports.addToSequence = addToSequence;\n/**\n * filter task sequence. make sure no empty.\n *\n * @param {Src[]} seq\n * @param {(str: string) => boolean} [filter]\n * @returns {Src[]}\n */\nfunction filterTaskSequence(seq, express) {\n    let rseq = [];\n    express = express || ((it) => !!it);\n    _.each(seq, it => {\n        if (!it) {\n            return;\n        }\n        if (_.isString(it) && express(it)) {\n            rseq.push(it);\n        }\n        else if (_.isArray(it)) {\n            rseq.push(_.filter(it, itm => express(itm)));\n        }\n    });\n    return rseq;\n}\n/**\n * run task sequence.\n *\n * @protected\n * @param {Gulp} gulp\n * @param {Src[]} tasks\n * @returns {Promise<any>}\n *\n * @memberOf Development\n */\nfunction runSequence(gulp, tasks) {\n    tasks = filterTaskSequence(tasks);\n    console.log('run tasks : ', chalk.cyan(tasks));\n    let run = new Promise((resolve, reject) => {\n        let ps = null;\n        if (tasks && tasks.length > 0) {\n            _.each(tasks, task => {\n                if (ps) {\n                    ps = ps.then(() => {\n                        return startTask(gulp, task);\n                    });\n                }\n                else {\n                    ps = startTask(gulp, task);\n                }\n            });\n        }\n        else {\n            ps = Promise.resolve();\n        }\n        return ps\n            .then(resolve)\n            .catch(reject);\n    });\n    return run.catch(err => {\n        console.error(chalk.red(err));\n        process.exit(0);\n    });\n}\nexports.runSequence = runSequence;\n/**\n * start task.\n *\n * @param {Gulp} gulp\n * @param {Src} task\n * @returns {Promise<any>}\n */\nfunction startTask(gulp, task) {\n    let taskErr = null, taskStop = null;\n    return new Promise((reslove, reject) => {\n        let tskmap = {};\n        _.each(_.isArray(task) ? task : [task], t => {\n            tskmap[t] = false;\n        });\n        taskErr = (err) => {\n            process.exit(err);\n            console.error(chalk.red(err));\n            reject(err);\n        };\n        taskStop = (e) => {\n            tskmap[e.task] = true;\n            if (!_.some(_.values(tskmap), it => !it)) {\n                reslove();\n            }\n        };\n        gulp.on('task_stop', taskStop)\n            .on('task_err', taskErr);\n        gulp.start(task);\n    })\n        .then(() => {\n        if (gulp['removeListener']) {\n            gulp['removeListener']('task_stop', taskStop);\n            gulp['removeListener']('task_err', taskErr);\n        }\n    }, err => {\n        if (gulp['removeListener']) {\n            gulp['removeListener']('task_stop', taskStop);\n            gulp['removeListener']('task_err', taskErr);\n        }\n        // process.exit(0);\n    });\n}\n/**\n * run task sequence\n *\n * @export\n * @param {Gulp} gulp\n * @param {(ITask[] | Promise<ITask[]>)} tasks\n * @param {ITaskContext} ctx\n * @returns {Promise<any>}\n */\nfunction runTaskSequence(gulp, tasks, ctx) {\n    return Promise.resolve(tasks)\n        .then(tasks => {\n        let taskseq = toSequence(gulp, tasks, ctx);\n        return runSequence(gulp, taskseq);\n    });\n}\nexports.runTaskSequence = runTaskSequence;\n","import * as _ from 'lodash';\r\nimport { Gulp } from 'gulp';\r\nimport * as chalk from 'chalk';\r\nimport { Src, ITaskInfo, ITaskContext, ITask, Operation } from './TaskConfig';\r\nimport { createTask } from './generateTask';\r\n/**\r\n * convert setup task result to run sequence src.\r\n * \r\n * @export\r\n * @param {Gulp} gulp\r\n * @param {ITask[]} tasks\r\n * @param {ITaskContext} ctx\r\n * @returns {Src[]}\r\n */\r\nexport function toSequence(gulp: Gulp, tasks: ITask[], ctx: ITaskContext): Src[] {\r\n    let seq: Src[] = [];\r\n    let len = tasks.length;\r\n    if (len < 1) {\r\n        return seq;\r\n    }\r\n\r\n    tasks = _.orderBy(tasks, t => {\r\n        if (_.isArray(t)) {\r\n            return len;\r\n        } else {\r\n            let info = t.getInfo();\r\n            if (_.isNumber(info.order)) {\r\n                return info.order;\r\n            }\r\n            return len;\r\n        }\r\n    });\r\n\r\n    let hasWatchtasks = [];\r\n    _.each(tasks, t => {\r\n        let info = t.getInfo();\r\n        if (info.oper & ctx.oper) {\r\n            let tname = t.setup(ctx, gulp);\r\n            if (tname) {\r\n                if ((info.oper & Operation.watch)) {\r\n                    hasWatchtasks.push(tname);\r\n                }\r\n                seq.push(tname);\r\n            }\r\n        }\r\n    });\r\n\r\n    console.log()\r\n    let watchname = taskSequenceWatch(gulp, seq, ctx, it => {\r\n        if (!it) {\r\n            return false;\r\n        }\r\n        if (hasWatchtasks.length > 0) {\r\n            return hasWatchtasks.indexOf(it) < 0;\r\n        }\r\n        return true;\r\n    });\r\n    if (watchname) {\r\n        seq.push(watchname);\r\n    }\r\n\r\n    return seq;\r\n}\r\n\r\n/**\r\n * generate watch task for sequence\r\n * \r\n * @export\r\n * @param {Gulp} gulp\r\n * @param {Src[]} tasks\r\n * @param {ITaskContext} ctx\r\n * @param {(str: string) => boolean} [express]\r\n * @returns\r\n */\r\nexport function taskSequenceWatch(gulp: Gulp, tasks: Src[], ctx: ITaskContext, express?: (str: string) => boolean) {\r\n    // create watch task.\r\n    if ((ctx.oper & Operation.watch) && ctx.option.watch) {\r\n        let wats = [];\r\n        let name = '';\r\n        if (_.isBoolean(ctx.option.watch)) {\r\n            let toWatchSeq = filterTaskSequence(tasks, express)\r\n\r\n            if (toWatchSeq.length > 1) {\r\n                let first = _.first(toWatchSeq);\r\n                first = _.isArray(first) ? _.first(first) : first;\r\n                let last = _.last(toWatchSeq);\r\n                last = _.isArray(last) ? _.last(last) : last;\r\n                name = `${first}-${last}`;\r\n                let taskname = name + '-seq';\r\n                gulp.task(ctx.subTaskName(taskname), () => {\r\n                    return runSequence(gulp, toWatchSeq);\r\n                });\r\n                wats.push(taskname);\r\n            } else if (toWatchSeq.length === 1) {\r\n                let first = _.first(toWatchSeq);\r\n                if (_.isArray(first)) {\r\n                    let fs = _.first(first);\r\n                    let ls = _.last(first);\r\n                    name = `${fs}-${ls}`;\r\n                    wats = first;\r\n                } else if (first) {\r\n                    name = first;\r\n                    wats.push(first);\r\n                }\r\n            }\r\n\r\n        } else {\r\n            wats = ctx.option.watch;\r\n        }\r\n\r\n        if (wats.length > 0) {\r\n            name = name ? name + '-watch' : 'watch';\r\n            let watchtask = createTask({ oper: Operation.defaultWatch, name: name, watchTasks: wats });\r\n            return watchtask.setup(ctx, gulp);\r\n        }\r\n    }\r\n    return '';\r\n}\r\n\r\n/**\r\n * add task to task sequence.\r\n * \r\n * @export\r\n * @param {Src[]} taskSequence\r\n * @param {ITaskInfo} rst\r\n * @returns\r\n */\r\nexport function addToSequence(taskSequence: Src[], rst: ITaskInfo) {\r\n    if (!rst) {\r\n        return taskSequence;\r\n    }\r\n    if (rst.taskName) {\r\n        if (_.isNumber(rst.order) && rst.order >= 0 && rst.order < taskSequence.length) {\r\n            taskSequence.splice(rst.order, 0, rst.taskName);\r\n            return taskSequence;\r\n        }\r\n        taskSequence.push(rst.taskName);\r\n    }\r\n    return taskSequence;\r\n}\r\n\r\n\r\n/**\r\n * filter task sequence. make sure no empty.\r\n * \r\n * @param {Src[]} seq\r\n * @param {(str: string) => boolean} [filter]\r\n * @returns {Src[]}\r\n */\r\nfunction filterTaskSequence(seq: Src[], express?: (str: string) => boolean): Src[] {\r\n    let rseq: Src[] = [];\r\n    express = express || ((it) => !!it);\r\n    _.each(seq, it => {\r\n        if (!it) {\r\n            return;\r\n        }\r\n        if (_.isString(it) && express(it)) {\r\n            rseq.push(it);\r\n        } else if (_.isArray(it)) {\r\n            rseq.push(_.filter(it, itm => express(itm)));\r\n        }\r\n    });\r\n    return rseq;\r\n}\r\n/**\r\n * run task sequence.\r\n * \r\n * @protected\r\n * @param {Gulp} gulp\r\n * @param {Src[]} tasks\r\n * @returns {Promise<any>}\r\n * \r\n * @memberOf Development\r\n */\r\nexport function runSequence(gulp: Gulp, tasks: Src[]): Promise<any> {\r\n    tasks = filterTaskSequence(tasks);\r\n    console.log('run tasks : ', chalk.cyan(<any>tasks));\r\n    let run = new Promise((resolve, reject) => {\r\n        let ps: Promise<any> = null;\r\n        if (tasks && tasks.length > 0) {\r\n            _.each(tasks, task => {\r\n                if (ps) {\r\n                    ps = ps.then(() => {\r\n                        return startTask(gulp, task);\r\n                    })\r\n                } else {\r\n                    ps = startTask(gulp, task);\r\n                }\r\n            });\r\n        } else {\r\n            ps = Promise.resolve();\r\n        }\r\n        return ps\r\n            .then(resolve)\r\n            .catch(reject);\r\n    });\r\n    return run.catch(err => {\r\n        console.error(chalk.red(err));\r\n        process.exit(0);\r\n    });\r\n}\r\n\r\n/**\r\n * start task.\r\n * \r\n * @param {Gulp} gulp\r\n * @param {Src} task\r\n * @returns {Promise<any>}\r\n */\r\nfunction startTask(gulp: Gulp, task: Src): Promise<any> {\r\n    let taskErr = null, taskStop = null;\r\n    return new Promise((reslove, reject) => {\r\n        let tskmap: any = {};\r\n        _.each(_.isArray(task) ? task : [task], t => {\r\n            tskmap[t] = false;\r\n        });\r\n        taskErr = (err) => {\r\n            process.exit(err);\r\n            console.error(chalk.red(err));\r\n            reject(err);\r\n        };\r\n        taskStop = (e: any) => {\r\n            tskmap[e.task] = true;\r\n            if (!_.some(_.values(tskmap), it => !it)) {\r\n                reslove();\r\n            }\r\n        }\r\n        gulp.on('task_stop', taskStop)\r\n            .on('task_err', taskErr);\r\n        gulp.start(task);\r\n    })\r\n        .then(() => {\r\n            if (gulp['removeListener']) {\r\n                gulp['removeListener']('task_stop', taskStop);\r\n                gulp['removeListener']('task_err', taskErr);\r\n            }\r\n        }, err => {\r\n            if (gulp['removeListener']) {\r\n                gulp['removeListener']('task_stop', taskStop);\r\n                gulp['removeListener']('task_err', taskErr);\r\n            }\r\n            // process.exit(0);\r\n        });\r\n}\r\n\r\n/**\r\n * run task sequence\r\n * \r\n * @export\r\n * @param {Gulp} gulp\r\n * @param {(ITask[] | Promise<ITask[]>)} tasks\r\n * @param {ITaskContext} ctx\r\n * @returns {Promise<any>}\r\n */\r\nexport function runTaskSequence(gulp: Gulp, tasks: ITask[] | Promise<ITask[]>, ctx: ITaskContext): Promise<any> {\r\n    return Promise.resolve(tasks)\r\n        .then(tasks => {\r\n            let taskseq = toSequence(gulp, tasks, ctx);\r\n            return runSequence(gulp, taskseq);\r\n        });\r\n}\r\n"]}