{"version":3,"sources":["taskSequence.js","taskSequence.ts"],"names":["toSequence","gulp","tasks","config","seq","len","length","_","orderBy","t","isArray","info","getInfo","isNumber","order","each","watch","env","oper","tname","setup","push","addToSequence","taskSequence","rst","taskName","splice","runSequence","console","log","chalk","cyan","run","Promise","resolve","reject","ps","task","then","startTask","catch","err","error","red","process","exit","taskErr","taskStop","reslove","tskmap","e","some","values","it","on","start","runTaskSequence","taskseq","require","exports"],"mappings":"AAAA,YCcA,SAAAA,YAA2BC,EAAYC,EAAgBC,GACnD,GAAIC,MACAC,EAAMH,EAAMI,MAChB,OAAID,GAAM,EACCD,GAGXF,EAAQK,EAAEC,QAAQN,EAAO,SAAAO,GACrB,GAAIF,EAAEG,QAAQD,GACV,MAAOJ,EAEP,IAAIM,GAAOF,EAAEG,SACb,OAAIL,GAAEM,SAASF,EAAKG,OACTH,EAAKG,MAETT,IAIfE,EAAEQ,KAAKb,EAAO,SAAAO,GACV,GAAIE,GAAOF,EAAEG,SACb,MAAID,EAAKK,OAAUb,EAAOc,IAAID,UAIzBL,EAAKO,MACLP,EAAKO,OAASP,EAAKO,KAAOf,EAAOe,MAAQ,GAAI,CAC9C,GAAIC,GAAQV,EAAEW,MAAMjB,EAAQF,EAC5BkB,IAASf,EAAIiB,KAAKF,MAKnBf,GAYX,QAAAkB,eAA8BC,EAAqBC,GAC/C,IAAKA,EACD,MAAOD,EAEX,IAAIC,EAAIC,SAAU,CACd,GAAIlB,EAAEM,SAASW,EAAIV,QAAUU,EAAIV,OAAS,GAAKU,EAAIV,MAAQS,EAAajB,OAEpE,MADAiB,GAAaG,OAAOF,EAAIV,MAAO,EAAGU,EAAIC,UAC/BF,CAEXA,GAAaF,KAAKG,EAAIC,UAE1B,MAAOF,GAaX,QAAAI,aAA4B1B,EAAYC,GACpC0B,QAAQC,IAAI,eAAgBC,MAAMC,KAAU7B,GAC5C,IAAI8B,GAAM,GAAIC,SAAQ,SAACC,EAASC,GAC5B,GAAIC,GAAmB,IAcvB,OAbIlC,IAASA,EAAMI,OAAS,EACxBC,EAAEQ,KAAKb,EAAO,SAAAmC,GAEND,EADAA,EACKA,EAAGE,KAAK,WACT,MAAOC,WAAUtC,EAAMoC,KAGtBE,UAAUtC,EAAMoC,KAI7BD,EAAKH,QAAQC,UAEVE,EACFE,KAAKJ,GACLM,MAAML,IAEf,OAAOH,GAAIQ,MAAM,SAAAC,GACbb,QAAQc,MAAMZ,MAAMa,IAAIF,IACxBG,QAAQC,KAAK,KAIrB,QAAAN,WAAmBtC,EAAYoC,GAC3B,GAAIS,GAAU,KAAMC,EAAW,IAC/B,OAAO,IAAId,SAAQ,SAACe,EAASb,GACzB,GAAIc,KACJ1C,GAAEQ,KAAKR,EAAEG,QAAQ2B,GAAQA,GAAQA,GAAO,SAAA5B,GACpCwC,EAAOxC,IAAK,IAEhBqC,EAAU,SAACL,GACPG,QAAQC,KAAKJ,GACbb,QAAQc,MAAMZ,MAAMa,IAAIF,IACxBN,EAAOM,IAEXM,EAAW,SAACG,GACRD,EAAOC,EAAEb,OAAQ,EACZ9B,EAAE4C,KAAK5C,EAAE6C,OAAOH,GAAS,SAAAI,GAAA,OAAOA,KACjCL,KAGR/C,EAAKqD,GAAG,YAAaP,GAChBO,GAAG,WAAYR,GACpB7C,EAAKsD,MAAMlB,KAEVC,KAAK,WACErC,EAAA,iBACAA,EAAA,eAAuB,YAAa8C,GACpC9C,EAAA,eAAuB,WAAY6C,KAExC,SAAAL,GACKxC,EAAA,iBACAA,EAAA,eAAuB,YAAa8C,GACpC9C,EAAA,eAAuB,WAAY6C,MAenD,QAAAU,iBAAgCvD,EAAYC,EAAmCC,GAC3E,MAAO8B,SAAQC,QAAQhC,GAClBoC,KAAK,SAAApC,GACF,GAAIuD,GAAUzD,WAAWC,EAAMC,EAAOC,EACtC,OAAOwB,aAAY1B,EAAMwD,KA/JrC,GAAYlD,GAACmD,QAAM,UAEP5B,MAAK4B,QAAM,QAYPC,SAAA3D,WAAUA,WA6CV2D,QAAArC,cAAaA,cAwBbqC,QAAAhC,YAAWA,YAwEXgC,QAAAH,gBAAeA","file":"../taskSequence.js","sourcesContent":["\"use strict\";\nconst _ = require('lodash');\nconst chalk = require('chalk');\n/**\n * convert setup task result to run sequence src.\n *\n * @export\n * @param {Gulp} gulp\n * @param {ITask[]} tasks\n * @param {ITaskConfig} config\n * @returns {Src[]}\n */\nfunction toSequence(gulp, tasks, config) {\n    let seq = [];\n    let len = tasks.length;\n    if (len < 1) {\n        return seq;\n    }\n    tasks = _.orderBy(tasks, t => {\n        if (_.isArray(t)) {\n            return len;\n        }\n        else {\n            let info = t.getInfo();\n            if (_.isNumber(info.order)) {\n                return info.order;\n            }\n            return len;\n        }\n    });\n    _.each(tasks, t => {\n        let info = t.getInfo();\n        if (info.watch && !config.env.watch) {\n            return;\n        }\n        if (!info.oper ||\n            (info.oper && (info.oper & config.oper) > 0)) {\n            let tname = t.setup(config, gulp);\n            tname && seq.push(tname);\n        }\n    });\n    return seq;\n}\nexports.toSequence = toSequence;\n/**\n * add task to task sequence.\n *\n * @export\n * @param {Src[]} taskSequence\n * @param {ITaskInfo} rst\n * @returns\n */\nfunction addToSequence(taskSequence, rst) {\n    if (!rst) {\n        return taskSequence;\n    }\n    if (rst.taskName) {\n        if (_.isNumber(rst.order) && rst.order >= 0 && rst.order < taskSequence.length) {\n            taskSequence.splice(rst.order, 0, rst.taskName);\n            return taskSequence;\n        }\n        taskSequence.push(rst.taskName);\n    }\n    return taskSequence;\n}\nexports.addToSequence = addToSequence;\n/**\n * run task sequence.\n *\n * @protected\n * @param {Gulp} gulp\n * @param {Src[]} tasks\n * @returns {Promise<any>}\n *\n * @memberOf Development\n */\nfunction runSequence(gulp, tasks) {\n    console.log('run tasks : ', chalk.cyan(tasks));\n    let run = new Promise((resolve, reject) => {\n        let ps = null;\n        if (tasks && tasks.length > 0) {\n            _.each(tasks, task => {\n                if (ps) {\n                    ps = ps.then(() => {\n                        return startTask(gulp, task);\n                    });\n                }\n                else {\n                    ps = startTask(gulp, task);\n                }\n            });\n        }\n        else {\n            ps = Promise.resolve();\n        }\n        return ps\n            .then(resolve)\n            .catch(reject);\n    });\n    return run.catch(err => {\n        console.error(chalk.red(err));\n        process.exit(0);\n    });\n}\nexports.runSequence = runSequence;\nfunction startTask(gulp, task) {\n    let taskErr = null, taskStop = null;\n    return new Promise((reslove, reject) => {\n        let tskmap = {};\n        _.each(_.isArray(task) ? task : [task], t => {\n            tskmap[t] = false;\n        });\n        taskErr = (err) => {\n            process.exit(err);\n            console.error(chalk.red(err));\n            reject(err);\n        };\n        taskStop = (e) => {\n            tskmap[e.task] = true;\n            if (!_.some(_.values(tskmap), it => !it)) {\n                reslove();\n            }\n        };\n        gulp.on('task_stop', taskStop)\n            .on('task_err', taskErr);\n        gulp.start(task);\n    })\n        .then(() => {\n        if (gulp['removeListener']) {\n            gulp['removeListener']('task_stop', taskStop);\n            gulp['removeListener']('task_err', taskErr);\n        }\n    }, err => {\n        if (gulp['removeListener']) {\n            gulp['removeListener']('task_stop', taskStop);\n            gulp['removeListener']('task_err', taskErr);\n        }\n        // process.exit(0);\n    });\n}\n/**\n * run task sequence\n *\n * @export\n * @param {Gulp} gulp\n * @param {ITask[] | Promise<ITask[]>} tasks\n * @param {TaskConfig} config\n * @returns {Promise<any>}\n */\nfunction runTaskSequence(gulp, tasks, config) {\n    return Promise.resolve(tasks)\n        .then(tasks => {\n        let taskseq = toSequence(gulp, tasks, config);\n        return runSequence(gulp, taskseq);\n    });\n}\nexports.runTaskSequence = runTaskSequence;\n","import * as _ from 'lodash';\r\nimport { Gulp } from 'gulp';\r\nimport * as chalk from 'chalk';\r\nimport { Src, ITaskInfo, ITaskContext, ITask } from './TaskConfig';\r\n\r\n/**\r\n * convert setup task result to run sequence src.\r\n * \r\n * @export\r\n * @param {Gulp} gulp\r\n * @param {ITask[]} tasks\r\n * @param {ITaskConfig} config\r\n * @returns {Src[]}\r\n */\r\nexport function toSequence(gulp: Gulp, tasks: ITask[], config: ITaskContext): Src[] {\r\n    let seq: Src[] = [];\r\n    let len = tasks.length;\r\n    if (len < 1) {\r\n        return seq;\r\n    }\r\n\r\n    tasks = _.orderBy(tasks, t => {\r\n        if (_.isArray(t)) {\r\n            return len;\r\n        } else {\r\n            let info = t.getInfo();\r\n            if (_.isNumber(info.order)) {\r\n                return info.order;\r\n            }\r\n            return len;\r\n        }\r\n    });\r\n\r\n    _.each(tasks, t => {\r\n        let info = t.getInfo();\r\n        if (info.watch && !config.env.watch) {\r\n            return;\r\n        }\r\n\r\n        if (!info.oper ||\r\n            (info.oper && (info.oper & config.oper) > 0)) {\r\n            let tname = t.setup(config, gulp);\r\n            tname && seq.push(tname);\r\n        }\r\n\r\n    });\r\n\r\n    return seq;\r\n}\r\n\r\n\r\n/**\r\n * add task to task sequence.\r\n * \r\n * @export\r\n * @param {Src[]} taskSequence\r\n * @param {ITaskInfo} rst\r\n * @returns\r\n */\r\nexport function addToSequence(taskSequence: Src[], rst: ITaskInfo) {\r\n    if (!rst) {\r\n        return taskSequence;\r\n    }\r\n    if (rst.taskName) {\r\n        if (_.isNumber(rst.order) && rst.order >= 0 && rst.order < taskSequence.length) {\r\n            taskSequence.splice(rst.order, 0, rst.taskName);\r\n            return taskSequence;\r\n        }\r\n        taskSequence.push(rst.taskName);\r\n    }\r\n    return taskSequence;\r\n}\r\n\r\n/**\r\n * run task sequence.\r\n * \r\n * @protected\r\n * @param {Gulp} gulp\r\n * @param {Src[]} tasks\r\n * @returns {Promise<any>}\r\n * \r\n * @memberOf Development\r\n */\r\nexport function runSequence(gulp: Gulp, tasks: Src[]): Promise<any> {\r\n    console.log('run tasks : ', chalk.cyan(<any>tasks));\r\n    let run = new Promise((resolve, reject) => {\r\n        let ps: Promise<any> = null;\r\n        if (tasks && tasks.length > 0) {\r\n            _.each(tasks, task => {\r\n                if (ps) {\r\n                    ps = ps.then(() => {\r\n                        return startTask(gulp, task);\r\n                    })\r\n                } else {\r\n                    ps = startTask(gulp, task);\r\n                }\r\n            });\r\n        } else {\r\n            ps = Promise.resolve();\r\n        }\r\n        return ps\r\n            .then(resolve)\r\n            .catch(reject);\r\n    });\r\n    return run.catch(err => {\r\n        console.error(chalk.red(err));\r\n        process.exit(0);\r\n    });\r\n}\r\n\r\nfunction startTask(gulp: Gulp, task: Src): Promise<any> {\r\n    let taskErr = null, taskStop = null;\r\n    return new Promise((reslove, reject) => {\r\n        let tskmap: any = {};\r\n        _.each(_.isArray(task) ? task : [task], t => {\r\n            tskmap[t] = false;\r\n        });\r\n        taskErr = (err) => {\r\n            process.exit(err);\r\n            console.error(chalk.red(err));\r\n            reject(err);\r\n        };\r\n        taskStop = (e: any) => {\r\n            tskmap[e.task] = true;\r\n            if (!_.some(_.values(tskmap), it => !it)) {\r\n                reslove();\r\n            }\r\n        }\r\n        gulp.on('task_stop', taskStop)\r\n            .on('task_err', taskErr);\r\n        gulp.start(task);\r\n    })\r\n        .then(() => {\r\n            if (gulp['removeListener']) {\r\n                gulp['removeListener']('task_stop', taskStop);\r\n                gulp['removeListener']('task_err', taskErr);\r\n            }\r\n        }, err => {\r\n            if (gulp['removeListener']) {\r\n                gulp['removeListener']('task_stop', taskStop);\r\n                gulp['removeListener']('task_err', taskErr);\r\n            }\r\n            // process.exit(0);\r\n        });\r\n}\r\n\r\n/**\r\n * run task sequence\r\n * \r\n * @export\r\n * @param {Gulp} gulp\r\n * @param {ITask[] | Promise<ITask[]>} tasks\r\n * @param {TaskConfig} config\r\n * @returns {Promise<any>}\r\n */\r\nexport function runTaskSequence(gulp: Gulp, tasks: ITask[] | Promise<ITask[]>, config: ITaskContext): Promise<any> {\r\n    return Promise.resolve(tasks)\r\n        .then(tasks => {\r\n            let taskseq = toSequence(gulp, tasks, config);\r\n            return runSequence(gulp, taskseq);\r\n        });\r\n}\r\n"]}