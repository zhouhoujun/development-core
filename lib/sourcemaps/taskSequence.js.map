{"version":3,"sources":["taskSequence.js","taskSequence.ts"],"names":["toSequence","gulp","tasks","ctx","seq","len","length","_","orderBy","t","isArray","info","getInfo","isNumber","order","isFunction","hasWatchtasks","each","oper","tname","setup","TaskConfig_1","Operation","watch","push","registerTasks","watchname","taskSequenceWatch","it","indexOf","globals","registerGlobals","task","console","error","chalk","red","cyan","process","exit","express","option","_ret","wats","name","isBoolean","toWatchSeq","filterTaskSequence","first","last","taskname","runSequence","fs","ls","src","getSrc","log","call","v","_typeof","addToSequence","taskSequence","rst","taskName","splice","rseq","isString","filter","itm","run","Promise","resolve","reject","ps","then","startTask","catch","err","taskErr","taskStop","reslove","tskmap","e","some","values","on","start","runTaskSequence","taskseq","require","exports"],"mappings":"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","file":"../taskSequence.js","sourcesContent":["\"use strict\";\nconst _ = require('lodash');\nconst chalk = require('chalk');\nconst TaskConfig_1 = require('./TaskConfig');\n/**\n * convert setup task result to run sequence src.\n *\n * @export\n * @param {Gulp} gulp\n * @param {ITask[]} tasks\n * @param {ITaskContext} ctx\n * @returns {Src[]}\n */\nfunction toSequence(gulp, tasks, ctx) {\n    let seq = [];\n    let len = tasks.length;\n    if (len < 1) {\n        return seq;\n    }\n    tasks = _.orderBy(tasks, (t) => {\n        if (_.isArray(t)) {\n            return len;\n        }\n        else {\n            let info = t.getInfo();\n            if (_.isNumber(info.order)) {\n                return info.order;\n            }\n            else if (_.isFunction(info.order)) {\n                return info.order(len);\n            }\n            return len;\n        }\n    });\n    let hasWatchtasks = [];\n    _.each(tasks, t => {\n        let info = t.getInfo();\n        if (info.oper & ctx.oper) {\n            let tname = t.setup(ctx, gulp);\n            if (tname) {\n                if ((info.oper & TaskConfig_1.Operation.watch)) {\n                    hasWatchtasks.push(tname);\n                }\n                registerTasks(ctx, tname);\n                seq.push(tname);\n            }\n        }\n    });\n    let watchname = taskSequenceWatch(gulp, seq, ctx, it => {\n        if (!it) {\n            return false;\n        }\n        if (hasWatchtasks.length > 0) {\n            return hasWatchtasks.indexOf(it) < 0;\n        }\n        return true;\n    });\n    if (watchname) {\n        registerTasks(ctx, watchname);\n        seq.push(watchname);\n    }\n    return seq;\n}\nexports.toSequence = toSequence;\nfunction registerTasks(ctx, tasks) {\n    ctx.globals.tasks = ctx.globals.tasks || {};\n    if (_.isArray(tasks)) {\n        _.each(tasks, t => registerGlobals(ctx, t));\n    }\n    else {\n        registerGlobals(ctx, tasks);\n    }\n}\nfunction registerGlobals(ctx, task) {\n    if (ctx.globals.tasks[task]) {\n        console.error(chalk.red('has same task:'), chalk.cyan(task));\n        process.exit(0);\n    }\n    else {\n        ctx.globals.tasks[task] = task;\n    }\n}\n/**\n * generate watch task for sequence\n *\n * @export\n * @param {Gulp} gulp\n * @param {Src[]} tasks\n * @param {ITaskContext} ctx\n * @param {(str: string) => boolean} [express]\n * @returns\n */\nfunction taskSequenceWatch(gulp, tasks, ctx, express) {\n    // create watch task.\n    if ((ctx.oper & TaskConfig_1.Operation.watch) && ctx.option.watch) {\n        let wats = [];\n        let name = '';\n        if (_.isBoolean(ctx.option.watch)) {\n            let toWatchSeq = filterTaskSequence(tasks, express);\n            if (toWatchSeq.length > 1) {\n                let first = _.first(toWatchSeq);\n                first = _.isArray(first) ? _.first(first) : first;\n                let last = _.last(toWatchSeq);\n                last = _.isArray(last) ? _.last(last) : last;\n                name = `${first}-${last}`;\n                let taskname = name + '-seq';\n                gulp.task(taskname, () => {\n                    return runSequence(gulp, toWatchSeq);\n                });\n                wats.push(taskname);\n            }\n            else if (toWatchSeq.length === 1) {\n                let first = _.first(toWatchSeq);\n                if (_.isArray(first)) {\n                    let fs = _.first(first);\n                    let ls = _.last(first);\n                    name = `${fs}-${ls}`;\n                    wats = first;\n                }\n                else if (first) {\n                    name = first;\n                    wats.push(first);\n                }\n            }\n        }\n        else {\n            wats = ctx.option.watch;\n        }\n        if (wats.length > 0) {\n            name = name ? name + '-owatch' : 'owatch';\n            gulp.task(name, () => {\n                let src = ctx.getSrc();\n                console.log('watch, src:', chalk.cyan.call(chalk, src));\n                gulp.watch(src, wats);\n            });\n            return name;\n        }\n    }\n    return '';\n}\nexports.taskSequenceWatch = taskSequenceWatch;\n/**\n * add task to task sequence.\n *\n * @export\n * @param {Src[]} taskSequence\n * @param {ITaskInfo} rst\n * @returns\n */\nfunction addToSequence(taskSequence, rst) {\n    if (!rst) {\n        return taskSequence;\n    }\n    if (rst.taskName) {\n        let order = taskSequence.length;\n        if (_.isNumber(rst.order)) {\n            order = rst.order;\n        }\n        else if (_.isFunction(rst.order)) {\n            order = rst.order(order);\n        }\n        if (order >= 0 && order < taskSequence.length) {\n            taskSequence.splice(order, 0, rst.taskName);\n        }\n        else {\n            taskSequence.push(rst.taskName);\n        }\n    }\n    return taskSequence;\n}\nexports.addToSequence = addToSequence;\n/**\n * filter task sequence. make sure no empty.\n *\n * @param {Src[]} seq\n * @param {(str: string) => boolean} [filter]\n * @returns {Src[]}\n */\nfunction filterTaskSequence(seq, express) {\n    let rseq = [];\n    express = express || ((it) => !!it);\n    _.each(seq, it => {\n        if (!it) {\n            return;\n        }\n        if (_.isString(it) && express(it)) {\n            rseq.push(it);\n        }\n        else if (_.isArray(it)) {\n            rseq.push(_.filter(it, itm => express(itm)));\n        }\n    });\n    return rseq;\n}\n/**\n * run task sequence.\n *\n * @protected\n * @param {Gulp} gulp\n * @param {Src[]} tasks\n * @returns {Promise<any>}\n *\n * @memberOf Development\n */\nfunction runSequence(gulp, tasks) {\n    tasks = filterTaskSequence(tasks);\n    console.log('run tasks : ', chalk.cyan(tasks));\n    let run = new Promise((resolve, reject) => {\n        let ps = null;\n        if (tasks && tasks.length > 0) {\n            _.each(tasks, task => {\n                if (ps) {\n                    ps = ps.then(() => {\n                        return startTask(gulp, task);\n                    });\n                }\n                else {\n                    ps = startTask(gulp, task);\n                }\n            });\n        }\n        else {\n            ps = Promise.resolve();\n        }\n        return ps\n            .then(resolve)\n            .catch(reject);\n    });\n    return run.catch(err => {\n        console.error(chalk.red(err));\n        process.exit(0);\n    });\n}\nexports.runSequence = runSequence;\n/**\n * start task.\n *\n * @param {Gulp} gulp\n * @param {Src} task\n * @returns {Promise<any>}\n */\nfunction startTask(gulp, task) {\n    let taskErr = null, taskStop = null;\n    return new Promise((reslove, reject) => {\n        let tskmap = {};\n        _.each(_.isArray(task) ? task : [task], t => {\n            tskmap[t] = false;\n        });\n        taskErr = (err) => {\n            process.exit(err);\n            console.error(chalk.red(err));\n            reject(err);\n        };\n        taskStop = (e) => {\n            tskmap[e.task] = true;\n            if (!_.some(_.values(tskmap), it => !it)) {\n                reslove();\n            }\n        };\n        gulp.on('task_stop', taskStop)\n            .on('task_err', taskErr);\n        gulp.start(task);\n    })\n        .then(() => {\n        if (gulp['removeListener']) {\n            gulp['removeListener']('task_stop', taskStop);\n            gulp['removeListener']('task_err', taskErr);\n        }\n    }, err => {\n        if (gulp['removeListener']) {\n            gulp['removeListener']('task_stop', taskStop);\n            gulp['removeListener']('task_err', taskErr);\n        }\n        // process.exit(0);\n    });\n}\n/**\n * run task sequence\n *\n * @export\n * @param {Gulp} gulp\n * @param {(ITask[] | Promise<ITask[]>)} tasks\n * @param {ITaskContext} ctx\n * @returns {Promise<any>}\n */\nfunction runTaskSequence(gulp, tasks, ctx) {\n    return Promise.resolve(tasks)\n        .then(tasks => {\n        let taskseq = toSequence(gulp, tasks, ctx);\n        return runSequence(gulp, taskseq);\n    });\n}\nexports.runTaskSequence = runTaskSequence;\n","import * as _ from 'lodash';\r\nimport { Gulp } from 'gulp';\r\nimport * as chalk from 'chalk';\r\nimport { Src, ITaskInfo, ITaskContext, ITask, Operation } from './TaskConfig';\r\n/**\r\n * convert setup task result to run sequence src.\r\n * \r\n * @export\r\n * @param {Gulp} gulp\r\n * @param {ITask[]} tasks\r\n * @param {ITaskContext} ctx\r\n * @returns {Src[]}\r\n */\r\nexport function toSequence(gulp: Gulp, tasks: ITask[], ctx: ITaskContext): Src[] {\r\n    let seq: Src[] = [];\r\n    let len = tasks.length;\r\n    if (len < 1) {\r\n        return seq;\r\n    }\r\n\r\n    tasks = _.orderBy(tasks, (t: ITask) => {\r\n        if (_.isArray(t)) {\r\n            return len;\r\n        } else {\r\n            let info = t.getInfo();\r\n            if (_.isNumber(info.order)) {\r\n                return info.order;\r\n            } else if (_.isFunction(info.order)) {\r\n                return info.order(len);\r\n            }\r\n            return len;\r\n        }\r\n    });\r\n\r\n    let hasWatchtasks = [];\r\n    _.each(tasks, t => {\r\n        let info = t.getInfo();\r\n        if (info.oper & ctx.oper) {\r\n            let tname = t.setup(ctx, gulp);\r\n            if (tname) {\r\n                if ((info.oper & Operation.watch)) {\r\n                    hasWatchtasks.push(tname);\r\n                }\r\n                registerTasks(ctx, tname);\r\n\r\n                seq.push(tname);\r\n            }\r\n        }\r\n    });\r\n\r\n    let watchname = taskSequenceWatch(gulp, seq, ctx, it => {\r\n        if (!it) {\r\n            return false;\r\n        }\r\n        if (hasWatchtasks.length > 0) {\r\n            return hasWatchtasks.indexOf(it) < 0;\r\n        }\r\n        return true;\r\n    });\r\n    if (watchname) {\r\n        registerTasks(ctx, watchname);\r\n        seq.push(watchname);\r\n    }\r\n\r\n    return seq;\r\n}\r\n\r\nfunction registerTasks(ctx: ITaskContext, tasks: Src) {\r\n    ctx.globals.tasks = ctx.globals.tasks || {};\r\n    if (_.isArray(tasks)) {\r\n        _.each(tasks, t => registerGlobals(ctx, t));\r\n    } else {\r\n        registerGlobals(ctx, tasks);\r\n    }\r\n}\r\nfunction registerGlobals(ctx: ITaskContext, task: string) {\r\n\r\n    if (ctx.globals.tasks[task]) {\r\n        console.error(chalk.red('has same task:'), chalk.cyan(task));\r\n        process.exit(0);\r\n    } else {\r\n        ctx.globals.tasks[task] = task;\r\n    }\r\n}\r\n\r\n/**\r\n * generate watch task for sequence\r\n * \r\n * @export\r\n * @param {Gulp} gulp\r\n * @param {Src[]} tasks\r\n * @param {ITaskContext} ctx\r\n * @param {(str: string) => boolean} [express]\r\n * @returns\r\n */\r\nexport function taskSequenceWatch(gulp: Gulp, tasks: Src[], ctx: ITaskContext, express?: (str: string) => boolean) {\r\n    // create watch task.\r\n    if ((ctx.oper & Operation.watch) && ctx.option.watch) {\r\n        let wats = [];\r\n        let name = '';\r\n        if (_.isBoolean(ctx.option.watch)) {\r\n            let toWatchSeq = filterTaskSequence(tasks, express)\r\n\r\n            if (toWatchSeq.length > 1) {\r\n                let first = _.first(toWatchSeq);\r\n                first = _.isArray(first) ? _.first(first) : first;\r\n                let last = _.last(toWatchSeq);\r\n                last = _.isArray(last) ? _.last(last) : last;\r\n                name = `${first}-${last}`;\r\n                let taskname = name + '-seq';\r\n                gulp.task(taskname, () => {\r\n                    return runSequence(gulp, toWatchSeq);\r\n                });\r\n                wats.push(taskname);\r\n            } else if (toWatchSeq.length === 1) {\r\n                let first = _.first(toWatchSeq);\r\n                if (_.isArray(first)) {\r\n                    let fs = _.first(first);\r\n                    let ls = _.last(first);\r\n                    name = `${fs}-${ls}`;\r\n                    wats = first;\r\n                } else if (first) {\r\n                    name = first;\r\n                    wats.push(first);\r\n                }\r\n            }\r\n\r\n        } else {\r\n            wats = ctx.option.watch;\r\n        }\r\n\r\n        if (wats.length > 0) {\r\n            name = name ? name + '-owatch' : 'owatch';\r\n            gulp.task(name, () => {\r\n                let src = ctx.getSrc();\r\n                console.log('watch, src:', chalk.cyan.call(chalk, src));\r\n                gulp.watch(src, wats)\r\n            });\r\n            return name;\r\n        }\r\n    }\r\n    return '';\r\n}\r\n\r\n/**\r\n * add task to task sequence.\r\n * \r\n * @export\r\n * @param {Src[]} taskSequence\r\n * @param {ITaskInfo} rst\r\n * @returns\r\n */\r\nexport function addToSequence(taskSequence: Src[], rst: ITaskInfo) {\r\n    if (!rst) {\r\n        return taskSequence;\r\n    }\r\n    if (rst.taskName) {\r\n        let order = taskSequence.length;\r\n        if (_.isNumber(rst.order)) {\r\n            order = rst.order;\r\n        } else if (_.isFunction(rst.order)) {\r\n            order = rst.order(order)\r\n        }\r\n\r\n        if (order >= 0 && order < taskSequence.length) {\r\n            taskSequence.splice(order, 0, rst.taskName);\r\n        } else {\r\n            taskSequence.push(rst.taskName);\r\n        }\r\n    }\r\n    return taskSequence;\r\n}\r\n\r\n\r\n/**\r\n * filter task sequence. make sure no empty.\r\n * \r\n * @param {Src[]} seq\r\n * @param {(str: string) => boolean} [filter]\r\n * @returns {Src[]}\r\n */\r\nfunction filterTaskSequence(seq: Src[], express?: (str: string) => boolean): Src[] {\r\n    let rseq: Src[] = [];\r\n    express = express || ((it) => !!it);\r\n    _.each(seq, it => {\r\n        if (!it) {\r\n            return;\r\n        }\r\n        if (_.isString(it) && express(it)) {\r\n            rseq.push(it);\r\n        } else if (_.isArray(it)) {\r\n            rseq.push(_.filter(it, itm => express(itm)));\r\n        }\r\n    });\r\n    return rseq;\r\n}\r\n/**\r\n * run task sequence.\r\n * \r\n * @protected\r\n * @param {Gulp} gulp\r\n * @param {Src[]} tasks\r\n * @returns {Promise<any>}\r\n * \r\n * @memberOf Development\r\n */\r\nexport function runSequence(gulp: Gulp, tasks: Src[]): Promise<any> {\r\n    tasks = filterTaskSequence(tasks);\r\n    console.log('run tasks : ', chalk.cyan(<any>tasks));\r\n    let run = new Promise((resolve, reject) => {\r\n        let ps: Promise<any> = null;\r\n        if (tasks && tasks.length > 0) {\r\n            _.each(tasks, task => {\r\n                if (ps) {\r\n                    ps = ps.then(() => {\r\n                        return startTask(gulp, task);\r\n                    })\r\n                } else {\r\n                    ps = startTask(gulp, task);\r\n                }\r\n            });\r\n        } else {\r\n            ps = Promise.resolve();\r\n        }\r\n        return ps\r\n            .then(resolve)\r\n            .catch(reject);\r\n    });\r\n    return run.catch(err => {\r\n        console.error(chalk.red(err));\r\n        process.exit(0);\r\n    });\r\n}\r\n\r\n/**\r\n * start task.\r\n * \r\n * @param {Gulp} gulp\r\n * @param {Src} task\r\n * @returns {Promise<any>}\r\n */\r\nfunction startTask(gulp: Gulp, task: Src): Promise<any> {\r\n    let taskErr = null, taskStop = null;\r\n    return new Promise((reslove, reject) => {\r\n        let tskmap: any = {};\r\n        _.each(_.isArray(task) ? task : [task], t => {\r\n            tskmap[t] = false;\r\n        });\r\n        taskErr = (err) => {\r\n            process.exit(err);\r\n            console.error(chalk.red(err));\r\n            reject(err);\r\n        };\r\n        taskStop = (e: any) => {\r\n            tskmap[e.task] = true;\r\n            if (!_.some(_.values(tskmap), it => !it)) {\r\n                reslove();\r\n            }\r\n        }\r\n        gulp.on('task_stop', taskStop)\r\n            .on('task_err', taskErr);\r\n        gulp.start(task);\r\n    })\r\n        .then(() => {\r\n            if (gulp['removeListener']) {\r\n                gulp['removeListener']('task_stop', taskStop);\r\n                gulp['removeListener']('task_err', taskErr);\r\n            }\r\n        }, err => {\r\n            if (gulp['removeListener']) {\r\n                gulp['removeListener']('task_stop', taskStop);\r\n                gulp['removeListener']('task_err', taskErr);\r\n            }\r\n            // process.exit(0);\r\n        });\r\n}\r\n\r\n/**\r\n * run task sequence\r\n * \r\n * @export\r\n * @param {Gulp} gulp\r\n * @param {(ITask[] | Promise<ITask[]>)} tasks\r\n * @param {ITaskContext} ctx\r\n * @returns {Promise<any>}\r\n */\r\nexport function runTaskSequence(gulp: Gulp, tasks: ITask[] | Promise<ITask[]>, ctx: ITaskContext): Promise<any> {\r\n    return Promise.resolve(tasks)\r\n        .then(tasks => {\r\n            let taskseq = toSequence(gulp, tasks, ctx);\r\n            return runSequence(gulp, taskseq);\r\n        });\r\n}\r\n"]}