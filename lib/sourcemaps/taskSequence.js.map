{"version":3,"sources":["taskSequence.js","taskSequence.ts"],"names":["toSequence","gulp","tasks","ctx","zipName","seq","len","length","taskseq","utils_1","sortOrder","t","getInfo","order","hasWatchtasks","callback","watch","push","_","each","tk","isArray","pallSeq","setupTask","ps","flattenSequence","concat","watchname","taskSequenceWatch","it","indexOf","registerTasks","info","oper","tname","setup","TaskConfig_1","Operation","autoWatch","wname","task","src","getSrc","console","log","chalk","cyan","call","cb","runSequence","globals","registerGlobals","hasRegistered","error","red","express","option","_ret3","wats","name","isBoolean","toWatchSeq","filterTaskSequence","zipSequence","v","_typeof","registerZipTask","i","taskname","first","last","RunWay","sequence","fs","ls","parallel","result","zipSrc","some","addToSequence","taskSequence","rst","taskName","isNumber","isFunction","val","value","parseInt","toFixed","seqMax","splice","rseq","isString","filter","itm","run","Promise","resolve","reject","then","startTask","catch","err","taskErr","taskStop","reslove","tskmap","process","exit","e","values","on","start","runTaskSequence","require","exports"],"mappings":"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","file":"../taskSequence.js","sourcesContent":["\"use strict\";\nconst _ = require('lodash');\nconst chalk = require('chalk');\nconst TaskConfig_1 = require('./TaskConfig');\nconst utils_1 = require('./utils');\nconst watch = require('gulp-watch');\n/**\n * convert setup task result to run sequence src.\n *\n * @export\n * @param {Gulp} gulp\n * @param {ITask[]} tasks\n * @param {ITaskContext} ctx\n * @param {ZipTaskName} [zipName]\n * @returns {Src[]}\n */\nfunction toSequence(gulp, tasks, ctx, zipName) {\n    let seq = [];\n    let len = tasks.length;\n    if (len < 1) {\n        return seq;\n    }\n    let taskseq = utils_1.sortOrder(tasks, t => t.getInfo().order, ctx);\n    let hasWatchtasks = [];\n    let callback = watch => hasWatchtasks.push(watch);\n    _.each(taskseq, tk => {\n        if (_.isArray(tk)) {\n            let pallSeq = [];\n            _.each(tk, t => {\n                pallSeq.push(setupTask(gulp, t, ctx, callback));\n            });\n            let ps = flattenSequence(gulp, pallSeq, ctx, zipName);\n            if (ps && ps.length > 0) {\n                seq.push(ps);\n            }\n        }\n        else {\n            seq = seq.concat(setupTask(gulp, tk, ctx, callback));\n        }\n    });\n    let watchname = taskSequenceWatch(gulp, seq, ctx, it => {\n        if (!it) {\n            return false;\n        }\n        if (hasWatchtasks.length > 0) {\n            return hasWatchtasks.indexOf(it) < 0;\n        }\n        return true;\n    }, zipName);\n    if (watchname) {\n        registerTasks(ctx, watchname);\n        seq.push(watchname);\n    }\n    return seq;\n}\nexports.toSequence = toSequence;\nfunction setupTask(gulp, t, ctx, callback) {\n    let seq = [];\n    let info = t.getInfo();\n    if (info.oper & ctx.oper) {\n        let tname = ctx.setup(t, gulp); // t.setup(ctx, gulp);\n        if (tname) {\n            // is watch task.\n            if ((info.oper & TaskConfig_1.Operation.watch)) {\n                callback(tname);\n            }\n            registerTasks(ctx, tname);\n            if (_.isArray(tname)) {\n                seq = tname;\n            }\n            else {\n                seq.push(tname);\n            }\n            // autoWatch\n            if ((ctx.oper & TaskConfig_1.Operation.watch) && (info.oper & TaskConfig_1.Operation.autoWatch)) {\n                let wname = tname + '-twatch';\n                registerTasks(ctx, wname);\n                gulp.task(wname, () => {\n                    let src = ctx.getSrc(info);\n                    console.log('watch, src:', chalk.cyan.call(chalk, src));\n                    watch(src, (cb) => {\n                        runSequence(gulp, _.isArray(tname) ? tname : [tname]);\n                    });\n                });\n                callback(wname);\n                seq.push(wname);\n            }\n        }\n    }\n    return seq;\n}\nfunction registerTasks(ctx, tasks) {\n    ctx.globals.tasks = ctx.globals.tasks || {};\n    if (_.isArray(tasks)) {\n        _.each(tasks, t => registerGlobals(ctx, t));\n    }\n    else {\n        registerGlobals(ctx, tasks);\n    }\n}\nfunction hasRegistered(ctx, task) {\n    ctx.globals.tasks = ctx.globals.tasks || {};\n    return (ctx.globals.tasks[task]) ? true : false;\n}\nfunction registerGlobals(ctx, task) {\n    if (ctx.globals.tasks[task]) {\n        console.error(chalk.red('has same task:'), chalk.cyan(task));\n    }\n    else {\n        ctx.globals.tasks[task] = task;\n    }\n}\n/**\n * generate watch task for sequence\n *\n * @export\n * @param {Gulp} gulp\n * @param {Src[]} tasks\n * @param {ITaskContext} ctx\n * @param {(str: string) => boolean} [express]\n * @param {ZipTaskName} [zipName]\n * @returns {string}\n */\nfunction taskSequenceWatch(gulp, tasks, ctx, express, zipName) {\n    // create watch task.\n    if ((ctx.oper & TaskConfig_1.Operation.watch) && ctx.option.watch) {\n        let wats = [];\n        let name = '';\n        if (_.isBoolean(ctx.option.watch)) {\n            let toWatchSeq = filterTaskSequence(tasks, express);\n            name = zipSequence(gulp, toWatchSeq, ctx, zipName);\n            name && wats.push(name);\n        }\n        else {\n            wats = ctx.option.watch;\n        }\n        if (wats.length > 0) {\n            name = name ? name + '-owatch' : 'owatch';\n            gulp.task(name, () => {\n                let src = ctx.getSrc();\n                console.log('watch, src:', chalk.cyan.call(chalk, src));\n                watch(src, () => {\n                    runSequence(gulp, wats);\n                });\n            });\n            return name;\n        }\n    }\n    return '';\n}\nexports.taskSequenceWatch = taskSequenceWatch;\nfunction registerZipTask(gulp, name, tasks, ctx) {\n    let i = 0;\n    let taskname = name;\n    while (hasRegistered(ctx, taskname) && i < 50) {\n        taskname = name + i;\n        console.log('try register name: ', chalk.cyan(taskname));\n        i++;\n    }\n    if (i >= 50) {\n        console.error(chalk.red('has same task:'), chalk.cyan(name), 'too many times.');\n        return '';\n    }\n    registerGlobals(ctx, taskname);\n    gulp.task(taskname, () => {\n        return runSequence(gulp, tasks);\n    });\n    return taskname;\n}\n/**\n * zip tasks to a single task.\n *\n * @export\n * @param {Gulp} gulp\n * @param {Src[]} tasks\n * @param {ITaskContext} ctx\n * @param {ZipTaskName} [zipName]\n * @returns {string}\n */\nfunction zipSequence(gulp, tasks, ctx, zipName) {\n    if (tasks.length > 1) {\n        let first = _.first(tasks);\n        first = _.isArray(first) ? _.first(first) : first;\n        let last = _.last(tasks);\n        last = _.isArray(last) ? _.last(last) : last;\n        let name = `${first}-${last}`;\n        name = zipName ? zipName(name, TaskConfig_1.RunWay.sequence, ctx) : name + '-seq';\n        return registerZipTask(gulp, name, tasks, ctx);\n    }\n    else if (tasks.length === 1) {\n        let first = _.first(tasks);\n        if (_.isArray(first)) {\n            if (first.length > 1) {\n                let fs = _.first(first);\n                let ls = _.last(first);\n                let name = `${fs}-${ls}`;\n                name = zipName ? zipName(name, TaskConfig_1.RunWay.parallel, ctx) : name + '-paral';\n                return registerZipTask(gulp, name, tasks, ctx);\n            }\n            else {\n                return _.first(first) || '';\n            }\n        }\n        else {\n            return first || '';\n        }\n    }\n    return '';\n}\nexports.zipSequence = zipSequence;\n/**\n * flatten task Sequence.\n *\n * @export\n * @param {Gulp} gulp\n * @param {Src[]} tasks\n * @param {ITaskContext} ctx\n * @param {ZipTaskName} [zipName]\n * @returns {string[]}\n */\nfunction flattenSequence(gulp, tasks, ctx, zipName) {\n    let result = [];\n    _.each(tasks, tk => {\n        if (_.isArray(tk)) {\n            let zipSrc = (_.some(tk, t => _.isArray(t))) ? tk : [tk];\n            let taskname = zipSequence(gulp, zipSrc, ctx, zipName);\n            taskname && result.push(taskname);\n        }\n        else {\n            result.push(tk);\n        }\n    });\n    return result;\n}\nexports.flattenSequence = flattenSequence;\n/**\n * add task to task sequence.\n *\n * @export\n * @param {Src[]} taskSequence\n * @param {ITaskInfo} rst\n * @param {ITaskContext} [ctx]\n * @returns {Src[]}\n */\nfunction addToSequence(taskSequence, rst, ctx) {\n    if (!rst) {\n        return taskSequence;\n    }\n    if (rst.taskName) {\n        let order = 1;\n        let len = taskSequence.length + 1;\n        if (_.isNumber(rst.order)) {\n            order = rst.order;\n        }\n        else if (_.isFunction(rst.order)) {\n            let val = rst.order(len, ctx);\n            order = _.isNumber(val) ? val : val.value;\n        }\n        else if (rst.order && _.isNumber(rst.order.value)) {\n            order = rst.order.value;\n        }\n        if (order > 0 && order < 1) {\n            order = order * len;\n        }\n        else if (order === 1) {\n            order = len;\n        }\n        else if (order > len) {\n            order = order % len;\n        }\n        order = parseInt(order.toFixed(0));\n        if (order < 0) {\n            order = 0;\n        }\n        let seqMax = len - 2;\n        console.log(order);\n        if (order >= 0 && order <= seqMax) {\n            taskSequence.splice(order, 0, rst.taskName);\n        }\n        else if (order > seqMax && order < len) {\n            taskSequence.splice(seqMax - (seqMax - order), 0, rst.taskName);\n        }\n        else {\n            taskSequence.push(rst.taskName);\n        }\n    }\n    return taskSequence;\n}\nexports.addToSequence = addToSequence;\n/**\n * filter task sequence. make sure no empty.\n *\n * @param {Src[]} seq\n * @param {(str: string) => boolean} [filter]\n * @returns {Src[]}\n */\nfunction filterTaskSequence(seq, express) {\n    let rseq = [];\n    express = express || ((it) => !!it);\n    _.each(seq, it => {\n        if (!it) {\n            return;\n        }\n        if (_.isString(it) && express(it)) {\n            rseq.push(it);\n        }\n        else if (_.isArray(it)) {\n            rseq.push(_.filter(it, itm => express(itm)));\n        }\n    });\n    return rseq;\n}\n/**\n * run task sequence.\n *\n * @protected\n * @param {Gulp} gulp\n * @param {Src[]} tasks\n * @returns {Promise<any>}\n *\n * @memberOf Development\n */\nfunction runSequence(gulp, tasks) {\n    tasks = filterTaskSequence(tasks);\n    console.log(chalk.cyan('run tasks : '), tasks);\n    let run = new Promise((resolve, reject) => {\n        let ps = null;\n        if (tasks && tasks.length > 0) {\n            _.each(tasks, task => {\n                if (ps) {\n                    ps = ps.then(() => {\n                        return startTask(gulp, task);\n                    });\n                }\n                else {\n                    ps = startTask(gulp, task);\n                }\n            });\n        }\n        else {\n            ps = Promise.resolve();\n        }\n        return ps\n            .then(resolve)\n            .catch(reject);\n    });\n    return run.catch(err => {\n        console.error(chalk.red(err));\n        // process.exit(0);\n    });\n}\nexports.runSequence = runSequence;\n/**\n * start task.\n *\n * @param {Gulp} gulp\n * @param {Src} task\n * @returns {Promise<any>}\n */\nfunction startTask(gulp, task) {\n    let taskErr = null, taskStop = null;\n    return new Promise((reslove, reject) => {\n        let tskmap = {};\n        _.each(_.isArray(task) ? task : [task], t => {\n            tskmap[t] = false;\n        });\n        taskErr = (err) => {\n            process.exit(err);\n            console.error(chalk.red(err));\n            reject(err);\n        };\n        taskStop = (e) => {\n            if (tskmap[e.task] === false) {\n                tskmap[e.task] = true;\n            }\n            if (!_.some(_.values(tskmap), it => !it)) {\n                reslove();\n            }\n        };\n        if (gulp['setMaxListeners']) {\n            gulp['setMaxListeners'](100);\n        }\n        gulp.on('task_stop', taskStop)\n            .on('task_err', taskErr);\n        gulp.start(task);\n    })\n        .then(() => {\n        if (gulp['removeListener']) {\n            gulp['removeListener']('task_stop', taskStop);\n            gulp['removeListener']('task_err', taskErr);\n        }\n    }, err => {\n        if (gulp['removeListener']) {\n            gulp['removeListener']('task_stop', taskStop);\n            gulp['removeListener']('task_err', taskErr);\n        }\n        // process.exit(0);\n    });\n}\n// function start(gulp: Gulp, taskname: string): Promise<any> {\n//     let taskErr = null, taskStop = null;\n//     return new Promise((reslove, reject) => {\n//         taskErr = (err) => {\n//             process.exit(err);\n//             console.error(chalk.red(err));\n//             reject(err);\n//         };\n//         taskStop = (e: any) => {\n//             if (e.task === taskname) {\n//                 reslove();\n//             }\n//         }\n//         gulp.on('task_stop', taskStop)\n//             .on('task_err', taskErr);\n//         gulp.start(taskname);\n//     })\n//         .then(() => {\n//             if (gulp['removeListener']) {\n//                 gulp['removeListener']('task_stop', taskStop);\n//                 gulp['removeListener']('task_err', taskErr);\n//             }\n//         }, err => {\n//             if (gulp['removeListener']) {\n//                 gulp['removeListener']('task_stop', taskStop);\n//                 gulp['removeListener']('task_err', taskErr);\n//             }\n//             // process.exit(0);\n//         });\n// }\n/**\n * run task sequence\n *\n * @export\n * @param {Gulp} gulp\n * @param {(ITask[] | Promise<ITask[]>)} tasks\n * @param {ITaskContext} ctx\n * @param {ZipTaskName} [zipName]\n * @returns {Promise<any>}\n */\nfunction runTaskSequence(gulp, tasks, ctx, zipName) {\n    return Promise.resolve(tasks)\n        .then(tasks => {\n        let taskseq = toSequence(gulp, tasks, ctx, zipName);\n        return runSequence(gulp, taskseq);\n    });\n}\nexports.runTaskSequence = runTaskSequence;\n","import * as _ from 'lodash';\r\nimport { Gulp } from 'gulp';\r\nimport * as chalk from 'chalk';\r\nimport { Src, RunWay, ITaskInfo, ITaskContext, ITask, Operation } from './TaskConfig';\r\nimport { sortOrder } from './utils';\r\nimport * as watch from 'gulp-watch';\r\n\r\nexport type ZipTaskName = (name: string, runWay?: RunWay, ctx?: ITaskContext) => string\r\n/**\r\n * convert setup task result to run sequence src.\r\n * \r\n * @export\r\n * @param {Gulp} gulp\r\n * @param {ITask[]} tasks\r\n * @param {ITaskContext} ctx\r\n * @param {ZipTaskName} [zipName]\r\n * @returns {Src[]}\r\n */\r\nexport function toSequence(gulp: Gulp, tasks: ITask[], ctx: ITaskContext, zipName?: ZipTaskName): Src[] {\r\n    let seq: Src[] = [];\r\n    let len = tasks.length;\r\n    if (len < 1) {\r\n        return seq;\r\n    }\r\n    let taskseq = sortOrder<ITask>(tasks, t => t.getInfo().order, ctx);\r\n\r\n    let hasWatchtasks = [];\r\n    let callback = watch => hasWatchtasks.push(watch);\r\n    _.each(taskseq, tk => {\r\n        if (_.isArray(tk)) {\r\n            let pallSeq: Src[] = [];\r\n            _.each(tk, t => {\r\n                pallSeq.push(setupTask(gulp, t, ctx, callback));\r\n            });\r\n            let ps: Src = flattenSequence(gulp, pallSeq, ctx, zipName);\r\n            if (ps && ps.length > 0) {\r\n                seq.push(ps);\r\n            }\r\n        } else {\r\n            seq = seq.concat(setupTask(gulp, tk, ctx, callback));\r\n        }\r\n    });\r\n\r\n    let watchname = taskSequenceWatch(gulp, seq, ctx, it => {\r\n        if (!it) {\r\n            return false;\r\n        }\r\n        if (hasWatchtasks.length > 0) {\r\n            return hasWatchtasks.indexOf(it) < 0;\r\n        }\r\n        return true;\r\n    }, zipName);\r\n    if (watchname) {\r\n        registerTasks(ctx, watchname);\r\n        seq.push(watchname);\r\n    }\r\n\r\n    return seq;\r\n}\r\n\r\nfunction setupTask(gulp: Gulp, t: ITask, ctx: ITaskContext, callback: (name: Src) => void): string[] {\r\n    let seq: string[] = [];\r\n    let info = t.getInfo();\r\n    if (info.oper & ctx.oper) {\r\n        let tname = ctx.setup(t, gulp); // t.setup(ctx, gulp);\r\n        if (tname) {\r\n            // is watch task.\r\n            if ((info.oper & Operation.watch)) {\r\n                callback(tname);\r\n            }\r\n            registerTasks(ctx, tname);\r\n            if (_.isArray(tname)) {\r\n                seq = tname;\r\n            } else {\r\n                seq.push(tname);\r\n            }\r\n            // autoWatch\r\n            if ((ctx.oper & Operation.watch) && (info.oper & Operation.autoWatch)) {\r\n                let wname = tname + '-twatch';\r\n                registerTasks(ctx, wname);\r\n                gulp.task(wname, () => {\r\n                    let src = ctx.getSrc(info);\r\n                    console.log('watch, src:', chalk.cyan.call(chalk, src));\r\n                    watch(src, (cb) => {\r\n                        runSequence(gulp, _.isArray(tname) ? tname : [<string>tname]);\r\n                    });\r\n                });\r\n\r\n                callback(wname);\r\n                seq.push(wname);\r\n            }\r\n        }\r\n    }\r\n    return seq;\r\n}\r\n\r\nfunction registerTasks(ctx: ITaskContext, tasks: Src) {\r\n    ctx.globals.tasks = ctx.globals.tasks || {};\r\n    if (_.isArray(tasks)) {\r\n        _.each(tasks, t => registerGlobals(ctx, t));\r\n    } else {\r\n        registerGlobals(ctx, tasks);\r\n    }\r\n}\r\n\r\nfunction hasRegistered(ctx: ITaskContext, task: string) {\r\n    ctx.globals.tasks = ctx.globals.tasks || {};\r\n    return (ctx.globals.tasks[task]) ? true : false;\r\n}\r\n\r\nfunction registerGlobals(ctx: ITaskContext, task: string) {\r\n    if (ctx.globals.tasks[task]) {\r\n        console.error(chalk.red('has same task:'), chalk.cyan(task));\r\n    } else {\r\n        ctx.globals.tasks[task] = task;\r\n    }\r\n}\r\n\r\n/**\r\n * generate watch task for sequence\r\n * \r\n * @export\r\n * @param {Gulp} gulp\r\n * @param {Src[]} tasks\r\n * @param {ITaskContext} ctx\r\n * @param {(str: string) => boolean} [express]\r\n * @param {ZipTaskName} [zipName]\r\n * @returns {string}\r\n */\r\nexport function taskSequenceWatch(gulp: Gulp, tasks: Src[], ctx: ITaskContext, express?: (str: string) => boolean, zipName?: ZipTaskName): string {\r\n    // create watch task.\r\n    if ((ctx.oper & Operation.watch) && ctx.option.watch) {\r\n        let wats = [];\r\n        let name = '';\r\n        if (_.isBoolean(ctx.option.watch)) {\r\n            let toWatchSeq = filterTaskSequence(tasks, express);\r\n            name = zipSequence(gulp, toWatchSeq, ctx, zipName);\r\n            name && wats.push(name);\r\n        } else {\r\n            wats = ctx.option.watch;\r\n        }\r\n\r\n        if (wats.length > 0) {\r\n            name = name ? name + '-owatch' : 'owatch';\r\n            gulp.task(name, () => {\r\n                let src = ctx.getSrc();\r\n                console.log('watch, src:', chalk.cyan.call(chalk, src));\r\n                watch(src, () => {\r\n                    runSequence(gulp, wats)\r\n                })\r\n            });\r\n            return name;\r\n        }\r\n    }\r\n    return '';\r\n}\r\n\r\nfunction registerZipTask(gulp: Gulp, name: string, tasks: Src[], ctx: ITaskContext) {\r\n    let i = 0;\r\n    let taskname = name;\r\n    while (hasRegistered(ctx, taskname) && i < 50) {\r\n        taskname = name + i;\r\n        console.log('try register name: ', chalk.cyan(taskname));\r\n        i++;\r\n    }\r\n    if (i >= 50) {\r\n        console.error(chalk.red('has same task:'), chalk.cyan(name), 'too many times.');\r\n        return '';\r\n    }\r\n\r\n    registerGlobals(ctx, taskname);\r\n    gulp.task(taskname, () => {\r\n        return runSequence(gulp, tasks);\r\n    });\r\n    return taskname;\r\n}\r\n\r\n/**\r\n * zip tasks to a single task.\r\n * \r\n * @export\r\n * @param {Gulp} gulp\r\n * @param {Src[]} tasks\r\n * @param {ITaskContext} ctx\r\n * @param {ZipTaskName} [zipName]\r\n * @returns {string}\r\n */\r\nexport function zipSequence(gulp: Gulp, tasks: Src[], ctx: ITaskContext, zipName?: ZipTaskName): string {\r\n    if (tasks.length > 1) {\r\n        let first = _.first(tasks);\r\n        first = _.isArray(first) ? _.first(first) : first;\r\n        let last = _.last(tasks);\r\n        last = _.isArray(last) ? _.last(last) : last;\r\n        let name = `${first}-${last}`;\r\n        name = zipName ? zipName(name, RunWay.sequence, ctx) : name + '-seq';\r\n        return registerZipTask(gulp, name, tasks, ctx);\r\n\r\n    } else if (tasks.length === 1) {\r\n        let first = _.first(tasks);\r\n        if (_.isArray(first)) {\r\n            if (first.length > 1) {\r\n                let fs = _.first(first);\r\n                let ls = _.last(first);\r\n                let name = `${fs}-${ls}`;\r\n                name = zipName ? zipName(name, RunWay.parallel, ctx) : name + '-paral';\r\n                return registerZipTask(gulp, name, tasks, ctx);\r\n            } else {\r\n                return _.first(first) || '';\r\n            }\r\n        } else {\r\n            return first || '';\r\n        }\r\n    }\r\n\r\n    return '';\r\n}\r\n\r\n/**\r\n * flatten task Sequence.\r\n * \r\n * @export\r\n * @param {Gulp} gulp\r\n * @param {Src[]} tasks\r\n * @param {ITaskContext} ctx\r\n * @param {ZipTaskName} [zipName]\r\n * @returns {string[]}\r\n */\r\nexport function flattenSequence(gulp: Gulp, tasks: Src[], ctx: ITaskContext, zipName?: ZipTaskName): string[] {\r\n    let result: string[] = [];\r\n    _.each(tasks, tk => {\r\n        if (_.isArray(tk)) {\r\n            let zipSrc: Src[] = (_.some(tk, t => _.isArray(t))) ? tk : [tk];\r\n            let taskname = zipSequence(gulp, zipSrc, ctx, zipName);\r\n            taskname && result.push(taskname);\r\n        } else {\r\n            result.push(tk);\r\n        }\r\n    });\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * add task to task sequence.\r\n * \r\n * @export\r\n * @param {Src[]} taskSequence\r\n * @param {ITaskInfo} rst\r\n * @param {ITaskContext} [ctx]\r\n * @returns {Src[]}\r\n */\r\nexport function addToSequence(taskSequence: Src[], rst: ITaskInfo, ctx?: ITaskContext): Src[] {\r\n    if (!rst) {\r\n        return taskSequence;\r\n    }\r\n    if (rst.taskName) {\r\n        let order = 1;\r\n        let len = taskSequence.length + 1;\r\n        if (_.isNumber(rst.order)) {\r\n            order = rst.order;\r\n        } else if (_.isFunction(rst.order)) {\r\n            let val = rst.order(len, ctx);\r\n            order = _.isNumber(val) ? val : val.value\r\n        } else if (rst.order && _.isNumber(rst.order.value)) {\r\n            order = rst.order.value;\r\n        }\r\n\r\n\r\n        if (order > 0 && order < 1) {\r\n            order = order * len;\r\n        } else if (order === 1) {\r\n            order = len;\r\n        } else if (order > len) {\r\n            order = order % len;\r\n        }\r\n\r\n        order = parseInt(order.toFixed(0));\r\n\r\n        if (order < 0) {\r\n            order = 0;\r\n        }\r\n\r\n        let seqMax = len - 2;\r\n        console.log(order);\r\n        if (order >= 0 && order <= seqMax) {\r\n            taskSequence.splice(order, 0, rst.taskName);\r\n        } else if (order > seqMax && order < len) {\r\n            taskSequence.splice(seqMax - (seqMax - order), 0, rst.taskName);\r\n        } else {\r\n            taskSequence.push(rst.taskName);\r\n        }\r\n    }\r\n    return taskSequence;\r\n}\r\n\r\n\r\n/**\r\n * filter task sequence. make sure no empty.\r\n * \r\n * @param {Src[]} seq\r\n * @param {(str: string) => boolean} [filter]\r\n * @returns {Src[]}\r\n */\r\nfunction filterTaskSequence(seq: Src[], express?: (str: string) => boolean): Src[] {\r\n    let rseq: Src[] = [];\r\n    express = express || ((it) => !!it);\r\n    _.each(seq, it => {\r\n        if (!it) {\r\n            return;\r\n        }\r\n        if (_.isString(it) && express(it)) {\r\n            rseq.push(it);\r\n        } else if (_.isArray(it)) {\r\n            rseq.push(_.filter(it, itm => express(itm)));\r\n        }\r\n    });\r\n    return rseq;\r\n}\r\n/**\r\n * run task sequence.\r\n * \r\n * @protected\r\n * @param {Gulp} gulp\r\n * @param {Src[]} tasks\r\n * @returns {Promise<any>}\r\n * \r\n * @memberOf Development\r\n */\r\nexport function runSequence(gulp: Gulp, tasks: Src[]): Promise<any> {\r\n    tasks = filterTaskSequence(tasks);\r\n    console.log(chalk.cyan('run tasks : '), tasks);\r\n    let run = new Promise((resolve, reject) => {\r\n        let ps: Promise<any> = null;\r\n        if (tasks && tasks.length > 0) {\r\n            _.each(tasks, task => {\r\n                if (ps) {\r\n                    ps = ps.then(() => {\r\n                        return startTask(gulp, task);\r\n                    })\r\n                } else {\r\n                    ps = startTask(gulp, task);\r\n                }\r\n            });\r\n        } else {\r\n            ps = Promise.resolve();\r\n        }\r\n        return ps\r\n            .then(resolve)\r\n            .catch(reject);\r\n    });\r\n    return run.catch(err => {\r\n        console.error(chalk.red(err));\r\n        // process.exit(0);\r\n    });\r\n}\r\n\r\n/**\r\n * start task.\r\n * \r\n * @param {Gulp} gulp\r\n * @param {Src} task\r\n * @returns {Promise<any>}\r\n */\r\nfunction startTask(gulp: Gulp, task: Src): Promise<any> {\r\n    let taskErr = null, taskStop = null;\r\n    return new Promise((reslove, reject) => {\r\n        let tskmap: any = {};\r\n        _.each(_.isArray(task) ? task : [task], t => {\r\n            tskmap[t] = false;\r\n        });\r\n        taskErr = (err) => {\r\n            process.exit(err);\r\n            console.error(chalk.red(err));\r\n            reject(err);\r\n        };\r\n        taskStop = (e: any) => {\r\n            if (tskmap[e.task] === false) {\r\n                tskmap[e.task] = true;\r\n            }\r\n            if (!_.some(_.values(tskmap), it => !it)) {\r\n                reslove();\r\n            }\r\n        }\r\n        if (gulp['setMaxListeners']) {\r\n            gulp['setMaxListeners'](100);\r\n        }\r\n        gulp.on('task_stop', taskStop)\r\n            .on('task_err', taskErr);\r\n        gulp.start(task);\r\n    })\r\n        .then(() => {\r\n            if (gulp['removeListener']) {\r\n                gulp['removeListener']('task_stop', taskStop);\r\n                gulp['removeListener']('task_err', taskErr);\r\n            }\r\n        }, err => {\r\n            if (gulp['removeListener']) {\r\n                gulp['removeListener']('task_stop', taskStop);\r\n                gulp['removeListener']('task_err', taskErr);\r\n            }\r\n            // process.exit(0);\r\n        });\r\n}\r\n\r\n\r\n// function start(gulp: Gulp, taskname: string): Promise<any> {\r\n//     let taskErr = null, taskStop = null;\r\n//     return new Promise((reslove, reject) => {\r\n//         taskErr = (err) => {\r\n//             process.exit(err);\r\n//             console.error(chalk.red(err));\r\n//             reject(err);\r\n//         };\r\n//         taskStop = (e: any) => {\r\n//             if (e.task === taskname) {\r\n//                 reslove();\r\n//             }\r\n//         }\r\n//         gulp.on('task_stop', taskStop)\r\n//             .on('task_err', taskErr);\r\n//         gulp.start(taskname);\r\n//     })\r\n//         .then(() => {\r\n//             if (gulp['removeListener']) {\r\n//                 gulp['removeListener']('task_stop', taskStop);\r\n//                 gulp['removeListener']('task_err', taskErr);\r\n//             }\r\n//         }, err => {\r\n//             if (gulp['removeListener']) {\r\n//                 gulp['removeListener']('task_stop', taskStop);\r\n//                 gulp['removeListener']('task_err', taskErr);\r\n//             }\r\n//             // process.exit(0);\r\n//         });\r\n// }\r\n\r\n/**\r\n * run task sequence\r\n * \r\n * @export\r\n * @param {Gulp} gulp\r\n * @param {(ITask[] | Promise<ITask[]>)} tasks\r\n * @param {ITaskContext} ctx\r\n * @param {ZipTaskName} [zipName]\r\n * @returns {Promise<any>}\r\n */\r\nexport function runTaskSequence(gulp: Gulp, tasks: ITask[] | Promise<ITask[]>, ctx: ITaskContext, zipName?: ZipTaskName): Promise<any> {\r\n    return Promise.resolve(tasks)\r\n        .then(tasks => {\r\n            let taskseq = toSequence(gulp, tasks, ctx, zipName);\r\n            return runSequence(gulp, taskseq);\r\n        });\r\n}\r\n"]}