{"version":3,"sources":["taskSequence.js","taskSequence.ts"],"names":["_","require","chalk","toSequence","gulp","tasks","config","seq","len","length","orderBy","isArray","t","info","getInfo","isNumber","order","each","watch","env","oper","tname","setup","push","exports","addToSequence","taskSequence","rst","taskName","splice","runSequence","console","log","cyan","run","Promise","resolve","reject","ps","then","startTask","task","catch","error","red","err","process","exit","taskErr","taskStop","reslove","tskmap","e","some","values","it","on","start","runTaskSequence","taskseq"],"mappings":"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","file":"../taskSequence.js","sourcesContent":["\"use strict\";\nconst _ = require('lodash');\nconst chalk = require('chalk');\n/**\n * convert setup task result to run sequence src.\n *\n * @export\n * @param {Gulp} gulp\n * @param {ITask[]} tasks\n * @param {ITaskConfig} config\n * @returns {Src[]}\n */\nfunction toSequence(gulp, tasks, config) {\n    let seq = [];\n    let len = tasks.length;\n    if (len < 1) {\n        return seq;\n    }\n    tasks = _.orderBy(tasks, t => {\n        if (_.isArray(t)) {\n            return len;\n        }\n        else {\n            let info = t.getInfo();\n            if (_.isNumber(info.order)) {\n                return info.order;\n            }\n            return len;\n        }\n    });\n    _.each(tasks, t => {\n        let info = t.getInfo();\n        if (info.watch && !config.env.watch) {\n            return;\n        }\n        if (!info.oper ||\n            (info.oper && (info.oper & config.oper) > 0)) {\n            let tname = t.setup(config, gulp);\n            tname && seq.push(tname);\n        }\n    });\n    return seq;\n}\nexports.toSequence = toSequence;\n/**\n * add task to task sequence.\n *\n * @export\n * @param {Src[]} taskSequence\n * @param {ITaskInfo} rst\n * @returns\n */\nfunction addToSequence(taskSequence, rst) {\n    if (!rst) {\n        return taskSequence;\n    }\n    if (rst.taskName) {\n        if (_.isNumber(rst.order) && rst.order >= 0 && rst.order < taskSequence.length) {\n            taskSequence.splice(rst.order, 0, rst.taskName);\n            return taskSequence;\n        }\n        taskSequence.push(rst.taskName);\n    }\n    return taskSequence;\n}\nexports.addToSequence = addToSequence;\n/**\n * run task sequence.\n *\n * @protected\n * @param {Gulp} gulp\n * @param {Src[]} tasks\n * @returns {Promise<any>}\n *\n * @memberOf Development\n */\nfunction runSequence(gulp, tasks) {\n    console.log('run tasks : ', chalk.cyan(tasks));\n    let run = new Promise((resolve, reject) => {\n        let ps = null;\n        if (tasks && tasks.length > 0) {\n            _.each(tasks, task => {\n                if (ps) {\n                    ps = ps.then(() => {\n                        return startTask(gulp, task);\n                    });\n                }\n                else {\n                    ps = startTask(gulp, task);\n                }\n            });\n        }\n        else {\n            ps = Promise.resolve();\n        }\n        return ps\n            .then(resolve)\n            .catch(reject);\n    });\n    return run.catch(err => {\n        console.error(chalk.red(err));\n        process.exit(0);\n    });\n}\nexports.runSequence = runSequence;\nfunction startTask(gulp, task) {\n    let taskErr = null, taskStop = null;\n    return new Promise((reslove, reject) => {\n        let tskmap = {};\n        _.each(_.isArray(task) ? task : [task], t => {\n            tskmap[t] = false;\n        });\n        taskErr = (err) => {\n            process.exit(err);\n            console.error(chalk.red(err));\n            reject(err);\n        };\n        taskStop = (e) => {\n            tskmap[e.task] = true;\n            if (!_.some(_.values(tskmap), it => !it)) {\n                reslove();\n            }\n        };\n        gulp.on('task_stop', taskStop)\n            .on('task_err', taskErr);\n        gulp.start(task);\n    })\n        .then(() => {\n        if (gulp['removeListener']) {\n            gulp['removeListener']('task_stop', taskStop);\n            gulp['removeListener']('task_err', taskErr);\n        }\n    }, err => {\n        if (gulp['removeListener']) {\n            gulp['removeListener']('task_stop', taskStop);\n            gulp['removeListener']('task_err', taskErr);\n        }\n        // process.exit(0);\n    });\n}\n/**\n * run task sequence\n *\n * @export\n * @param {Gulp} gulp\n * @param {ITask[] | Promise<ITask[]>} tasks\n * @param {TaskConfig} config\n * @returns {Promise<any>}\n */\nfunction runTaskSequence(gulp, tasks, config) {\n    return Promise.resolve(tasks)\n        .then(tasks => {\n        let taskseq = toSequence(gulp, tasks, config);\n        return runSequence(gulp, taskseq);\n    });\n}\nexports.runTaskSequence = runTaskSequence;\n","import * as _ from 'lodash';\r\nimport { Gulp } from 'gulp';\r\nimport * as chalk from 'chalk';\r\nimport { Src, ITaskInfo, ITaskContext, ITask } from './TaskConfig';\r\n\r\n/**\r\n * convert setup task result to run sequence src.\r\n * \r\n * @export\r\n * @param {Gulp} gulp\r\n * @param {ITask[]} tasks\r\n * @param {ITaskConfig} config\r\n * @returns {Src[]}\r\n */\r\nexport function toSequence(gulp: Gulp, tasks: ITask[], config: ITaskContext): Src[] {\r\n    let seq: Src[] = [];\r\n    let len = tasks.length;\r\n    if (len < 1) {\r\n        return seq;\r\n    }\r\n\r\n    tasks = _.orderBy(tasks, t => {\r\n        if (_.isArray(t)) {\r\n            return len;\r\n        } else {\r\n            let info = t.getInfo();\r\n            if (_.isNumber(info.order)) {\r\n                return info.order;\r\n            }\r\n            return len;\r\n        }\r\n    });\r\n\r\n    _.each(tasks, t => {\r\n        let info = t.getInfo();\r\n        if (info.watch && !config.env.watch) {\r\n            return;\r\n        }\r\n\r\n        if (!info.oper ||\r\n            (info.oper && (info.oper & config.oper) > 0)) {\r\n            let tname = t.setup(config, gulp);\r\n            tname && seq.push(tname);\r\n        }\r\n\r\n    });\r\n\r\n    return seq;\r\n}\r\n\r\n\r\n/**\r\n * add task to task sequence.\r\n * \r\n * @export\r\n * @param {Src[]} taskSequence\r\n * @param {ITaskInfo} rst\r\n * @returns\r\n */\r\nexport function addToSequence(taskSequence: Src[], rst: ITaskInfo) {\r\n    if (!rst) {\r\n        return taskSequence;\r\n    }\r\n    if (rst.taskName) {\r\n        if (_.isNumber(rst.order) && rst.order >= 0 && rst.order < taskSequence.length) {\r\n            taskSequence.splice(rst.order, 0, rst.taskName);\r\n            return taskSequence;\r\n        }\r\n        taskSequence.push(rst.taskName);\r\n    }\r\n    return taskSequence;\r\n}\r\n\r\n/**\r\n * run task sequence.\r\n * \r\n * @protected\r\n * @param {Gulp} gulp\r\n * @param {Src[]} tasks\r\n * @returns {Promise<any>}\r\n * \r\n * @memberOf Development\r\n */\r\nexport function runSequence(gulp: Gulp, tasks: Src[]): Promise<any> {\r\n    console.log('run tasks : ', chalk.cyan(<any>tasks));\r\n    let run = new Promise((resolve, reject) => {\r\n        let ps: Promise<any> = null;\r\n        if (tasks && tasks.length > 0) {\r\n            _.each(tasks, task => {\r\n                if (ps) {\r\n                    ps = ps.then(() => {\r\n                        return startTask(gulp, task);\r\n                    })\r\n                } else {\r\n                    ps = startTask(gulp, task);\r\n                }\r\n            });\r\n        } else {\r\n            ps = Promise.resolve();\r\n        }\r\n        return ps\r\n            .then(resolve)\r\n            .catch(reject);\r\n    });\r\n    return run.catch(err => {\r\n        console.error(chalk.red(err));\r\n        process.exit(0);\r\n    });\r\n}\r\n\r\nfunction startTask(gulp: Gulp, task: Src): Promise<any> {\r\n    let taskErr = null, taskStop = null;\r\n    return new Promise((reslove, reject) => {\r\n        let tskmap: any = {};\r\n        _.each(_.isArray(task) ? task : [task], t => {\r\n            tskmap[t] = false;\r\n        });\r\n        taskErr = (err) => {\r\n            process.exit(err);\r\n            console.error(chalk.red(err));\r\n            reject(err);\r\n        };\r\n        taskStop = (e: any) => {\r\n            tskmap[e.task] = true;\r\n            if (!_.some(_.values(tskmap), it => !it)) {\r\n                reslove();\r\n            }\r\n        }\r\n        gulp.on('task_stop', taskStop)\r\n            .on('task_err', taskErr);\r\n        gulp.start(task);\r\n    })\r\n        .then(() => {\r\n            if (gulp['removeListener']) {\r\n                gulp['removeListener']('task_stop', taskStop);\r\n                gulp['removeListener']('task_err', taskErr);\r\n            }\r\n        }, err => {\r\n            if (gulp['removeListener']) {\r\n                gulp['removeListener']('task_stop', taskStop);\r\n                gulp['removeListener']('task_err', taskErr);\r\n            }\r\n            // process.exit(0);\r\n        });\r\n}\r\n\r\n/**\r\n * run task sequence\r\n * \r\n * @export\r\n * @param {Gulp} gulp\r\n * @param {ITask[] | Promise<ITask[]>} tasks\r\n * @param {TaskConfig} config\r\n * @returns {Promise<any>}\r\n */\r\nexport function runTaskSequence(gulp: Gulp, tasks: ITask[] | Promise<ITask[]>, config: ITaskContext): Promise<any> {\r\n    return Promise.resolve(tasks)\r\n        .then(tasks => {\r\n            let taskseq = toSequence(gulp, tasks, config);\r\n            return runSequence(gulp, taskseq);\r\n        });\r\n}\r\n"]}