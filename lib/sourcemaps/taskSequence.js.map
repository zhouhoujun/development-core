{"version":3,"sources":["taskSequence.ts"],"names":["toSequence","gulp","tasks","ctx","zipName","seq","length","taskseq","sortOrder_1","sortOrder","t","getInfo","order","hasWatchtasks","callback","watch","push","_","each","tk","isArray","pallSeq_1","setupTask","ps","flattenSequence","concat","watchname","taskSequenceWatch","it","indexOf","registerTasks","info","infoOper","to","oper","tname_1","setup","Operation_1","Operation","autoWatch","wname","task","src","getSrc","console","log","chalk","cyan","call","cb","runSequence","globals","registerGlobals","hasRegistered","error","red","express","option","wats_1","name_1","isBoolean","toWatchSeq","filterTaskSequence","zipSequence","registerZipTask","name","i","taskname","first","last","name_2","RunWay_1","RunWay","sequence","fs","ls","name_3","parallel","result","zipSrc","some","addToSequence","taskSequence","rst","taskName","len","isNumber","isFunction","val","value","parseInt","toFixed","seqMax","splice","rseq","isString","filter","itm","Promise","resolve","reject","then","startTask","catch","taskErr","taskStop","reslove","tskmap","err","e","values","on","start","process","exit","runTaskSequence","require","exports"],"mappings":"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","file":"../taskSequence.js","sourcesContent":["import * as _ from 'lodash';\r\nimport { Gulp } from 'gulp';\r\nimport * as chalk from 'chalk';\r\nimport { sortOrder } from './utils/sortOrder';\r\nimport * as watch from 'gulp-watch';\r\nimport { ITask, ITaskInfo } from './ITask';\r\nimport { Src, ZipTaskName } from './types';\r\nimport { ITaskContext } from './ITaskContext';\r\nimport { Operation } from './Operation';\r\nimport { RunWay } from './RunWay';\r\n\r\n\r\n/**\r\n * convert setup task result to run sequence src.\r\n *\r\n * @export\r\n * @param {Gulp} gulp\r\n * @param {ITask[]} tasks\r\n * @param {ITaskContext} ctx\r\n * @param {ZipTaskName} [zipName]\r\n * @returns {Src[]}\r\n */\r\nexport function toSequence(gulp: Gulp, tasks: ITask[], ctx: ITaskContext, zipName?: ZipTaskName): Src[] {\r\n    let seq: Src[] = [];\r\n    let len = tasks.length;\r\n    if (len < 1) {\r\n        return seq;\r\n    }\r\n    let taskseq = sortOrder<ITask>(tasks, t => t.getInfo().order, ctx);\r\n\r\n    let hasWatchtasks = [];\r\n    let callback = watch => hasWatchtasks.push(watch);\r\n    _.each(taskseq, tk => {\r\n        if (_.isArray(tk)) {\r\n            let pallSeq: Src[] = [];\r\n            _.each(tk, t => {\r\n                pallSeq.push(setupTask(gulp, t, ctx, callback));\r\n            });\r\n            let ps: Src = flattenSequence(gulp, pallSeq, ctx, zipName);\r\n            if (ps && ps.length > 0) {\r\n                seq.push(ps);\r\n            }\r\n        } else {\r\n            seq = seq.concat(setupTask(gulp, tk, ctx, callback));\r\n        }\r\n    });\r\n\r\n    let watchname = taskSequenceWatch(gulp, seq, ctx, it => {\r\n        if (!it) {\r\n            return false;\r\n        }\r\n        if (hasWatchtasks.length > 0) {\r\n            return hasWatchtasks.indexOf(it) < 0;\r\n        }\r\n        return true;\r\n    }, zipName);\r\n    if (watchname) {\r\n        registerTasks(ctx, watchname);\r\n        seq.push(watchname);\r\n    }\r\n\r\n    return seq;\r\n}\r\n\r\nfunction setupTask(gulp: Gulp, t: ITask, ctx: ITaskContext, callback: (name: Src) => void): string[] {\r\n    let seq: string[] = [];\r\n    let info = t.getInfo();\r\n    let infoOper = ctx.to(info.oper);\r\n    if (infoOper & ctx.oper) {\r\n        // ctx.addTask(t);\r\n        let tname = t.setup(ctx, gulp); // t.setup(ctx, gulp);\r\n        if (tname) {\r\n            // is watch task.\r\n            if ((infoOper & Operation.watch)) {\r\n                callback(tname);\r\n            }\r\n            registerTasks(ctx, tname);\r\n            if (_.isArray(tname)) {\r\n                seq = tname;\r\n            } else {\r\n                seq.push(tname);\r\n            }\r\n            // autoWatch\r\n            if ((ctx.oper & Operation.watch) && (infoOper & Operation.autoWatch)) {\r\n                let wname = tname + '-twatch';\r\n                registerTasks(ctx, wname);\r\n                gulp.task(wname, () => {\r\n                    let src = ctx.getSrc(info);\r\n                    console.log('watch, src:', chalk.cyan.call(chalk, src));\r\n                    watch(src, (cb) => {\r\n                        runSequence(gulp, _.isArray(tname) ? tname : [<string>tname]);\r\n                    });\r\n                });\r\n\r\n                callback(wname);\r\n                seq.push(wname);\r\n            }\r\n        }\r\n    }\r\n    return seq;\r\n}\r\n\r\nfunction registerTasks(ctx: ITaskContext, tasks: Src) {\r\n    ctx.globals.tasks = ctx.globals.tasks || {};\r\n    if (_.isArray(tasks)) {\r\n        _.each(tasks, t => registerGlobals(ctx, t));\r\n    } else {\r\n        registerGlobals(ctx, tasks);\r\n    }\r\n}\r\n\r\nfunction hasRegistered(ctx: ITaskContext, task: string) {\r\n    ctx.globals.tasks = ctx.globals.tasks || {};\r\n    return (ctx.globals.tasks[task]) ? true : false;\r\n}\r\n\r\nfunction registerGlobals(ctx: ITaskContext, task: string) {\r\n    if (ctx.globals.tasks[task]) {\r\n        console.error(chalk.red('has same task:'), chalk.cyan(task));\r\n    } else {\r\n        ctx.globals.tasks[task] = task;\r\n    }\r\n}\r\n\r\n/**\r\n * generate watch task for sequence\r\n *\r\n * @export\r\n * @param {Gulp} gulp\r\n * @param {Src[]} tasks\r\n * @param {ITaskContext} ctx\r\n * @param {(str: string) => boolean} [express]\r\n * @param {ZipTaskName} [zipName]\r\n * @returns {string}\r\n */\r\nexport function taskSequenceWatch(gulp: Gulp, tasks: Src[], ctx: ITaskContext, express?: (str: string) => boolean, zipName?: ZipTaskName): string {\r\n    // create watch task.\r\n    if ((ctx.oper & Operation.watch) && ctx.option.watch) {\r\n        let wats = [];\r\n        let name = '';\r\n        if (_.isBoolean(ctx.option.watch)) {\r\n            let toWatchSeq = filterTaskSequence(tasks, express);\r\n            name = zipSequence(gulp, toWatchSeq, ctx, zipName);\r\n            name && wats.push(name);\r\n        } else {\r\n            wats = ctx.option.watch;\r\n        }\r\n\r\n        if (wats.length > 0) {\r\n            name = name ? name + '-owatch' : 'owatch';\r\n            gulp.task(name, () => {\r\n                let src = ctx.getSrc();\r\n                console.log('watch, src:', chalk.cyan.call(chalk, src));\r\n                watch(src, () => {\r\n                    runSequence(gulp, wats)\r\n                })\r\n            });\r\n            return name;\r\n        }\r\n    }\r\n    return '';\r\n}\r\n\r\nfunction registerZipTask(gulp: Gulp, name: string, tasks: Src[], ctx: ITaskContext) {\r\n    let i = 0;\r\n    let taskname = name;\r\n    while (hasRegistered(ctx, taskname) && i < 50) {\r\n        taskname = name + i;\r\n        console.log('try register name: ', chalk.cyan(taskname));\r\n        i++;\r\n    }\r\n    if (i >= 50) {\r\n        console.error(chalk.red('has same task:'), chalk.cyan(name), 'too many times.');\r\n        return '';\r\n    }\r\n\r\n    registerGlobals(ctx, taskname);\r\n    gulp.task(taskname, () => {\r\n        return runSequence(gulp, tasks);\r\n    });\r\n    return taskname;\r\n}\r\n\r\n/**\r\n * zip tasks to a single task.\r\n *\r\n * @export\r\n * @param {Gulp} gulp\r\n * @param {Src[]} tasks\r\n * @param {ITaskContext} ctx\r\n * @param {ZipTaskName} [zipName]\r\n * @returns {string}\r\n */\r\nexport function zipSequence(gulp: Gulp, tasks: Src[], ctx: ITaskContext, zipName?: ZipTaskName): string {\r\n    if (tasks.length > 1) {\r\n        let first = _.first(tasks);\r\n        first = _.isArray(first) ? _.first(first) : first;\r\n        let last = _.last(tasks);\r\n        last = _.isArray(last) ? _.last(last) : last;\r\n        let name = `${first}-${last}`;\r\n        name = zipName ? zipName(name, RunWay.sequence, ctx) : name + '-seq';\r\n        return registerZipTask(gulp, name, tasks, ctx);\r\n\r\n    } else if (tasks.length === 1) {\r\n        let first = _.first(tasks);\r\n        if (_.isArray(first)) {\r\n            if (first.length > 1) {\r\n                let fs = _.first(first);\r\n                let ls = _.last(first);\r\n                let name = `${fs}-${ls}`;\r\n                name = zipName ? zipName(name, RunWay.parallel, ctx) : name + '-paral';\r\n                return registerZipTask(gulp, name, tasks, ctx);\r\n            } else {\r\n                return _.first(first) || '';\r\n            }\r\n        } else {\r\n            return first || '';\r\n        }\r\n    }\r\n\r\n    return '';\r\n}\r\n\r\n/**\r\n * flatten task Sequence.\r\n *\r\n * @export\r\n * @param {Gulp} gulp\r\n * @param {Src[]} tasks\r\n * @param {ITaskContext} ctx\r\n * @param {ZipTaskName} [zipName]\r\n * @returns {string[]}\r\n */\r\nexport function flattenSequence(gulp: Gulp, tasks: Src[], ctx: ITaskContext, zipName?: ZipTaskName): string[] {\r\n    let result: string[] = [];\r\n    _.each(tasks, tk => {\r\n        if (_.isArray(tk)) {\r\n            if (tk.length < 1) {\r\n                return;\r\n            }\r\n            let zipSrc: Src[] = (_.some(tk, t => _.isArray(t))) ? tk : [tk];\r\n            let taskname = zipSequence(gulp, zipSrc, ctx, zipName);\r\n            taskname && result.push(taskname);\r\n        } else {\r\n            tk && result.push(tk);\r\n        }\r\n    });\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * add task to task sequence.\r\n *\r\n * @export\r\n * @param {Src[]} taskSequence\r\n * @param {ITaskInfo} rst\r\n * @param {ITaskContext} [ctx]\r\n * @returns {Src[]}\r\n */\r\nexport function addToSequence(taskSequence: Src[], rst: ITaskInfo, ctx?: ITaskContext): Src[] {\r\n    if (!rst) {\r\n        return taskSequence;\r\n    }\r\n    if (rst.taskName) {\r\n        let order = 1;\r\n        let len = taskSequence.length + 1;\r\n        if (_.isNumber(rst.order)) {\r\n            order = rst.order;\r\n        } else if (_.isFunction(rst.order)) {\r\n            let val = rst.order(len, ctx);\r\n            order = _.isNumber(val) ? val : val.value\r\n        } else if (rst.order && _.isNumber(rst.order.value)) {\r\n            order = rst.order.value;\r\n        }\r\n\r\n\r\n        if (order > 0 && order < 1) {\r\n            order = order * len;\r\n        } else if (order === 1) {\r\n            order = len;\r\n        } else if (order > len) {\r\n            order = order % len;\r\n        }\r\n\r\n        order = parseInt(order.toFixed(0));\r\n\r\n        if (order < 0) {\r\n            order = 0;\r\n        }\r\n\r\n        let seqMax = len - 2;\r\n        // console.log(order);\r\n        if (order >= 0 && order <= seqMax) {\r\n            taskSequence.splice(order, 0, rst.taskName);\r\n        } else if (order > seqMax && order < len) {\r\n            taskSequence.splice(seqMax - (seqMax - order), 0, rst.taskName);\r\n        } else {\r\n            taskSequence.push(rst.taskName);\r\n        }\r\n    }\r\n    return taskSequence;\r\n}\r\n\r\n\r\n/**\r\n * filter task sequence. make sure no empty.\r\n *\r\n * @param {Src[]} seq\r\n * @param {(str: string) => boolean} [filter]\r\n * @returns {Src[]}\r\n */\r\nfunction filterTaskSequence(seq: Src[], express?: (str: string) => boolean): Src[] {\r\n    let rseq: Src[] = [];\r\n    express = express || ((it) => !!it);\r\n    _.each(seq, it => {\r\n        if (!it) {\r\n            return;\r\n        }\r\n        if (_.isString(it) && express(it)) {\r\n            rseq.push(it);\r\n        } else if (_.isArray(it)) {\r\n            rseq.push(_.filter(it, itm => express(itm)));\r\n        }\r\n    });\r\n    return rseq;\r\n}\r\n/**\r\n * run task sequence.\r\n *\r\n * @protected\r\n * @param {Gulp} gulp\r\n * @param {Src[]} tasks\r\n * @returns {Promise<any>}\r\n *\r\n * @memberOf Development\r\n */\r\nexport function runSequence(gulp: Gulp, tasks: Src[]): Promise<any> {\r\n    tasks = filterTaskSequence(tasks);\r\n    console.log(chalk.cyan('run tasks : '), tasks);\r\n    return new Promise((resolve, reject) => {\r\n        let ps: Promise<any> = null;\r\n        if (tasks && tasks.length > 0) {\r\n            _.each(tasks, task => {\r\n                if (ps) {\r\n                    ps = ps.then(() => {\r\n                        return startTask(gulp, task);\r\n                    })\r\n                } else {\r\n                    ps = startTask(gulp, task);\r\n                }\r\n            });\r\n        } else {\r\n            ps = Promise.resolve();\r\n        }\r\n        return ps\r\n            .then(resolve)\r\n            .catch(reject);\r\n    });\r\n}\r\n\r\n/**\r\n * start task.\r\n *\r\n * @param {Gulp} gulp\r\n * @param {Src} task\r\n * @returns {Promise<any>}\r\n */\r\nfunction startTask(gulp: Gulp, task: Src): Promise<any> {\r\n    let taskErr = null, taskStop = null;\r\n    return new Promise((reslove, reject) => {\r\n        let tskmap: any = {};\r\n        _.each(_.isArray(task) ? task : [task], t => {\r\n            tskmap[t] = false;\r\n        });\r\n        taskErr = (err) => {\r\n            reject(err);\r\n        };\r\n        taskStop = (e: any) => {\r\n            if (tskmap[e.task] === false) {\r\n                tskmap[e.task] = true;\r\n            }\r\n            if (!_.some(_.values(tskmap), it => !it)) {\r\n                reslove();\r\n            }\r\n        }\r\n        if (gulp['setMaxListeners']) {\r\n            gulp['setMaxListeners'](100);\r\n        }\r\n        gulp.on('task_stop', taskStop)\r\n            .on('task_err', taskErr);\r\n        gulp.start(task);\r\n    })\r\n        .then(() => {\r\n            if (gulp['removeListener']) {\r\n                gulp['removeListener']('task_stop', taskStop);\r\n                gulp['removeListener']('task_err', taskErr);\r\n            }\r\n        })\r\n        .catch(err => {\r\n            if (gulp['removeListener']) {\r\n                gulp['removeListener']('task_stop', taskStop);\r\n                gulp['removeListener']('task_err', taskErr);\r\n            }\r\n            // console.log(err);\r\n            process.exit(_.isNumber(err) ? err : 1);\r\n        });\r\n}\r\n\r\n\r\n// function start(gulp: Gulp, taskname: string): Promise<any> {\r\n//     let taskErr = null, taskStop = null;\r\n//     return new Promise((reslove, reject) => {\r\n//         taskErr = (err) => {\r\n//             process.exit(err);\r\n//             console.error(chalk.red(err));\r\n//             reject(err);\r\n//         };\r\n//         taskStop = (e: any) => {\r\n//             if (e.task === taskname) {\r\n//                 reslove();\r\n//             }\r\n//         }\r\n//         gulp.on('task_stop', taskStop)\r\n//             .on('task_err', taskErr);\r\n//         gulp.start(taskname);\r\n//     })\r\n//         .then(() => {\r\n//             if (gulp['removeListener']) {\r\n//                 gulp['removeListener']('task_stop', taskStop);\r\n//                 gulp['removeListener']('task_err', taskErr);\r\n//             }\r\n//         }, err => {\r\n//             if (gulp['removeListener']) {\r\n//                 gulp['removeListener']('task_stop', taskStop);\r\n//                 gulp['removeListener']('task_err', taskErr);\r\n//             }\r\n//             // process.exit(0);\r\n//         });\r\n// }\r\n\r\n/**\r\n * run task sequence\r\n *\r\n * @export\r\n * @param {Gulp} gulp\r\n * @param {(ITask[] | Promise<ITask[]>)} tasks\r\n * @param {ITaskContext} ctx\r\n * @param {ZipTaskName} [zipName]\r\n * @returns {Promise<any>}\r\n */\r\nexport function runTaskSequence(gulp: Gulp, tasks: ITask[] | Promise<ITask[]>, ctx: ITaskContext, zipName?: ZipTaskName): Promise<any> {\r\n    return Promise.resolve(tasks)\r\n        .then(tasks => {\r\n            let taskseq = toSequence(gulp, tasks, ctx, zipName);\r\n            return runSequence(gulp, taskseq);\r\n        });\r\n}\r\n"]}