{"version":3,"sources":["taskSequence.js","taskSequence.ts"],"names":["toSequence","gulp","tasks","config","seq","len","length","_","orderBy","t","isArray","isNumber","decorator","order","each","watch","env","oper","tname","setup","push","addToSequence","taskSequence","rst","taskName","splice","runSequence","console","log","chalk","cyan","run","Promise","resolve","reject","ps","task","then","startTask","catch","err","error","red","process","exit","taskErr","taskStop","reslove","tskmap","e","some","values","it","on","start","runTaskSequence","taskseq","require","exports"],"mappings":"AAAA,YCcA,SAAAA,YAA2BC,EAAYC,EAAgBC,GACnD,GAAIC,MACAC,EAAMH,EAAMI,MAChB,OAAID,GAAM,EACCD,GAGXF,EAAQK,EAAEC,QAAQN,EAAO,SAAAO,GACrB,MAAIF,GAAEG,QAAQD,GACHJ,EAEHE,EAAEI,SAASF,EAAEG,UAAUC,OAChBJ,EAAEG,UAAUC,MAEhBR,IAIfE,EAAEO,KAAKZ,EAAO,SAAAO,GACV,KAAIA,EAAEG,UAAUG,OAAUZ,EAAOa,IAAID,UAIhCN,EAAEG,UAAUK,MACZR,EAAEG,UAAUK,OAASR,EAAEG,UAAUK,KAAOd,EAAOc,MAAQ,GAAI,CAC5D,GAAIC,GAAQT,EAAEU,MAAMhB,EAAQF,EAC5BiB,IAASd,EAAIgB,KAAKF,MAKnBd,GAYX,QAAAiB,eAA8BC,EAAqBC,GAC/C,IAAKA,EACD,MAAOD,EAEX,IAAIC,EAAIC,SAAU,CACd,GAAIjB,EAAEI,SAASY,EAAIV,QAAUU,EAAIV,OAAS,GAAKU,EAAIV,MAAQS,EAAahB,OAEpE,MADAgB,GAAaG,OAAOF,EAAIV,MAAO,EAAGU,EAAIC,UAC/BF,CAEXA,GAAaF,KAAKG,EAAIC,UAE1B,MAAOF,GAaX,QAAAI,aAA4BzB,EAAYC,GACpCyB,QAAQC,IAAI,eAAgBC,MAAMC,KAAU5B,GAC5C,IAAI6B,GAAM,GAAIC,SAAQ,SAACC,EAASC,GAC5B,GAAIC,GAAmB,IAcvB,OAbIjC,IAASA,EAAMI,OAAS,EACxBC,EAAEO,KAAKZ,EAAO,SAAAkC,GAEND,EADAA,EACKA,EAAGE,KAAK,WACT,MAAOC,WAAUrC,EAAMmC,KAGtBE,UAAUrC,EAAMmC,KAI7BD,EAAKH,QAAQC,UAEVE,EACFE,KAAKJ,GACLM,MAAML,IAEf,OAAOH,GAAIQ,MAAM,SAAAC,GACbb,QAAQc,MAAMZ,MAAMa,IAAIF,IACxBG,QAAQC,KAAK,KAIrB,QAAAN,WAAmBrC,EAAYmC,GAC3B,GAAIS,GAAU,KAAMC,EAAW,IAC/B,OAAO,IAAId,SAAQ,SAACe,EAASb,GACzB,GAAIc,KACJzC,GAAEO,KAAKP,EAAEG,QAAQ0B,GAAQA,GAAQA,GAAO,SAAA3B,GACpCuC,EAAOvC,IAAK,IAEhBoC,EAAU,SAACL,GACPG,QAAQC,KAAKJ,GACbb,QAAQc,MAAMZ,MAAMa,IAAIF,IACxBN,EAAOM,IAEXM,EAAW,SAACG,GACRD,EAAOC,EAAEb,OAAQ,EACZ7B,EAAE2C,KAAK3C,EAAE4C,OAAOH,GAAS,SAAAI,GAAA,OAAOA,KACjCL,KAGR9C,EAAKoD,GAAG,YAAaP,GAChBO,GAAG,WAAYR,GACpB5C,EAAKqD,MAAMlB,KAEVC,KAAK,WACEpC,EAAA,iBACAA,EAAA,eAAuB,YAAa6C,GACpC7C,EAAA,eAAuB,WAAY4C,KAExC,SAAAL,GACKvC,EAAA,iBACAA,EAAA,eAAuB,YAAa6C,GACpC7C,EAAA,eAAuB,WAAY4C,MAenD,QAAAU,iBAAgCtD,EAAYC,EAAgBC,GACxD,GAAIqD,GAAUxD,WAAWC,EAAMC,EAAOC,EACtC,OAAOuB,aAAYzB,EAAMuD,GA3J7B,GAAYjD,GAACkD,QAAM,UAEP5B,MAAK4B,QAAM,QAYPC,SAAA1D,WAAUA,WA2CV0D,QAAArC,cAAaA,cAwBbqC,QAAAhC,YAAWA,YAwEXgC,QAAAH,gBAAeA","file":"../taskSequence.js","sourcesContent":["\"use strict\";\nconst _ = require('lodash');\nconst chalk = require('chalk');\nfunction toSequence(gulp, tasks, config) {\n    let seq = [];\n    let len = tasks.length;\n    if (len < 1) {\n        return seq;\n    }\n    tasks = _.orderBy(tasks, t => {\n        if (_.isArray(t)) {\n            return len;\n        }\n        else {\n            if (_.isNumber(t.decorator.order)) {\n                return t.decorator.order;\n            }\n            return len;\n        }\n    });\n    _.each(tasks, t => {\n        if (t.decorator.watch && !config.env.watch) {\n            return;\n        }\n        if (!t.decorator.oper ||\n            (t.decorator.oper && (t.decorator.oper & config.oper) > 0)) {\n            let tname = t.setup(config, gulp);\n            tname && seq.push(tname);\n        }\n    });\n    return seq;\n}\nexports.toSequence = toSequence;\nfunction addToSequence(taskSequence, rst) {\n    if (!rst) {\n        return taskSequence;\n    }\n    if (rst.taskName) {\n        if (_.isNumber(rst.order) && rst.order >= 0 && rst.order < taskSequence.length) {\n            taskSequence.splice(rst.order, 0, rst.taskName);\n            return taskSequence;\n        }\n        taskSequence.push(rst.taskName);\n    }\n    return taskSequence;\n}\nexports.addToSequence = addToSequence;\nfunction runSequence(gulp, tasks) {\n    console.log('run tasks : ', chalk.cyan(tasks));\n    let run = new Promise((resolve, reject) => {\n        let ps = null;\n        if (tasks && tasks.length > 0) {\n            _.each(tasks, task => {\n                if (ps) {\n                    ps = ps.then(() => {\n                        return startTask(gulp, task);\n                    });\n                }\n                else {\n                    ps = startTask(gulp, task);\n                }\n            });\n        }\n        else {\n            ps = Promise.resolve();\n        }\n        return ps\n            .then(resolve)\n            .catch(reject);\n    });\n    return run.catch(err => {\n        console.error(chalk.red(err));\n        process.exit(0);\n    });\n}\nexports.runSequence = runSequence;\nfunction startTask(gulp, task) {\n    let taskErr = null, taskStop = null;\n    return new Promise((reslove, reject) => {\n        let tskmap = {};\n        _.each(_.isArray(task) ? task : [task], t => {\n            tskmap[t] = false;\n        });\n        taskErr = (err) => {\n            process.exit(err);\n            console.error(chalk.red(err));\n            reject(err);\n        };\n        taskStop = (e) => {\n            tskmap[e.task] = true;\n            if (!_.some(_.values(tskmap), it => !it)) {\n                reslove();\n            }\n        };\n        gulp.on('task_stop', taskStop)\n            .on('task_err', taskErr);\n        gulp.start(task);\n    })\n        .then(() => {\n        if (gulp['removeListener']) {\n            gulp['removeListener']('task_stop', taskStop);\n            gulp['removeListener']('task_err', taskErr);\n        }\n    }, err => {\n        if (gulp['removeListener']) {\n            gulp['removeListener']('task_stop', taskStop);\n            gulp['removeListener']('task_err', taskErr);\n        }\n    });\n}\nfunction runTaskSequence(gulp, tasks, config) {\n    let taskseq = toSequence(gulp, tasks, config);\n    return runSequence(gulp, taskseq);\n}\nexports.runTaskSequence = runTaskSequence;\n","import * as _ from 'lodash';\r\nimport { Gulp } from 'gulp';\r\nimport * as chalk from 'chalk';\r\nimport { Src, ITaskInfo, ITaskConfig, ITask } from './TaskConfig';\r\n\r\n/**\r\n * convert setup task result to run sequence src.\r\n * \r\n * @export\r\n * @param {Gulp} gulp\r\n * @param {ITask[]} tasks\r\n * @param {ITaskConfig} config\r\n * @returns {Src[]}\r\n */\r\nexport function toSequence(gulp: Gulp, tasks: ITask[], config: ITaskConfig): Src[] {\r\n    let seq: Src[] = [];\r\n    let len = tasks.length;\r\n    if (len < 1) {\r\n        return seq;\r\n    }\r\n\r\n    tasks = _.orderBy(tasks, t => {\r\n        if (_.isArray(t)) {\r\n            return len;\r\n        } else {\r\n            if (_.isNumber(t.decorator.order)) {\r\n                return t.decorator.order;\r\n            }\r\n            return len;\r\n        }\r\n    });\r\n\r\n    _.each(tasks, t => {\r\n        if (t.decorator.watch && !config.env.watch) {\r\n            return;\r\n        }\r\n\r\n        if (!t.decorator.oper ||\r\n            (t.decorator.oper && (t.decorator.oper & config.oper) > 0)) {\r\n            let tname = t.setup(config, gulp);\r\n            tname && seq.push(tname);\r\n        }\r\n\r\n    });\r\n\r\n    return seq;\r\n}\r\n\r\n\r\n/**\r\n * add task to task sequence.\r\n * \r\n * @export\r\n * @param {Src[]} taskSequence\r\n * @param {ITaskInfo} rst\r\n * @returns\r\n */\r\nexport function addToSequence(taskSequence: Src[], rst: ITaskInfo) {\r\n    if (!rst) {\r\n        return taskSequence;\r\n    }\r\n    if (rst.taskName) {\r\n        if (_.isNumber(rst.order) && rst.order >= 0 && rst.order < taskSequence.length) {\r\n            taskSequence.splice(rst.order, 0, rst.taskName);\r\n            return taskSequence;\r\n        }\r\n        taskSequence.push(rst.taskName);\r\n    }\r\n    return taskSequence;\r\n}\r\n\r\n/**\r\n * run task sequence.\r\n * \r\n * @protected\r\n * @param {Gulp} gulp\r\n * @param {Src[]} tasks\r\n * @returns {Promise<any>}\r\n * \r\n * @memberOf Development\r\n */\r\nexport function runSequence(gulp: Gulp, tasks: Src[]): Promise<any> {\r\n    console.log('run tasks : ', chalk.cyan(<any>tasks));\r\n    let run = new Promise((resolve, reject) => {\r\n        let ps: Promise<any> = null;\r\n        if (tasks && tasks.length > 0) {\r\n            _.each(tasks, task => {\r\n                if (ps) {\r\n                    ps = ps.then(() => {\r\n                        return startTask(gulp, task);\r\n                    })\r\n                } else {\r\n                    ps = startTask(gulp, task);\r\n                }\r\n            });\r\n        } else {\r\n            ps = Promise.resolve();\r\n        }\r\n        return ps\r\n            .then(resolve)\r\n            .catch(reject);\r\n    });\r\n    return run.catch(err => {\r\n        console.error(chalk.red(err));\r\n        process.exit(0);\r\n    });\r\n}\r\n\r\nfunction startTask(gulp: Gulp, task: Src): Promise<any> {\r\n    let taskErr = null, taskStop = null;\r\n    return new Promise((reslove, reject) => {\r\n        let tskmap: any = {};\r\n        _.each(_.isArray(task) ? task : [task], t => {\r\n            tskmap[t] = false;\r\n        });\r\n        taskErr = (err) => {\r\n            process.exit(err);\r\n            console.error(chalk.red(err));\r\n            reject(err);\r\n        };\r\n        taskStop = (e: any) => {\r\n            tskmap[e.task] = true;\r\n            if (!_.some(_.values(tskmap), it => !it)) {\r\n                reslove();\r\n            }\r\n        }\r\n        gulp.on('task_stop', taskStop)\r\n            .on('task_err', taskErr);\r\n        gulp.start(task);\r\n    })\r\n        .then(() => {\r\n            if (gulp['removeListener']) {\r\n                gulp['removeListener']('task_stop', taskStop);\r\n                gulp['removeListener']('task_err', taskErr);\r\n            }\r\n        }, err => {\r\n            if (gulp['removeListener']) {\r\n                gulp['removeListener']('task_stop', taskStop);\r\n                gulp['removeListener']('task_err', taskErr);\r\n            }\r\n            // process.exit(0);\r\n        });\r\n}\r\n\r\n/**\r\n * run task sequence\r\n * \r\n * @export\r\n * @param {Gulp} gulp\r\n * @param {ITask[]} tasks\r\n * @param {TaskConfig} config\r\n * @returns {Promise<any>}\r\n */\r\nexport function runTaskSequence(gulp: Gulp, tasks: ITask[], config: ITaskConfig): Promise<any> {\r\n    let taskseq = toSequence(gulp, tasks, config);\r\n    return runSequence(gulp, taskseq);\r\n}\r\n"]}