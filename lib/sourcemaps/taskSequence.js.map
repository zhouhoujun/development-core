{"version":3,"sources":["taskSequence.js","taskSequence.ts"],"names":["_","require","chalk","TaskConfig_1","utils_1","toSequence","gulp","tasks","ctx","seq","len","length","sortOrder","t","getInfo","order","hasWatchtasks","each","info","oper","tname","setup","Operation","watch","push","registerTasks","watchname","taskSequenceWatch","it","indexOf","exports","globals","isArray","registerGlobals","hasRegistered","task","console","error","red","cyan","process","exit","express","option","wats","name","isBoolean","toWatchSeq","filterTaskSequence","zipSequence","src","getSrc","log","call","registerZipTask","i","taskname","runSequence","first","last","fs","ls","flattenSequence","result","tk","zipSrc","some","addToSequence","taskSequence","rst","taskName","isNumber","isFunction","Math","round","splice","rseq","isString","filter","itm","run","Promise","resolve","reject","ps","then","startTask","catch","err","taskErr","taskStop","reslove","tskmap","e","values","on","start","runTaskSequence","taskseq"],"mappings":"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","file":"../taskSequence.js","sourcesContent":["\"use strict\";\nconst _ = require('lodash');\nconst chalk = require('chalk');\nconst TaskConfig_1 = require('./TaskConfig');\nconst utils_1 = require('./utils');\n/**\n * convert setup task result to run sequence src.\n *\n * @export\n * @param {Gulp} gulp\n * @param {ITask[]} tasks\n * @param {ITaskContext} ctx\n * @returns {Src[]}\n */\nfunction toSequence(gulp, tasks, ctx) {\n    let seq = [];\n    let len = tasks.length;\n    if (len < 1) {\n        return seq;\n    }\n    tasks = utils_1.sortOrder(tasks, t => t.getInfo().order);\n    let hasWatchtasks = [];\n    _.each(tasks, t => {\n        let info = t.getInfo();\n        if (info.oper & ctx.oper) {\n            let tname = t.setup(ctx, gulp);\n            if (tname) {\n                if ((info.oper & TaskConfig_1.Operation.watch)) {\n                    hasWatchtasks.push(tname);\n                }\n                registerTasks(ctx, tname);\n                seq.push(tname);\n            }\n        }\n    });\n    let watchname = taskSequenceWatch(gulp, seq, ctx, it => {\n        if (!it) {\n            return false;\n        }\n        if (hasWatchtasks.length > 0) {\n            return hasWatchtasks.indexOf(it) < 0;\n        }\n        return true;\n    });\n    if (watchname) {\n        registerTasks(ctx, watchname);\n        seq.push(watchname);\n    }\n    return seq;\n}\nexports.toSequence = toSequence;\nfunction registerTasks(ctx, tasks) {\n    ctx.globals.tasks = ctx.globals.tasks || {};\n    if (_.isArray(tasks)) {\n        _.each(tasks, t => registerGlobals(ctx, t));\n    }\n    else {\n        registerGlobals(ctx, tasks);\n    }\n}\nfunction hasRegistered(ctx, task) {\n    ctx.globals.tasks = ctx.globals.tasks || {};\n    return (ctx.globals.tasks[task]) ? true : false;\n}\nfunction registerGlobals(ctx, task) {\n    if (ctx.globals.tasks[task]) {\n        console.error(chalk.red('has same task:'), chalk.cyan(task));\n        process.exit(0);\n    }\n    else {\n        ctx.globals.tasks[task] = task;\n    }\n}\n/**\n * generate watch task for sequence\n *\n * @export\n * @param {Gulp} gulp\n * @param {Src[]} tasks\n * @param {ITaskContext} ctx\n * @param {(str: string) => boolean} [express]\n * @returns\n */\nfunction taskSequenceWatch(gulp, tasks, ctx, express) {\n    // create watch task.\n    if ((ctx.oper & TaskConfig_1.Operation.watch) && ctx.option.watch) {\n        let wats = [];\n        let name = '';\n        if (_.isBoolean(ctx.option.watch)) {\n            let toWatchSeq = filterTaskSequence(tasks, express);\n            name = zipSequence(gulp, toWatchSeq, ctx);\n            name && wats.push(name);\n        }\n        else {\n            wats = ctx.option.watch;\n        }\n        if (wats.length > 0) {\n            name = name ? name + '-owatch' : 'owatch';\n            gulp.task(name, () => {\n                let src = ctx.getSrc();\n                console.log('watch, src:', chalk.cyan.call(chalk, src));\n                gulp.watch(src, wats);\n            });\n            return name;\n        }\n    }\n    return '';\n}\nexports.taskSequenceWatch = taskSequenceWatch;\nfunction registerZipTask(gulp, name, tasks, ctx) {\n    let i = 0;\n    let taskname = name;\n    while (hasRegistered(ctx, taskname) && i < 50) {\n        taskname = name + i;\n        console.log('try register name: ', chalk.cyan(taskname));\n        i++;\n    }\n    if (i >= 50) {\n        console.error(chalk.red('has same task:'), chalk.cyan(name), 'too many times.');\n        return '';\n    }\n    registerGlobals(ctx, taskname);\n    gulp.task(taskname, () => {\n        return runSequence(gulp, tasks);\n    });\n    return taskname;\n}\n/**\n * zip tasks to a single task.\n *\n * @export\n * @param {Gulp} gulp\n * @param {string[]} tasks tasks sequence\n * @param {ITaskContext} ctx\n * @returns {string}\n */\nfunction zipSequence(gulp, tasks, ctx) {\n    if (tasks.length > 1) {\n        let first = _.first(tasks);\n        first = _.isArray(first) ? _.first(first) : first;\n        let last = _.last(tasks);\n        last = _.isArray(last) ? _.last(last) : last;\n        let name = `${first}-${last}-seq`;\n        return registerZipTask(gulp, name, tasks, ctx);\n    }\n    else if (tasks.length === 1) {\n        let first = _.first(tasks);\n        if (_.isArray(first)) {\n            if (first.length > 1) {\n                let fs = _.first(first);\n                let ls = _.last(first);\n                let name = `${fs}-${ls}-paral`;\n                return registerZipTask(gulp, name, tasks, ctx);\n            }\n            else {\n                return _.first(first) || '';\n            }\n        }\n        else {\n            return first || '';\n        }\n    }\n    return '';\n}\nexports.zipSequence = zipSequence;\n/**\n * flatten task Sequence.\n *\n * @export\n * @param {Gulp} gulp\n * @param {Src[]} tasks\n * @param {ITaskContext} ctx\n * @returns {string[]}\n */\nfunction flattenSequence(gulp, tasks, ctx) {\n    let result = [];\n    _.each(tasks, tk => {\n        if (_.isArray(tk)) {\n            let zipSrc = (_.some(tk, t => _.isArray(t))) ? tk : [tk];\n            let taskname = zipSequence(gulp, zipSrc, ctx);\n            taskname && result.push(taskname);\n        }\n        else {\n            result.push(tk);\n        }\n    });\n    return result;\n}\nexports.flattenSequence = flattenSequence;\n/**\n * add task to task sequence.\n *\n * @export\n * @param {Src[]} taskSequence\n * @param {ITaskInfo} rst\n * @returns\n */\nfunction addToSequence(taskSequence, rst) {\n    if (!rst) {\n        return taskSequence;\n    }\n    if (rst.taskName) {\n        let order = 1;\n        let len = taskSequence.length + 1;\n        if (_.isNumber(rst.order)) {\n            order = rst.order;\n        }\n        else if (_.isFunction(rst.order)) {\n            order = rst.order(len);\n        }\n        if (_.isNumber(order)) {\n            if (order > 0 && order < 1) {\n                order = Math.round(order * len);\n            }\n            else if (order === 1) {\n                order = len;\n            }\n            else if (order > len) {\n                order = Math.round(order % len);\n            }\n        }\n        if (order < 0) {\n            order = 0;\n        }\n        if (order >= 0 && order < taskSequence.length) {\n            taskSequence.splice(order, 0, rst.taskName);\n        }\n        else {\n            taskSequence.push(rst.taskName);\n        }\n    }\n    return taskSequence;\n}\nexports.addToSequence = addToSequence;\n/**\n * filter task sequence. make sure no empty.\n *\n * @param {Src[]} seq\n * @param {(str: string) => boolean} [filter]\n * @returns {Src[]}\n */\nfunction filterTaskSequence(seq, express) {\n    let rseq = [];\n    express = express || ((it) => !!it);\n    _.each(seq, it => {\n        if (!it) {\n            return;\n        }\n        if (_.isString(it) && express(it)) {\n            rseq.push(it);\n        }\n        else if (_.isArray(it)) {\n            rseq.push(_.filter(it, itm => express(itm)));\n        }\n    });\n    return rseq;\n}\n/**\n * run task sequence.\n *\n * @protected\n * @param {Gulp} gulp\n * @param {Src[]} tasks\n * @returns {Promise<any>}\n *\n * @memberOf Development\n */\nfunction runSequence(gulp, tasks) {\n    tasks = filterTaskSequence(tasks);\n    console.log('run tasks : ', chalk.cyan(tasks));\n    let run = new Promise((resolve, reject) => {\n        let ps = null;\n        if (tasks && tasks.length > 0) {\n            _.each(tasks, task => {\n                if (ps) {\n                    ps = ps.then(() => {\n                        return startTask(gulp, task);\n                    });\n                }\n                else {\n                    ps = startTask(gulp, task);\n                }\n            });\n        }\n        else {\n            ps = Promise.resolve();\n        }\n        return ps\n            .then(resolve)\n            .catch(reject);\n    });\n    return run.catch(err => {\n        console.error(chalk.red(err));\n        // process.exit(0);\n    });\n}\nexports.runSequence = runSequence;\n/**\n * start task.\n *\n * @param {Gulp} gulp\n * @param {Src} task\n * @returns {Promise<any>}\n */\nfunction startTask(gulp, task) {\n    let taskErr = null, taskStop = null;\n    return new Promise((reslove, reject) => {\n        let tskmap = {};\n        _.each(_.isArray(task) ? task : [task], t => {\n            tskmap[t] = false;\n        });\n        taskErr = (err) => {\n            process.exit(err);\n            console.error(chalk.red(err));\n            reject(err);\n        };\n        taskStop = (e) => {\n            tskmap[e.task] = true;\n            if (!_.some(_.values(tskmap), it => !it)) {\n                reslove();\n            }\n        };\n        gulp.on('task_stop', taskStop)\n            .on('task_err', taskErr);\n        gulp.start(task);\n    })\n        .then(() => {\n        if (gulp['removeListener']) {\n            gulp['removeListener']('task_stop', taskStop);\n            gulp['removeListener']('task_err', taskErr);\n        }\n    }, err => {\n        if (gulp['removeListener']) {\n            gulp['removeListener']('task_stop', taskStop);\n            gulp['removeListener']('task_err', taskErr);\n        }\n        // process.exit(0);\n    });\n}\n/**\n * run task sequence\n *\n * @export\n * @param {Gulp} gulp\n * @param {(ITask[] | Promise<ITask[]>)} tasks\n * @param {ITaskContext} ctx\n * @returns {Promise<any>}\n */\nfunction runTaskSequence(gulp, tasks, ctx) {\n    return Promise.resolve(tasks)\n        .then(tasks => {\n        let taskseq = toSequence(gulp, tasks, ctx);\n        return runSequence(gulp, taskseq);\n    });\n}\nexports.runTaskSequence = runTaskSequence;\n","import * as _ from 'lodash';\r\nimport { Gulp } from 'gulp';\r\nimport * as chalk from 'chalk';\r\nimport { Src, ITaskInfo, ITaskContext, ITask, Operation } from './TaskConfig';\r\nimport { sortOrder } from './utils';\r\n/**\r\n * convert setup task result to run sequence src.\r\n * \r\n * @export\r\n * @param {Gulp} gulp\r\n * @param {ITask[]} tasks\r\n * @param {ITaskContext} ctx\r\n * @returns {Src[]}\r\n */\r\nexport function toSequence(gulp: Gulp, tasks: ITask[], ctx: ITaskContext): Src[] {\r\n    let seq: Src[] = [];\r\n    let len = tasks.length;\r\n    if (len < 1) {\r\n        return seq;\r\n    }\r\n    tasks = sortOrder<ITask>(tasks, t => t.getInfo().order);\r\n\r\n    let hasWatchtasks = [];\r\n    _.each(tasks, t => {\r\n        let info = t.getInfo();\r\n        if (info.oper & ctx.oper) {\r\n            let tname = t.setup(ctx, gulp);\r\n            if (tname) {\r\n                if ((info.oper & Operation.watch)) {\r\n                    hasWatchtasks.push(tname);\r\n                }\r\n                registerTasks(ctx, tname);\r\n\r\n                seq.push(tname);\r\n            }\r\n        }\r\n    });\r\n\r\n    let watchname = taskSequenceWatch(gulp, seq, ctx, it => {\r\n        if (!it) {\r\n            return false;\r\n        }\r\n        if (hasWatchtasks.length > 0) {\r\n            return hasWatchtasks.indexOf(it) < 0;\r\n        }\r\n        return true;\r\n    });\r\n    if (watchname) {\r\n        registerTasks(ctx, watchname);\r\n        seq.push(watchname);\r\n    }\r\n\r\n    return seq;\r\n}\r\n\r\nfunction registerTasks(ctx: ITaskContext, tasks: Src) {\r\n    ctx.globals.tasks = ctx.globals.tasks || {};\r\n    if (_.isArray(tasks)) {\r\n        _.each(tasks, t => registerGlobals(ctx, t));\r\n    } else {\r\n        registerGlobals(ctx, tasks);\r\n    }\r\n}\r\n\r\nfunction hasRegistered(ctx: ITaskContext, task: string) {\r\n    ctx.globals.tasks = ctx.globals.tasks || {};\r\n    return (ctx.globals.tasks[task]) ? true : false;\r\n}\r\n\r\nfunction registerGlobals(ctx: ITaskContext, task: string) {\r\n    if (ctx.globals.tasks[task]) {\r\n        console.error(chalk.red('has same task:'), chalk.cyan(task));\r\n        process.exit(0);\r\n    } else {\r\n        ctx.globals.tasks[task] = task;\r\n    }\r\n}\r\n\r\n/**\r\n * generate watch task for sequence\r\n * \r\n * @export\r\n * @param {Gulp} gulp\r\n * @param {Src[]} tasks\r\n * @param {ITaskContext} ctx\r\n * @param {(str: string) => boolean} [express]\r\n * @returns\r\n */\r\nexport function taskSequenceWatch(gulp: Gulp, tasks: Src[], ctx: ITaskContext, express?: (str: string) => boolean) {\r\n    // create watch task.\r\n    if ((ctx.oper & Operation.watch) && ctx.option.watch) {\r\n        let wats = [];\r\n        let name = '';\r\n        if (_.isBoolean(ctx.option.watch)) {\r\n            let toWatchSeq = filterTaskSequence(tasks, express);\r\n            name = zipSequence(gulp, toWatchSeq, ctx);\r\n            name && wats.push(name);\r\n        } else {\r\n            wats = ctx.option.watch;\r\n        }\r\n\r\n        if (wats.length > 0) {\r\n            name = name ? name + '-owatch' : 'owatch';\r\n            gulp.task(name, () => {\r\n                let src = ctx.getSrc();\r\n                console.log('watch, src:', chalk.cyan.call(chalk, src));\r\n                gulp.watch(src, wats)\r\n            });\r\n            return name;\r\n        }\r\n    }\r\n    return '';\r\n}\r\n\r\nfunction registerZipTask(gulp: Gulp, name: string, tasks: Src[], ctx: ITaskContext) {\r\n    let i = 0;\r\n    let taskname = name;\r\n    while (hasRegistered(ctx, taskname) && i < 50) {\r\n        taskname = name + i;\r\n        console.log('try register name: ', chalk.cyan(taskname));\r\n        i++;\r\n    }\r\n    if (i >= 50) {\r\n        console.error(chalk.red('has same task:'), chalk.cyan(name), 'too many times.');\r\n        return '';\r\n    }\r\n\r\n    registerGlobals(ctx, taskname);\r\n    gulp.task(taskname, () => {\r\n        return runSequence(gulp, tasks);\r\n    });\r\n    return taskname;\r\n}\r\n\r\n/**\r\n * zip tasks to a single task.\r\n * \r\n * @export\r\n * @param {Gulp} gulp\r\n * @param {string[]} tasks tasks sequence\r\n * @param {ITaskContext} ctx\r\n * @returns {string}\r\n */\r\nexport function zipSequence(gulp: Gulp, tasks: Src[], ctx: ITaskContext): string {\r\n    if (tasks.length > 1) {\r\n        let first = _.first(tasks);\r\n        first = _.isArray(first) ? _.first(first) : first;\r\n        let last = _.last(tasks);\r\n        last = _.isArray(last) ? _.last(last) : last;\r\n        let name = `${first}-${last}-seq`;\r\n        return registerZipTask(gulp, name, tasks, ctx);\r\n\r\n    } else if (tasks.length === 1) {\r\n        let first = _.first(tasks);\r\n        if (_.isArray(first)) {\r\n            if (first.length > 1) {\r\n                let fs = _.first(first);\r\n                let ls = _.last(first);\r\n                let name = `${fs}-${ls}-paral`;\r\n                return registerZipTask(gulp, name, tasks, ctx);\r\n            } else {\r\n                return _.first(first) || '';\r\n            }\r\n        } else {\r\n            return first || '';\r\n        }\r\n    }\r\n\r\n    return '';\r\n}\r\n\r\n/**\r\n * flatten task Sequence.\r\n * \r\n * @export\r\n * @param {Gulp} gulp\r\n * @param {Src[]} tasks\r\n * @param {ITaskContext} ctx\r\n * @returns {string[]}\r\n */\r\nexport function flattenSequence(gulp: Gulp, tasks: Src[], ctx: ITaskContext): string[] {\r\n    let result: string[] = [];\r\n    _.each(tasks, tk => {\r\n        if (_.isArray(tk)) {\r\n            let zipSrc: Src[] = (_.some(tk, t => _.isArray(t))) ? tk : [tk];\r\n            let taskname = zipSequence(gulp, zipSrc, ctx);\r\n            taskname && result.push(taskname);\r\n        } else {\r\n            result.push(tk);\r\n        }\r\n    });\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * add task to task sequence.\r\n * \r\n * @export\r\n * @param {Src[]} taskSequence\r\n * @param {ITaskInfo} rst\r\n * @returns\r\n */\r\nexport function addToSequence(taskSequence: Src[], rst: ITaskInfo) {\r\n    if (!rst) {\r\n        return taskSequence;\r\n    }\r\n    if (rst.taskName) {\r\n        let order = 1;\r\n        let len = taskSequence.length + 1;\r\n        if (_.isNumber(rst.order)) {\r\n            order = rst.order;\r\n        } else if (_.isFunction(rst.order)) {\r\n            order = rst.order(len)\r\n        }\r\n\r\n        if (_.isNumber(order)) {\r\n            if (order > 0 && order < 1) {\r\n                order = Math.round(order * len);\r\n            } else if (order === 1) {\r\n                order = len;\r\n            } else if (order > len) {\r\n                order = Math.round(order % len);\r\n            }\r\n        }\r\n        if (order < 0) {\r\n            order = 0;\r\n        }\r\n\r\n        if (order >= 0 && order < taskSequence.length) {\r\n            taskSequence.splice(order, 0, rst.taskName);\r\n        } else {\r\n            taskSequence.push(rst.taskName);\r\n        }\r\n    }\r\n    return taskSequence;\r\n}\r\n\r\n\r\n/**\r\n * filter task sequence. make sure no empty.\r\n * \r\n * @param {Src[]} seq\r\n * @param {(str: string) => boolean} [filter]\r\n * @returns {Src[]}\r\n */\r\nfunction filterTaskSequence(seq: Src[], express?: (str: string) => boolean): Src[] {\r\n    let rseq: Src[] = [];\r\n    express = express || ((it) => !!it);\r\n    _.each(seq, it => {\r\n        if (!it) {\r\n            return;\r\n        }\r\n        if (_.isString(it) && express(it)) {\r\n            rseq.push(it);\r\n        } else if (_.isArray(it)) {\r\n            rseq.push(_.filter(it, itm => express(itm)));\r\n        }\r\n    });\r\n    return rseq;\r\n}\r\n/**\r\n * run task sequence.\r\n * \r\n * @protected\r\n * @param {Gulp} gulp\r\n * @param {Src[]} tasks\r\n * @returns {Promise<any>}\r\n * \r\n * @memberOf Development\r\n */\r\nexport function runSequence(gulp: Gulp, tasks: Src[]): Promise<any> {\r\n    tasks = filterTaskSequence(tasks);\r\n    console.log('run tasks : ', chalk.cyan(<any>tasks));\r\n    let run = new Promise((resolve, reject) => {\r\n        let ps: Promise<any> = null;\r\n        if (tasks && tasks.length > 0) {\r\n            _.each(tasks, task => {\r\n                if (ps) {\r\n                    ps = ps.then(() => {\r\n                        return startTask(gulp, task);\r\n                    })\r\n                } else {\r\n                    ps = startTask(gulp, task);\r\n                }\r\n            });\r\n        } else {\r\n            ps = Promise.resolve();\r\n        }\r\n        return ps\r\n            .then(resolve)\r\n            .catch(reject);\r\n    });\r\n    return run.catch(err => {\r\n        console.error(chalk.red(err));\r\n        // process.exit(0);\r\n    });\r\n}\r\n\r\n/**\r\n * start task.\r\n * \r\n * @param {Gulp} gulp\r\n * @param {Src} task\r\n * @returns {Promise<any>}\r\n */\r\nfunction startTask(gulp: Gulp, task: Src): Promise<any> {\r\n    let taskErr = null, taskStop = null;\r\n    return new Promise((reslove, reject) => {\r\n        let tskmap: any = {};\r\n        _.each(_.isArray(task) ? task : [task], t => {\r\n            tskmap[t] = false;\r\n        });\r\n        taskErr = (err) => {\r\n            process.exit(err);\r\n            console.error(chalk.red(err));\r\n            reject(err);\r\n        };\r\n        taskStop = (e: any) => {\r\n            tskmap[e.task] = true;\r\n            if (!_.some(_.values(tskmap), it => !it)) {\r\n                reslove();\r\n            }\r\n        }\r\n        gulp.on('task_stop', taskStop)\r\n            .on('task_err', taskErr);\r\n        gulp.start(task);\r\n    })\r\n        .then(() => {\r\n            if (gulp['removeListener']) {\r\n                gulp['removeListener']('task_stop', taskStop);\r\n                gulp['removeListener']('task_err', taskErr);\r\n            }\r\n        }, err => {\r\n            if (gulp['removeListener']) {\r\n                gulp['removeListener']('task_stop', taskStop);\r\n                gulp['removeListener']('task_err', taskErr);\r\n            }\r\n            // process.exit(0);\r\n        });\r\n}\r\n\r\n/**\r\n * run task sequence\r\n * \r\n * @export\r\n * @param {Gulp} gulp\r\n * @param {(ITask[] | Promise<ITask[]>)} tasks\r\n * @param {ITaskContext} ctx\r\n * @returns {Promise<any>}\r\n */\r\nexport function runTaskSequence(gulp: Gulp, tasks: ITask[] | Promise<ITask[]>, ctx: ITaskContext): Promise<any> {\r\n    return Promise.resolve(tasks)\r\n        .then(tasks => {\r\n            let taskseq = toSequence(gulp, tasks, ctx);\r\n            return runSequence(gulp, taskseq);\r\n        });\r\n}\r\n"]}