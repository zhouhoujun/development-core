{"version":3,"sources":["taskSequence.js","taskSequence.ts"],"names":["toSequence","gulp","tasks","config","seq","len","length","_","orderBy","t","isArray","isNumber","decorator","order","each","watch","env","oper","tname","setup","push","addToSequence","taskSequence","rst","name","splice","runSequence","ps","Promise","resolve","task","then","taskErr","taskStop","reslove","reject","tskmap","err","process","exit","console","error","chalk","red","e","some","values","it","on","start","catch","runTaskSequence","taskseq","require","exports"],"mappings":"AAAA,YCcA,SAAAA,YAA2BC,EAAYC,EAAgBC,GACnD,GAAIC,MACAC,EAAMH,EAAMI,MAChB,OAAID,GAAM,EACCD,GAGXF,EAAQK,EAAEC,QAAQN,EAAO,SAAAO,GACrB,MAAIF,GAAEG,QAAQD,GACHJ,EAEHE,EAAEI,SAASF,EAAEG,UAAUC,OAChBJ,EAAEG,UAAUC,MAEhBR,IAIfE,EAAEO,KAAKZ,EAAO,SAAAO,GACV,KAAIA,EAAEG,UAAUG,OAAUZ,EAAOa,IAAID,UAIhCN,EAAEG,UAAUK,MACZR,EAAEG,UAAUK,OAASR,EAAEG,UAAUK,KAAOd,EAAOc,MAAQ,GAAI,CAC5D,GAAIC,GAAQT,EAAEU,MAAMhB,EAAQF,EAC5BiB,IAASd,EAAIgB,KAAKF,MAKnBd,GAYX,QAAAiB,eAA8BC,EAAqBC,GAC/C,IAAKA,EACD,MAAOD,EAEX,IAAIC,EAAIC,KAAM,CACV,GAAIjB,EAAEI,SAASY,EAAIV,QAAUU,EAAIV,OAAS,GAAKU,EAAIV,MAAQS,EAAahB,OAEpE,MADAgB,GAAaG,OAAOF,EAAIV,MAAO,EAAGU,EAAIC,MAC/BF,CAEXA,GAAaF,KAAKG,EAAIC,MAE1B,MAAOF,GAaX,QAAAI,aAA4BzB,EAAYC,GACpC,GAAIyB,GAAKC,QAAQC,SAwCjB,OAvCI3B,IAASA,EAAMI,OAAS,GACxBC,EAAEO,KAAKZ,EAAO,SAAA4B,GACVH,EAAKA,EAAGI,KAAK,WACT,GAAIC,GAAU,KAAMC,EAAW,IAC/B,OAAO,IAAIL,SAAQ,SAACM,EAASC,GACzB,GAAIC,KACJ7B,GAAEO,KAAKP,EAAEG,QAAQoB,GAAQA,GAAQA,GAAO,SAAArB,GACpC2B,EAAO3B,IAAK,IAEhBuB,EAAU,SAACK,GACPC,QAAQC,KAAKF,GACbG,QAAQC,MAAMC,MAAMC,IAAIN,IACxBF,EAAOE,IAEXJ,EAAW,SAACW,GACRR,EAAOQ,EAAEd,OAAQ,EACZvB,EAAEsC,KAAKtC,EAAEuC,OAAOV,GAAS,SAAAW,GAAA,OAAOA,KACjCb,KAGRjC,EAAK+C,GAAG,YAAaf,GAChBe,GAAG,WAAYhB,GACpB/B,EAAKgD,MAAMnB,KAEVC,KAAK,WACE9B,EAAA,iBACAA,EAAA,eAAuB,YAAagC,GACpChC,EAAA,eAAuB,WAAY+B,MAG1CkB,MAAM,SAAAb,GACCpC,EAAA,iBACAA,EAAA,eAAuB,YAAagC,GACpChC,EAAA,eAAuB,WAAY+B,UAMpDL,EAAGuB,MAAM,SAAAb,GACZG,QAAQC,MAAMC,MAAMC,IAAIN,MAahC,QAAAc,iBAAgClD,EAAYC,EAAgBC,GACxD,GAAIiD,GAAUpD,WAAWC,EAAMC,EAAOC,EACtC,OAAOuB,aAAYzB,EAAMmD,GA1I7B,GAAY7C,GAAC8C,QAAM,UAEPX,MAAKW,QAAM,QAYPC,SAAAtD,WAAUA,WA2CVsD,QAAAjC,cAAaA,cAwBbiC,QAAA5B,YAAWA,YAuDX4B,QAAAH,gBAAeA","file":"../taskSequence.js","sourcesContent":["\"use strict\";\nconst _ = require('lodash');\nconst chalk = require('chalk');\nfunction toSequence(gulp, tasks, config) {\n    let seq = [];\n    let len = tasks.length;\n    if (len < 1) {\n        return seq;\n    }\n    tasks = _.orderBy(tasks, t => {\n        if (_.isArray(t)) {\n            return len;\n        }\n        else {\n            if (_.isNumber(t.decorator.order)) {\n                return t.decorator.order;\n            }\n            return len;\n        }\n    });\n    _.each(tasks, t => {\n        if (t.decorator.watch && !config.env.watch) {\n            return;\n        }\n        if (!t.decorator.oper ||\n            (t.decorator.oper && (t.decorator.oper & config.oper) > 0)) {\n            let tname = t.setup(config, gulp);\n            tname && seq.push(tname);\n        }\n    });\n    return seq;\n}\nexports.toSequence = toSequence;\nfunction addToSequence(taskSequence, rst) {\n    if (!rst) {\n        return taskSequence;\n    }\n    if (rst.name) {\n        if (_.isNumber(rst.order) && rst.order >= 0 && rst.order < taskSequence.length) {\n            taskSequence.splice(rst.order, 0, rst.name);\n            return taskSequence;\n        }\n        taskSequence.push(rst.name);\n    }\n    return taskSequence;\n}\nexports.addToSequence = addToSequence;\nfunction runSequence(gulp, tasks) {\n    let ps = Promise.resolve();\n    if (tasks && tasks.length > 0) {\n        _.each(tasks, task => {\n            ps = ps.then(() => {\n                let taskErr = null, taskStop = null;\n                return new Promise((reslove, reject) => {\n                    let tskmap = {};\n                    _.each(_.isArray(task) ? task : [task], t => {\n                        tskmap[t] = false;\n                    });\n                    taskErr = (err) => {\n                        process.exit(err);\n                        console.error(chalk.red(err));\n                        reject(err);\n                    };\n                    taskStop = (e) => {\n                        tskmap[e.task] = true;\n                        if (!_.some(_.values(tskmap), it => !it)) {\n                            reslove();\n                        }\n                    };\n                    gulp.on('task_stop', taskStop)\n                        .on('task_err', taskErr);\n                    gulp.start(task);\n                })\n                    .then(() => {\n                    if (gulp['removeListener']) {\n                        gulp['removeListener']('task_stop', taskStop);\n                        gulp['removeListener']('task_err', taskErr);\n                    }\n                })\n                    .catch(err => {\n                    if (gulp['removeListener']) {\n                        gulp['removeListener']('task_stop', taskStop);\n                        gulp['removeListener']('task_err', taskErr);\n                    }\n                });\n            });\n        });\n    }\n    return ps.catch(err => {\n        console.error(chalk.red(err));\n    });\n}\nexports.runSequence = runSequence;\nfunction runTaskSequence(gulp, tasks, config) {\n    let taskseq = toSequence(gulp, tasks, config);\n    return runSequence(gulp, taskseq);\n}\nexports.runTaskSequence = runTaskSequence;\n","import * as _ from 'lodash';\r\nimport { Gulp } from 'gulp';\r\nimport * as chalk from 'chalk';\r\nimport { Src, ITaskInfo, ITaskConfig, ITask } from './TaskConfig';\r\n\r\n/**\r\n * convert setup task result to run sequence src.\r\n * \r\n * @export\r\n * @param {Gulp} gulp\r\n * @param {ITask[]} tasks\r\n * @param {ITaskConfig} config\r\n * @returns {Src[]}\r\n */\r\nexport function toSequence(gulp: Gulp, tasks: ITask[], config: ITaskConfig): Src[] {\r\n    let seq: Src[] = [];\r\n    let len = tasks.length;\r\n    if (len < 1) {\r\n        return seq;\r\n    }\r\n\r\n    tasks = _.orderBy(tasks, t => {\r\n        if (_.isArray(t)) {\r\n            return len;\r\n        } else {\r\n            if (_.isNumber(t.decorator.order)) {\r\n                return t.decorator.order;\r\n            }\r\n            return len;\r\n        }\r\n    });\r\n\r\n    _.each(tasks, t => {\r\n        if (t.decorator.watch && !config.env.watch) {\r\n            return;\r\n        }\r\n\r\n        if (!t.decorator.oper ||\r\n            (t.decorator.oper && (t.decorator.oper & config.oper) > 0)) {\r\n            let tname = t.setup(config, gulp);\r\n            tname && seq.push(tname);\r\n        }\r\n\r\n    });\r\n\r\n    return seq;\r\n}\r\n\r\n\r\n/**\r\n * add task to task sequence.\r\n * \r\n * @export\r\n * @param {Src[]} taskSequence\r\n * @param {ITaskInfo} rst\r\n * @returns\r\n */\r\nexport function addToSequence(taskSequence: Src[], rst: ITaskInfo) {\r\n    if (!rst) {\r\n        return taskSequence;\r\n    }\r\n    if (rst.name) {\r\n        if (_.isNumber(rst.order) && rst.order >= 0 && rst.order < taskSequence.length) {\r\n            taskSequence.splice(rst.order, 0, rst.name);\r\n            return taskSequence;\r\n        }\r\n        taskSequence.push(rst.name);\r\n    }\r\n    return taskSequence;\r\n}\r\n\r\n/**\r\n * run task sequence.\r\n * \r\n * @protected\r\n * @param {Gulp} gulp\r\n * @param {Src[]} tasks\r\n * @returns {Promise<any>}\r\n * \r\n * @memberOf Development\r\n */\r\nexport function runSequence(gulp: Gulp, tasks: Src[]): Promise<any> {\r\n    let ps = Promise.resolve();\r\n    if (tasks && tasks.length > 0) {\r\n        _.each(tasks, task => {\r\n            ps = ps.then(() => {\r\n                let taskErr = null, taskStop = null;\r\n                return new Promise((reslove, reject) => {\r\n                    let tskmap: any = {};\r\n                    _.each(_.isArray(task) ? task : [task], t => {\r\n                        tskmap[t] = false;\r\n                    });\r\n                    taskErr = (err) => {\r\n                        process.exit(err);\r\n                        console.error(chalk.red(err));\r\n                        reject(err);\r\n                    };\r\n                    taskStop = (e: any) => {\r\n                        tskmap[e.task] = true;\r\n                        if (!_.some(_.values(tskmap), it => !it)) {\r\n                            reslove();\r\n                        }\r\n                    }\r\n                    gulp.on('task_stop', taskStop)\r\n                        .on('task_err', taskErr);\r\n                    gulp.start(task);\r\n                })\r\n                    .then(() => {\r\n                        if (gulp['removeListener']) {\r\n                            gulp['removeListener']('task_stop', taskStop);\r\n                            gulp['removeListener']('task_err', taskErr);\r\n                        }\r\n                    })\r\n                    .catch(err => {\r\n                        if (gulp['removeListener']) {\r\n                            gulp['removeListener']('task_stop', taskStop);\r\n                            gulp['removeListener']('task_err', taskErr);\r\n                        }\r\n                    });\r\n            });\r\n        });\r\n    }\r\n    return ps.catch(err => {\r\n        console.error(chalk.red(err));\r\n    });\r\n}\r\n\r\n/**\r\n * run task sequence\r\n * \r\n * @export\r\n * @param {Gulp} gulp\r\n * @param {ITask[]} tasks\r\n * @param {TaskConfig} config\r\n * @returns {Promise<any>}\r\n */\r\nexport function runTaskSequence(gulp: Gulp, tasks: ITask[], config: ITaskConfig): Promise<any> {\r\n    let taskseq = toSequence(gulp, tasks, config);\r\n    return runSequence(gulp, taskseq);\r\n}\r\n"]}