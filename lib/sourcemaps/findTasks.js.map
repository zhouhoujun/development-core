{"version":3,"sources":["findTasks.ts"],"names":["findTaskset","tasks","target","match","ctx","_","isFunction","tinfo","isBoolean","utils_1","matchCompare","has","task","setInfo","set","tinfo_1","dyts","map","tk","extend","clone","generateTask_1","generateTask","isArray","each","sm","keys","key","test","findTaskMap","Map","forEach","it","push","apply","addTask","findTasks","findTaskDefines","defs","dc","concat","findTaskDefine","def","findTaskDefineInModule","md","tsdef","isString","require","err","Promise","reject","resolve","findTasksInModule","mdls","findTaskDefineInDir","dirs","race","dir","fs_1","existsSync","mdl","requireDir","duplicates","camelcase","recurse","findTasksInDir","all","console","log","chalk","grey","cyan","then","flatten","exports"],"mappings":"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","file":"../findTasks.js","sourcesContent":["import 'reflect-metadata';\r\nimport * as _ from 'lodash';\r\nimport * as chalk from 'chalk';\r\nimport { ITask, ITaskDecorator, ITaskContext, ITaskDefine, Src, IDynamicTasks } from './TaskConfig';\r\nimport { generateTask } from './generateTask';\r\n// import { bindingConfig } from './bindingConfig';\r\nimport { matchCompare } from './utils';\r\nimport { existsSync } from 'fs';\r\nconst requireDir = require('require-dir');\r\n\r\n\r\ntype Taskitem = ITask | ITask[];\r\n\r\nfunction findTaskset(tasks: Map<any, Taskitem>, target: any, match?: ITaskDecorator, ctx?: ITaskContext) {\r\n\r\n    if (!target) {\r\n        return;\r\n    }\r\n    if (_.isFunction(target)) {\r\n        if (target['__task']) {\r\n            let tinfo: ITaskDecorator = target['__task'];\r\n            tinfo = _.isBoolean(tinfo) ? {} : tinfo;\r\n\r\n            if (!matchCompare(ctx, tinfo, match)) {\r\n                return;\r\n            }\r\n            if (tasks.has(target)) {\r\n                return;\r\n            }\r\n\r\n            let task: ITask = new target(tinfo);\r\n            if (task.setInfo) {\r\n                task.setInfo(tinfo);\r\n            }\r\n\r\n            tasks.set(target, task);\r\n\r\n        } else if (target['__dynamictask']) {\r\n            let tinfo: ITaskDecorator = target['__dynamictask'];\r\n\r\n            if (!matchCompare(ctx, tinfo, match)) {\r\n                return;\r\n            }\r\n\r\n            if (tasks.has(target)) {\r\n                return;\r\n            }\r\n\r\n            let dyts = _.map((<IDynamicTasks>new target()).tasks(), tk => {\r\n                tk = _.extend(_.clone(tinfo), tk);\r\n                // tk.group = tk.group || tinfo.group;\r\n                return tk;\r\n            });\r\n            tasks.set(target, generateTask(ctx, dyts, match));\r\n        }\r\n    } else if (_.isArray(target)) {\r\n        _.each(target, sm => {\r\n            findTaskset(tasks, sm, match, ctx);\r\n        });\r\n    } else {\r\n        _.each(_.keys(target), key => {\r\n            if (!key || !target[key] || /^[0-9]+$/.test(key)) {\r\n                return;\r\n            }\r\n            // console.log(chalk.grey('find task from :'), chalk.cyan(key));\r\n            findTaskset(tasks, target[key], match, ctx);\r\n        });\r\n    }\r\n}\r\n\r\n\r\nfunction findTaskMap(target: any, match?: ITaskDecorator, ctx?: ITaskContext, map?: Map<any, Taskitem>): ITask[] {\r\n    map = map || new Map<any, Taskitem>();\r\n    findTaskset(map, target, match, ctx);\r\n    let tasks: ITask[] = [];\r\n    map.forEach((it: Taskitem) => {\r\n        if (_.isArray(it)) {\r\n            tasks.push(...it);\r\n        } else {\r\n            tasks.push(it);\r\n        }\r\n    });\r\n    if (ctx) {\r\n        ctx.addTask(...tasks);\r\n    }\r\n    return tasks;\r\n}\r\n/**\r\n * find tasks in Object module.\r\n *\r\n * @export\r\n * @param {*} target\r\n * @param {ITaskDecorator} [match]\r\n * @param {ITaskContext} [ctx]\r\n * @returns {ITask[]}\r\n */\r\nexport function findTasks(target: any, match?: ITaskDecorator, ctx?: ITaskContext): ITask[] {\r\n    return findTaskMap(target, match, ctx);\r\n}\r\n\r\n/**\r\n * get all taskdefine in module.\r\n *\r\n * @export\r\n * @param {any} target\r\n * @returns\r\n */\r\nexport function findTaskDefines(target): ITaskDefine[] {\r\n    let defs: ITaskDefine[] = [];\r\n    if (!target) {\r\n        return defs;\r\n    }\r\n    if (_.isFunction(target)) {\r\n        if (target['__task_context']) {\r\n            let dc = new target();\r\n            // if (!dc['getContext']) {\r\n            //     dc = taskDefine2Context(dc);\r\n            // }\r\n            defs.push(<ITaskDefine>dc);\r\n        }\r\n    } else if (_.isArray(target)) {\r\n        _.each(target, sm => {\r\n            defs.concat(findTaskDefines(sm));\r\n        });\r\n    } else {\r\n        _.each(_.keys(target), key => {\r\n            if (!key || !target[key] || /^[0-9]+$/.test(key)) {\r\n                return;\r\n            }\r\n            // console.log(chalk.grey('find task define from :'), chalk.cyan(key));\r\n            defs = defs.concat(findTaskDefines(target[key]));\r\n        });\r\n    }\r\n\r\n    return defs;\r\n}\r\n\r\n\r\n/**\r\n * get one taskdefine in module.\r\n *\r\n * @export\r\n * @param {any} target\r\n * @returns\r\n */\r\nexport function findTaskDefine(target): ITaskDefine {\r\n    let def: ITaskDefine;\r\n    if (!target) {\r\n        return null;\r\n    }\r\n    if (_.isFunction(target)) {\r\n        if (target['__task_context']) {\r\n            def = new target();\r\n            // if (dc['getContext']) {\r\n            //     def = dc;\r\n            // } else {\r\n            //     def = taskDefine2Context(dc);\r\n            // }\r\n        }\r\n    } else if (_.isArray(target)) {\r\n        _.each(target, sm => {\r\n            if (def) {\r\n                return false;\r\n            }\r\n            def = findTaskDefine(sm);\r\n            return true;\r\n        });\r\n    } else {\r\n        _.each(_.keys(target), key => {\r\n            if (def) {\r\n                return false;\r\n            }\r\n            if (!key || !target[key] || /^[0-9]+$/.test(key)) {\r\n                return true;\r\n            }\r\n            // console.log(chalk.grey('find task define from :'), chalk.cyan(key));\r\n            def = findTaskDefine(target[key]);\r\n            return true;\r\n        });\r\n    }\r\n\r\n    return def;\r\n}\r\n\r\n/**\r\n * find one taskdefine in module.\r\n *\r\n * @export\r\n * @param {(string | Object)} md\r\n * @returns {Promise<ITaskDefine>}\r\n */\r\nexport function findTaskDefineInModule(md: string | Object): Promise<ITaskDefine> {\r\n    let tsdef;\r\n    try {\r\n        if (_.isString(md)) {\r\n            tsdef = findTaskDefine(require(md));\r\n        } else {\r\n            tsdef = findTaskDefine(md);\r\n        }\r\n    } catch (err) {\r\n        return Promise.reject(err);\r\n    }\r\n\r\n    if (tsdef) {\r\n        return Promise.resolve(tsdef);\r\n    } else {\r\n        // console.error('can not found task config builder method in module {0}.', mdl);\r\n        // console.log(chalk.yellow('can not found task define in module.'));\r\n        return Promise.resolve(null);\r\n    }\r\n}\r\n\r\n/**\r\n * fund tasks in module.\r\n *\r\n * @export\r\n * @param {(string | Object)} md\r\n * @param {ITaskDecorator} [match]\r\n * @param {ITaskContext} [ctx]\r\n * @returns {Promise<ITask[]>}\r\n */\r\nexport function findTasksInModule(md: string | Object, match?: ITaskDecorator, ctx?: ITaskContext): Promise<ITask[]> {\r\n    let mdls;\r\n    try {\r\n        if (_.isString(md)) {\r\n            mdls = findTasks(require(md), match, ctx);\r\n        } else {\r\n            mdls = findTasks(md, match, ctx);\r\n        }\r\n    } catch (err) {\r\n        return Promise.reject(err);\r\n    }\r\n\r\n    return Promise.resolve(mdls);\r\n}\r\n\r\n\r\n/**\r\n * find one task define in directories.\r\n *\r\n * @export\r\n * @param {Src} dirs\r\n * @returns {Promise<ITaskDefine>}\r\n */\r\nexport function findTaskDefineInDir(dirs: Src): Promise<ITaskDefine> {\r\n    return Promise.race<ITaskDefine>(_.map(_.isArray(dirs) ? dirs : [dirs], dir => {\r\n        return new Promise<ITaskDefine>((resolve, reject) => {\r\n            if (existsSync(dir)) {\r\n                let mdl = requireDir(dir, { duplicates: true, camelcase: true, recurse: true });\r\n                if (mdl) {\r\n                    let def = findTaskDefine(mdl);\r\n                    if (def) {\r\n                        resolve(def);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }));\r\n}\r\n\r\n/**\r\n * find tasks in directories.\r\n *\r\n * @export\r\n * @param {Src} dirs\r\n * @param {ITaskDecorator} [match]\r\n * @param {ITaskContext} [ctx]\r\n * @returns {Promise<ITask[]>}\r\n */\r\nexport function findTasksInDir(dirs: Src, match?: ITaskDecorator, ctx?: ITaskContext): Promise<ITask[]> {\r\n    let map = new Map<any, Taskitem>();\r\n    return Promise.all(_.map(_.isArray(dirs) ? dirs : [dirs], dir => {\r\n        console.log(chalk.grey('begin load task from dir'), chalk.cyan(dir));\r\n        try {\r\n            let mdl = requireDir(dir, { duplicates: true, camelcase: true, recurse: true });\r\n            return Promise.resolve(findTaskMap(mdl, match, ctx, map));\r\n        } catch (err) {\r\n            return Promise.reject(err);\r\n        }\r\n    }))\r\n        .then(tasks => {\r\n            return _.flatten(tasks);\r\n        });\r\n}\r\n"]}