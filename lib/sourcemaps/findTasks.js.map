{"version":3,"sources":["findTasks.ts"],"names":["findTaskset","tasks","target","match","ctx","tinfo","_","isBoolean","match_1","matchCompare","has","task","setInfo","set","tinfo_1","dyts","map","tk","extend","clone","generateTask_1","generateTask","isArray","each","sm","keys","key","test","findTaskMap","Map","forEach","it","push","apply","addTask","findTasks","findTaskDefines","defs","dc","concat","findTaskDefine","def","findTaskDefineInModule","md","tsdef","isString","require","err","Promise","reject","resolve","findTasksInModule","mdls","findTaskDefineInDir","dirs","race","dir","fs_1","existsSync","mdl","requireDir","duplicates","camelcase","recurse","findTasksInDir","all","console","log","chalk","grey","cyan","then","flatten","exports"],"mappings":"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","file":"../findTasks.js","sourcesContent":["import 'reflect-metadata';\r\nimport * as _ from 'lodash';\r\nimport * as chalk from 'chalk';\r\nimport { generateTask } from './generateTask';\r\n// import { bindingConfig } from './bindingConfig';\r\nimport { matchCompare } from './utils/match';\r\nimport { existsSync } from 'fs';\r\nimport { ITask } from './ITask';\r\nimport { ITaskDecorator } from './ITaskDecorator';\r\nimport { IDynamicTasks } from './IDynamicTasks';\r\nimport { ITaskContext } from './ITaskContext';\r\nimport { ITaskDefine } from './ITaskDefine';\r\nimport { Src } from './types';\r\nconst requireDir = require('require-dir');\r\n\r\n\r\ntype Taskitem = ITask | ITask[];\r\n\r\nfunction findTaskset(tasks: Map<any, Taskitem>, target: any, match?: ITaskDecorator, ctx?: ITaskContext) {\r\n\r\n    if (!target) {\r\n        return;\r\n    }\r\n    if (typeof(target) === 'function') { // _.isFunction(target)) {\r\n        if (target['__task']) {\r\n            let tinfo: ITaskDecorator = target['__task'];\r\n            tinfo = _.isBoolean(tinfo) ? {} : tinfo;\r\n\r\n            if (!matchCompare(ctx, tinfo, match)) {\r\n                return;\r\n            }\r\n            if (tasks.has(target)) {\r\n                return;\r\n            }\r\n\r\n            let task: ITask = new target(tinfo);\r\n            if (task.setInfo) {\r\n                task.setInfo(tinfo);\r\n            }\r\n\r\n            tasks.set(target, task);\r\n\r\n        } else if (target['__dynamictask']) {\r\n            let tinfo: ITaskDecorator = target['__dynamictask'];\r\n\r\n            if (!matchCompare(ctx, tinfo, match)) {\r\n                return;\r\n            }\r\n\r\n            if (tasks.has(target)) {\r\n                return;\r\n            }\r\n\r\n            let dyts = _.map((<IDynamicTasks>new target()).tasks(), tk => {\r\n                tk = _.extend(_.clone(tinfo), tk);\r\n                // tk.group = tk.group || tinfo.group;\r\n                return tk;\r\n            });\r\n            tasks.set(target, generateTask(ctx, dyts, match));\r\n        }\r\n    } else if (_.isArray(target)) {\r\n        _.each(target, sm => {\r\n            findTaskset(tasks, sm, match, ctx);\r\n        });\r\n    } else {\r\n        _.each(_.keys(target), key => {\r\n            if (!key || !target[key] || /^[0-9]+$/.test(key)) {\r\n                return;\r\n            }\r\n            // console.log(chalk.grey('find task from :'), chalk.cyan(key));\r\n            findTaskset(tasks, target[key], match, ctx);\r\n        });\r\n    }\r\n}\r\n\r\n\r\nfunction findTaskMap(target: any, match?: ITaskDecorator, ctx?: ITaskContext, map?: Map<any, Taskitem>): ITask[] {\r\n    map = map || new Map<any, Taskitem>();\r\n    findTaskset(map, target, match, ctx);\r\n    let tasks: ITask[] = [];\r\n    map.forEach((it: Taskitem) => {\r\n        if (_.isArray(it)) {\r\n            tasks.push(...it);\r\n        } else {\r\n            tasks.push(it);\r\n        }\r\n    });\r\n    if (ctx) {\r\n        ctx.addTask(...tasks);\r\n    }\r\n    return tasks;\r\n}\r\n/**\r\n * find tasks in Object module.\r\n *\r\n * @export\r\n * @param {*} target\r\n * @param {ITaskDecorator} [match]\r\n * @param {ITaskContext} [ctx]\r\n * @returns {ITask[]}\r\n */\r\nexport function findTasks(target: any, match?: ITaskDecorator, ctx?: ITaskContext): ITask[] {\r\n    return findTaskMap(target, match, ctx);\r\n}\r\n\r\n/**\r\n * get all taskdefine in module.\r\n *\r\n * @export\r\n * @param {any} target\r\n * @returns\r\n */\r\nexport function findTaskDefines(target): ITaskDefine[] {\r\n    let defs: ITaskDefine[] = [];\r\n    if (!target) {\r\n        return defs;\r\n    }\r\n    if (typeof(target) === 'function') {\r\n        if (target['__task_context']) {\r\n            let dc = new target();\r\n            // if (!dc['getContext']) {\r\n            //     dc = taskDefine2Context(dc);\r\n            // }\r\n            defs.push(<ITaskDefine>dc);\r\n        }\r\n    } else if (_.isArray(target)) {\r\n        _.each(target, sm => {\r\n            defs.concat(findTaskDefines(sm));\r\n        });\r\n    } else {\r\n        _.each(_.keys(target), key => {\r\n            if (!key || !target[key] || /^[0-9]+$/.test(key)) {\r\n                return;\r\n            }\r\n            // console.log(chalk.grey('find task define from :'), chalk.cyan(key));\r\n            defs = defs.concat(findTaskDefines(target[key]));\r\n        });\r\n    }\r\n\r\n    return defs;\r\n}\r\n\r\n\r\n/**\r\n * get one taskdefine in module.\r\n *\r\n * @export\r\n * @param {any} target\r\n * @returns\r\n */\r\nexport function findTaskDefine(target): ITaskDefine {\r\n    let def: ITaskDefine;\r\n    if (!target) {\r\n        return null;\r\n    }\r\n    if (typeof(target) === 'function') {\r\n        if (target['__task_context']) {\r\n            def = new target();\r\n            // if (dc['getContext']) {\r\n            //     def = dc;\r\n            // } else {\r\n            //     def = taskDefine2Context(dc);\r\n            // }\r\n        }\r\n    } else if (_.isArray(target)) {\r\n        _.each(target, sm => {\r\n            if (def) {\r\n                return false;\r\n            }\r\n            def = findTaskDefine(sm);\r\n            return true;\r\n        });\r\n    } else {\r\n        _.each(_.keys(target), key => {\r\n            if (def) {\r\n                return false;\r\n            }\r\n            if (!key || !target[key] || /^[0-9]+$/.test(key)) {\r\n                return true;\r\n            }\r\n            // console.log(chalk.grey('find task define from :'), chalk.cyan(key));\r\n            def = findTaskDefine(target[key]);\r\n            return true;\r\n        });\r\n    }\r\n\r\n    return def;\r\n}\r\n\r\n/**\r\n * find one taskdefine in module.\r\n *\r\n * @export\r\n * @param {(string | Object)} md\r\n * @returns {Promise<ITaskDefine>}\r\n */\r\nexport function findTaskDefineInModule(md: string | Object): Promise<ITaskDefine> {\r\n    let tsdef;\r\n    try {\r\n        if (_.isString(md)) {\r\n            tsdef = findTaskDefine(require(md));\r\n        } else {\r\n            tsdef = findTaskDefine(md);\r\n        }\r\n    } catch (err) {\r\n        return Promise.reject(err);\r\n    }\r\n\r\n    if (tsdef) {\r\n        return Promise.resolve(tsdef);\r\n    } else {\r\n        // console.error('can not found task config builder method in module {0}.', mdl);\r\n        // console.log(chalk.yellow('can not found task define in module.'));\r\n        return Promise.resolve(null);\r\n    }\r\n}\r\n\r\n/**\r\n * fund tasks in module.\r\n *\r\n * @export\r\n * @param {(string | Object)} md\r\n * @param {ITaskDecorator} [match]\r\n * @param {ITaskContext} [ctx]\r\n * @returns {Promise<ITask[]>}\r\n */\r\nexport function findTasksInModule(md: string | Object, match?: ITaskDecorator, ctx?: ITaskContext): Promise<ITask[]> {\r\n    let mdls;\r\n    try {\r\n        if (_.isString(md)) {\r\n            mdls = findTasks(require(md), match, ctx);\r\n        } else {\r\n            mdls = findTasks(md, match, ctx);\r\n        }\r\n    } catch (err) {\r\n        return Promise.reject(err);\r\n    }\r\n\r\n    return Promise.resolve(mdls);\r\n}\r\n\r\n\r\n/**\r\n * find one task define in directories.\r\n *\r\n * @export\r\n * @param {Src} dirs\r\n * @returns {Promise<ITaskDefine>}\r\n */\r\nexport function findTaskDefineInDir(dirs: Src): Promise<ITaskDefine> {\r\n    return Promise.race<ITaskDefine>(_.map(_.isArray(dirs) ? dirs : [dirs], dir => {\r\n        return new Promise<ITaskDefine>((resolve, reject) => {\r\n            if (existsSync(dir)) {\r\n                let mdl = requireDir(dir, { duplicates: true, camelcase: true, recurse: true });\r\n                if (mdl) {\r\n                    let def = findTaskDefine(mdl);\r\n                    if (def) {\r\n                        resolve(def);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }));\r\n}\r\n\r\n/**\r\n * find tasks in directories.\r\n *\r\n * @export\r\n * @param {Src} dirs\r\n * @param {ITaskDecorator} [match]\r\n * @param {ITaskContext} [ctx]\r\n * @returns {Promise<ITask[]>}\r\n */\r\nexport function findTasksInDir(dirs: Src, match?: ITaskDecorator, ctx?: ITaskContext): Promise<ITask[]> {\r\n    let map = new Map<any, Taskitem>();\r\n    return Promise.all(_.map(_.isArray(dirs) ? dirs : [dirs], dir => {\r\n        console.log(chalk.grey('begin load task from dir'), chalk.cyan(dir));\r\n        try {\r\n            let mdl = requireDir(dir, { duplicates: true, camelcase: true, recurse: true });\r\n            return Promise.resolve(findTaskMap(mdl, match, ctx, map));\r\n        } catch (err) {\r\n            return Promise.reject(err);\r\n        }\r\n    }))\r\n        .then(tasks => {\r\n            return _.flatten(tasks);\r\n        });\r\n}\r\n"]}