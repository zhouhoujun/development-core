{"version":3,"sources":["decorator.js","decorator.ts"],"names":["task","target","_","isFunction","_ret","tg","v","_typeof","dynamicTask","_ret2","findTasks","match","tasks","tinfo","isBoolean","utils_1","matchTaskInfo","matchTaskGroup","setInfo","push","_ret3","dyts","map","tk","extend","clone","concat","generateTask_1","generateTask","isArray","each","sm","keys","key","test","console","log","chalk","grey","cyan","taskdefine","_ret4","findTaskDefines","defs","dc","taskDefine2Context","findTaskDefine","def","findTaskDefineInModule","md","tsdef","isString","require","err","Promise","reject","resolve","yellow","findTasksInModule","mdls","findTaskDefineInDir","dirs","race","dir","fs_1","existsSync","mdl","requireDir","findTasksInDir","all","recurse","then","flatten","tdef","context","cfg","bindingConfig_1","bindingConfig","loadConfig","option","env","loadTasks","exports"],"mappings":"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","file":"../decorator.js","sourcesContent":["\"use strict\";\nrequire('reflect-metadata');\nconst _ = require('lodash');\nconst chalk = require('chalk');\nconst generateTask_1 = require('./generateTask');\nconst bindingConfig_1 = require('./bindingConfig');\nconst utils_1 = require('./utils');\nconst fs_1 = require('fs');\nconst requireDir = require('require-dir');\n/**\n * task decorator.\n *\n * @export\n * @param {ITaskDecorator} type\n * @returns\n */\nfunction task(target) {\n    if (_.isFunction(target)) {\n        target['__task'] = {};\n        return target;\n    }\n    else {\n        let tg = target;\n        return (target) => {\n            target['__task'] = tg || {};\n            return target;\n        };\n    }\n}\nexports.task = task;\n/**\n * dynamic task decorator.\n *\n * @export\n * @template T\n * @param {((new <T>() => T) | ITaskDecorator)} [target]\n * @returns {*}\n */\nfunction dynamicTask(target) {\n    if (target && _.isFunction(target)) {\n        target['__dynamictask'] = {};\n        return target;\n    }\n    else {\n        let tg = target;\n        return (target) => {\n            target['__dynamictask'] = tg || {};\n            return target;\n        };\n    }\n}\nexports.dynamicTask = dynamicTask;\n/**\n * find tasks in Object module.\n *\n * @export\n * @param {*} target\n * @param {ITaskDecorator} [match]\n * @returns {ITask[]}\n */\nfunction findTasks(target, match) {\n    let tasks = [];\n    if (!target) {\n        return tasks;\n    }\n    if (_.isFunction(target)) {\n        if (target['__task']) {\n            let tinfo = target['__task'];\n            tinfo = _.isBoolean(tinfo) ? {} : tinfo;\n            if (!utils_1.matchTaskInfo(tinfo, match)) {\n                return tasks;\n            }\n            if (!utils_1.matchTaskGroup(tinfo, match)) {\n                return tasks;\n            }\n            let task = new target(tinfo);\n            if (task.setInfo) {\n                task.setInfo(tinfo);\n            }\n            tasks.push(task);\n        }\n        else if (target['__dynamictask']) {\n            let tinfo = target['__dynamictask'];\n            if (!utils_1.matchTaskInfo(tinfo, match)) {\n                return tasks;\n            }\n            if (!utils_1.matchTaskGroup(tinfo, match)) {\n                return tasks;\n            }\n            let dyts = _.map((new target()).tasks(), tk => {\n                tk = _.extend(_.clone(tinfo), tk);\n                // tk.group = tk.group || tinfo.group;\n                return tk;\n            });\n            tasks = tasks.concat(generateTask_1.generateTask(dyts, match));\n        }\n    }\n    else if (_.isArray(target)) {\n        _.each(target, sm => {\n            tasks.concat(findTasks(sm, match));\n        });\n    }\n    else {\n        _.each(_.keys(target), key => {\n            if (!key || !target[key] || /^[0-9]+$/.test(key)) {\n                return;\n            }\n            console.log(chalk.grey('find task from :'), chalk.cyan(key));\n            tasks = tasks.concat(findTasks(target[key], match));\n        });\n    }\n    return tasks;\n}\nexports.findTasks = findTasks;\n/**\n * decorator task define implements IContextDefine.\n *\n * @export\n * @param {Function} constructor\n */\nfunction taskdefine(target) {\n    if (_.isFunction(target)) {\n        target['__task_context'] = true;\n        return target;\n    }\n    else {\n        let tg = target;\n        return (target) => {\n            target['__task_context'] = tg || true;\n            return target;\n        };\n    }\n}\nexports.taskdefine = taskdefine;\n/**\n * get all taskdefine in module.\n *\n * @export\n * @param {any} target\n * @returns\n */\nfunction findTaskDefines(target) {\n    let defs = [];\n    if (!target) {\n        return defs;\n    }\n    if (_.isFunction(target)) {\n        if (target['__task_context']) {\n            let dc = new target();\n            if (!dc['getContext']) {\n                dc = taskDefine2Context(dc);\n            }\n            defs.push(dc);\n        }\n    }\n    else if (_.isArray(target)) {\n        _.each(target, sm => {\n            defs.concat(findTaskDefines(sm));\n        });\n    }\n    else {\n        _.each(_.keys(target), key => {\n            if (!key || !target[key] || /^[0-9]+$/.test(key)) {\n                return;\n            }\n            console.log(chalk.grey('find task define from :'), chalk.cyan(key));\n            defs = defs.concat(findTaskDefines(target[key]));\n        });\n    }\n    return defs;\n}\nexports.findTaskDefines = findTaskDefines;\n/**\n * get one taskdefine in module.\n *\n * @export\n * @param {any} target\n * @returns\n */\nfunction findTaskDefine(target) {\n    let def;\n    if (!target) {\n        return null;\n    }\n    if (_.isFunction(target)) {\n        if (target['__task_context']) {\n            let dc = new target();\n            if (dc['getContext']) {\n                def = dc;\n            }\n            else {\n                def = taskDefine2Context(dc);\n            }\n        }\n    }\n    else if (_.isArray(target)) {\n        _.each(target, sm => {\n            if (def) {\n                return false;\n            }\n            def = findTaskDefine(sm);\n            return true;\n        });\n    }\n    else {\n        _.each(_.keys(target), key => {\n            if (def) {\n                return false;\n            }\n            if (!key || !target[key] || /^[0-9]+$/.test(key)) {\n                return true;\n            }\n            console.log(chalk.grey('find task define from :'), chalk.cyan(key));\n            def = findTaskDefine(target[key]);\n            return true;\n        });\n    }\n    return def;\n}\nexports.findTaskDefine = findTaskDefine;\n/**\n * find one taskdefine in module.\n *\n * @export\n * @param {(string | Object)} md\n * @returns {Promise<IContextDefine>}\n */\nfunction findTaskDefineInModule(md) {\n    let tsdef;\n    try {\n        if (_.isString(md)) {\n            tsdef = findTaskDefine(require(md));\n        }\n        else {\n            tsdef = findTaskDefine(md);\n        }\n    }\n    catch (err) {\n        return Promise.reject(err);\n    }\n    if (tsdef) {\n        return Promise.resolve(tsdef);\n    }\n    else {\n        // console.error('can not found task config builder method in module {0}.', mdl);\n        console.log(chalk.yellow('can not found task define in module.'));\n        return Promise.resolve(null);\n    }\n}\nexports.findTaskDefineInModule = findTaskDefineInModule;\n/**\n * fund tasks in module.\n *\n * @export\n * @param {(string | Object)} md\n * @param {ITaskDecorator} [match]\n * @returns {Promise<ITask[]>}\n */\nfunction findTasksInModule(md, match) {\n    let mdls;\n    try {\n        if (_.isString(md)) {\n            mdls = findTasks(require(md), match);\n        }\n        else {\n            mdls = findTasks(md, match);\n        }\n    }\n    catch (err) {\n        return Promise.reject(err);\n    }\n    return Promise.resolve(mdls);\n}\nexports.findTasksInModule = findTasksInModule;\n/**\n * find one task define in directories.\n *\n * @export\n * @param {Src} dirs\n * @returns {Promise<IContextDefine>}\n */\nfunction findTaskDefineInDir(dirs) {\n    return Promise.race(_.map(_.isArray(dirs) ? dirs : [dirs], dir => {\n        return new Promise((resolve, reject) => {\n            if (fs_1.existsSync(dir)) {\n                let mdl = requireDir(dir);\n                if (mdl) {\n                    let def = findTaskDefine(mdl);\n                    if (def) {\n                        resolve(def);\n                    }\n                }\n            }\n        });\n    }));\n}\nexports.findTaskDefineInDir = findTaskDefineInDir;\n/**\n * find tasks in directories.\n *\n * @export\n * @param {Src} dirs\n * @param {ITaskDecorator} [match]\n * @returns {Promise<ITask[]>}\n */\nfunction findTasksInDir(dirs, match) {\n    return Promise.all(_.map(_.isArray(dirs) ? dirs : [dirs], dir => {\n        console.log(chalk.grey('begin load task from dir'), chalk.cyan(dir));\n        try {\n            let mdl = requireDir(dir, { recurse: true });\n            return Promise.resolve(findTasks(mdl, match));\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }))\n        .then(tasks => {\n        return _.flatten(tasks);\n    });\n}\nexports.findTasksInDir = findTasksInDir;\n/**\n * task define context convert.\n *\n * @export\n * @param {ITaskDefine} tdef\n * @returns {IContextDefine}\n */\nfunction taskDefine2Context(tdef) {\n    let context = _.extend({}, tdef);\n    context['getContext'] = (cfg) => {\n        return bindingConfig_1.bindingConfig(tdef.loadConfig(cfg.option, cfg.env));\n    };\n    context['tasks'] = tdef.loadTasks ? (context) => tdef.loadTasks(context) : null;\n    return context;\n}\nexports.taskDefine2Context = taskDefine2Context;\n","import 'reflect-metadata';\r\nimport * as _ from 'lodash';\r\nimport * as chalk from 'chalk';\r\nimport { ITask, ITaskDecorator, ITaskConfig, IContextDefine, ITaskDefine, Src, IDynamicTasks } from './TaskConfig';\r\nimport { generateTask } from './generateTask';\r\nimport { bindingConfig } from './bindingConfig';\r\nimport { matchTaskGroup, matchTaskInfo } from './utils';\r\nimport { existsSync } from 'fs';\r\nconst requireDir = require('require-dir');\r\n\r\n\r\n/**\r\n * task decorator.\r\n * \r\n * @export\r\n * @param {ITaskDecorator} type\r\n * @returns\r\n */\r\nexport function task<T extends Function>(target?: (new <T>() => T) | ITaskDecorator): any {\r\n    if (_.isFunction(target)) {\r\n        target['__task'] = {};\r\n        return target;\r\n    } else {\r\n        let tg = target;\r\n        return (target: any) => {\r\n            target['__task'] = tg || {};\r\n            return target;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * dynamic task decorator.\r\n * \r\n * @export\r\n * @template T\r\n * @param {((new <T>() => T) | ITaskDecorator)} [target]\r\n * @returns {*}\r\n */\r\nexport function dynamicTask<T extends Function>(target?: (new <T>() => T) | ITaskDecorator): any {\r\n    if (target && _.isFunction(target)) {\r\n        target['__dynamictask'] = {};\r\n        return target;\r\n    } else {\r\n        let tg = target;\r\n        return (target: any) => {\r\n            target['__dynamictask'] = tg || {};\r\n            return target;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * find tasks in Object module.\r\n * \r\n * @export\r\n * @param {*} target\r\n * @param {ITaskDecorator} [match]\r\n * @returns {ITask[]}\r\n */\r\nexport function findTasks(target: any, match?: ITaskDecorator): ITask[] {\r\n    let tasks: ITask[] = [];\r\n    if (!target) {\r\n        return tasks;\r\n    }\r\n    if (_.isFunction(target)) {\r\n        if (target['__task']) {\r\n            let tinfo: ITaskDecorator = target['__task'];\r\n            tinfo = _.isBoolean(tinfo) ? {} : tinfo;\r\n            if (!matchTaskInfo(tinfo, match)) {\r\n                return tasks;\r\n            }\r\n\r\n            if (!matchTaskGroup(tinfo, match)) {\r\n                return tasks;\r\n            }\r\n\r\n            let task: ITask = new target(tinfo);\r\n            if (task.setInfo) {\r\n                task.setInfo(tinfo);\r\n            }\r\n\r\n            tasks.push(task);\r\n        } else if (target['__dynamictask']) {\r\n            let tinfo: ITaskDecorator = target['__dynamictask'];\r\n\r\n            if (!matchTaskInfo(tinfo, match)) {\r\n                return tasks;\r\n            }\r\n\r\n            if (!matchTaskGroup(tinfo, match)) {\r\n                return tasks;\r\n            }\r\n\r\n            let dyts = _.map((<IDynamicTasks>new target()).tasks(), tk => {\r\n                tk = _.extend(_.clone(tinfo), tk);\r\n                // tk.group = tk.group || tinfo.group;\r\n                return tk;\r\n            });\r\n            tasks = tasks.concat(generateTask(dyts, match));\r\n        }\r\n    } else if (_.isArray(target)) {\r\n        _.each(target, sm => {\r\n            tasks.concat(findTasks(sm, match));\r\n        });\r\n    } else {\r\n        _.each(_.keys(target), key => {\r\n            if (!key || !target[key] || /^[0-9]+$/.test(key)) {\r\n                return;\r\n            }\r\n            console.log(chalk.grey('find task from :'), chalk.cyan(key));\r\n            tasks = tasks.concat(findTasks(target[key], match));\r\n        });\r\n    }\r\n\r\n    return tasks;\r\n}\r\n\r\n/**\r\n * decorator task define implements IContextDefine.\r\n * \r\n * @export\r\n * @param {Function} constructor\r\n */\r\nexport function taskdefine<T extends Function>(target?: (new <T>() => T)): any {\r\n    if (_.isFunction(target)) {\r\n        target['__task_context'] = true;\r\n        return target;\r\n    } else {\r\n        let tg = target;\r\n        return (target: any) => {\r\n            target['__task_context'] = tg || true;\r\n            return target;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * get all taskdefine in module.\r\n * \r\n * @export\r\n * @param {any} target\r\n * @returns\r\n */\r\nexport function findTaskDefines(target): IContextDefine[] {\r\n    let defs: IContextDefine[] = [];\r\n    if (!target) {\r\n        return defs;\r\n    }\r\n    if (_.isFunction(target)) {\r\n        if (target['__task_context']) {\r\n            let dc = new target();\r\n            if (!dc['getContext']) {\r\n                dc = taskDefine2Context(dc);\r\n            }\r\n            defs.push(<IContextDefine>dc);\r\n        }\r\n    } else if (_.isArray(target)) {\r\n        _.each(target, sm => {\r\n            defs.concat(findTaskDefines(sm));\r\n        });\r\n    } else {\r\n        _.each(_.keys(target), key => {\r\n            if (!key || !target[key] || /^[0-9]+$/.test(key)) {\r\n                return;\r\n            }\r\n            console.log(chalk.grey('find task define from :'), chalk.cyan(key));\r\n            defs = defs.concat(findTaskDefines(target[key]));\r\n        });\r\n    }\r\n\r\n    return defs;\r\n}\r\n\r\n\r\n/**\r\n * get one taskdefine in module.\r\n * \r\n * @export\r\n * @param {any} target\r\n * @returns\r\n */\r\nexport function findTaskDefine(target): IContextDefine {\r\n    let def: IContextDefine;\r\n    if (!target) {\r\n        return null;\r\n    }\r\n    if (_.isFunction(target)) {\r\n        if (target['__task_context']) {\r\n            let dc = new target();\r\n            if (dc['getContext']) {\r\n                def = dc;\r\n            } else {\r\n                def = taskDefine2Context(dc);\r\n            }\r\n        }\r\n    } else if (_.isArray(target)) {\r\n        _.each(target, sm => {\r\n            if (def) {\r\n                return false;\r\n            }\r\n            def = findTaskDefine(sm);\r\n            return true;\r\n        });\r\n    } else {\r\n        _.each(_.keys(target), key => {\r\n            if (def) {\r\n                return false;\r\n            }\r\n            if (!key || !target[key] || /^[0-9]+$/.test(key)) {\r\n                return true;\r\n            }\r\n            console.log(chalk.grey('find task define from :'), chalk.cyan(key));\r\n            def = findTaskDefine(target[key]);\r\n            return true;\r\n        });\r\n    }\r\n\r\n    return def;\r\n}\r\n\r\n/**\r\n * find one taskdefine in module.\r\n * \r\n * @export\r\n * @param {(string | Object)} md\r\n * @returns {Promise<IContextDefine>}\r\n */\r\nexport function findTaskDefineInModule(md: string | Object): Promise<IContextDefine> {\r\n    let tsdef;\r\n    try {\r\n        if (_.isString(md)) {\r\n            tsdef = findTaskDefine(require(md));\r\n        } else {\r\n            tsdef = findTaskDefine(md);\r\n        }\r\n    } catch (err) {\r\n        return Promise.reject(err);\r\n    }\r\n\r\n    if (tsdef) {\r\n        return Promise.resolve(tsdef);\r\n    } else {\r\n        // console.error('can not found task config builder method in module {0}.', mdl);\r\n        console.log(chalk.yellow('can not found task define in module.'));\r\n        return Promise.resolve(null);\r\n    }\r\n}\r\n\r\n/**\r\n * fund tasks in module.\r\n * \r\n * @export\r\n * @param {(string | Object)} md\r\n * @param {ITaskDecorator} [match]\r\n * @returns {Promise<ITask[]>}\r\n */\r\nexport function findTasksInModule(md: string | Object, match?: ITaskDecorator): Promise<ITask[]> {\r\n    let mdls;\r\n    try {\r\n        if (_.isString(md)) {\r\n            mdls = findTasks(require(md), match);\r\n        } else {\r\n            mdls = findTasks(md, match);\r\n        }\r\n    } catch (err) {\r\n        return Promise.reject(err);\r\n    }\r\n\r\n    return Promise.resolve(mdls);\r\n}\r\n\r\n\r\n/**\r\n * find one task define in directories.\r\n * \r\n * @export\r\n * @param {Src} dirs\r\n * @returns {Promise<IContextDefine>}\r\n */\r\nexport function findTaskDefineInDir(dirs: Src): Promise<IContextDefine> {\r\n    return Promise.race<IContextDefine>(_.map(_.isArray(dirs) ? dirs : [dirs], dir => {\r\n        return new Promise<IContextDefine>((resolve, reject) => {\r\n            if (existsSync(dir)) {\r\n                let mdl = requireDir(dir);\r\n                if (mdl) {\r\n                    let def = findTaskDefine(mdl);\r\n                    if (def) {\r\n                        resolve(def);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }));\r\n}\r\n\r\n/**\r\n * find tasks in directories.\r\n * \r\n * @export\r\n * @param {Src} dirs\r\n * @param {ITaskDecorator} [match]\r\n * @returns {Promise<ITask[]>}\r\n */\r\nexport function findTasksInDir(dirs: Src, match?: ITaskDecorator): Promise<ITask[]> {\r\n    return Promise.all(_.map(_.isArray(dirs) ? dirs : [dirs], dir => {\r\n        console.log(chalk.grey('begin load task from dir'), chalk.cyan(dir));\r\n        try {\r\n            let mdl = requireDir(dir, { recurse: true });\r\n            return Promise.resolve(findTasks(mdl, match));\r\n        } catch (err) {\r\n            return Promise.reject(err);\r\n        }\r\n    }))\r\n        .then(tasks => {\r\n            return _.flatten(tasks);\r\n        });\r\n}\r\n\r\n/**\r\n * task define context convert.\r\n * \r\n * @export\r\n * @param {ITaskDefine} tdef\r\n * @returns {IContextDefine}\r\n */\r\nexport function taskDefine2Context(tdef: ITaskDefine): IContextDefine {\r\n    let context: any = _.extend({}, tdef);\r\n    context['getContext'] = (cfg: ITaskConfig) => {\r\n        return bindingConfig(tdef.loadConfig(cfg.option, cfg.env));\r\n    };\r\n\r\n    context['tasks'] = tdef.loadTasks ? (context) => tdef.loadTasks(context) : null;\r\n\r\n    return <IContextDefine>context;\r\n}\r\n"]}