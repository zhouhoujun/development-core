{"version":3,"sources":["decorator.js","decorator.ts"],"names":["require","_","chalk","generateTask_1","bindingConfig_1","utils_1","fs_1","requireDir","task","target","isFunction","tg","exports","dynamicTask","findTaskset","tasks","match","ctx","tinfo","isBoolean","matchCompare","has","setInfo","set","dyts","map","tk","extend","clone","generateTask","isArray","each","sm","keys","key","test","console","log","grey","cyan","findTaskMap","Map","forEach","it","concat","push","findTasks","taskdefine","findTaskDefines","defs","dc","taskDefine2Context","findTaskDefine","def","findTaskDefineInModule","md","tsdef","isString","err","Promise","reject","resolve","yellow","findTasksInModule","mdls","findTaskDefineInDir","dirs","race","existsSync","dir","mdl","duplicates","camelcase","recurse","findTasksInDir","all","then","flatten","tdef","context","cfg","bindingConfig","loadConfig","option","env","loadTasks"],"mappings":"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","file":"../decorator.js","sourcesContent":["\"use strict\";\nrequire('reflect-metadata');\nconst _ = require('lodash');\nconst chalk = require('chalk');\nconst generateTask_1 = require('./generateTask');\nconst bindingConfig_1 = require('./bindingConfig');\nconst utils_1 = require('./utils');\nconst fs_1 = require('fs');\nconst requireDir = require('require-dir');\n/**\n * task decorator.\n *\n * @export\n * @param {ITaskDecorator} type\n * @returns\n */\nfunction task(target) {\n    if (_.isFunction(target)) {\n        target['__task'] = {};\n        return target;\n    }\n    else {\n        let tg = target;\n        return (target) => {\n            target['__task'] = tg || {};\n            return target;\n        };\n    }\n}\nexports.task = task;\n/**\n * dynamic task decorator.\n *\n * @export\n * @template T\n * @param {((new <T>() => T) | ITaskDecorator)} [target]\n * @returns {*}\n */\nfunction dynamicTask(target) {\n    if (target && _.isFunction(target)) {\n        target['__dynamictask'] = {};\n        return target;\n    }\n    else {\n        let tg = target;\n        return (target) => {\n            target['__dynamictask'] = tg || {};\n            return target;\n        };\n    }\n}\nexports.dynamicTask = dynamicTask;\nfunction findTaskset(tasks, target, match, ctx) {\n    if (!target) {\n        return;\n    }\n    if (_.isFunction(target)) {\n        if (target['__task']) {\n            let tinfo = target['__task'];\n            tinfo = _.isBoolean(tinfo) ? {} : tinfo;\n            if (!utils_1.matchCompare(tinfo, match, ctx)) {\n                return;\n            }\n            if (tasks.has(target)) {\n                return;\n            }\n            let task = new target(tinfo);\n            if (task.setInfo) {\n                task.setInfo(tinfo);\n            }\n            tasks.set(target, task);\n        }\n        else if (target['__dynamictask']) {\n            let tinfo = target['__dynamictask'];\n            if (!utils_1.matchCompare(tinfo, match, ctx)) {\n                return;\n            }\n            if (tasks.has(target)) {\n                return;\n            }\n            let dyts = _.map((new target()).tasks(), tk => {\n                tk = _.extend(_.clone(tinfo), tk);\n                // tk.group = tk.group || tinfo.group;\n                return tk;\n            });\n            tasks.set(target, generateTask_1.generateTask(dyts, match, ctx));\n        }\n    }\n    else if (_.isArray(target)) {\n        _.each(target, sm => {\n            findTaskset(tasks, sm, match, ctx);\n        });\n    }\n    else {\n        _.each(_.keys(target), key => {\n            if (!key || !target[key] || /^[0-9]+$/.test(key)) {\n                return;\n            }\n            console.log(chalk.grey('find task from :'), chalk.cyan(key));\n            findTaskset(tasks, target[key], match, ctx);\n        });\n    }\n}\nfunction findTaskMap(target, match, ctx, map) {\n    map = map || new Map();\n    findTaskset(map, target, match, ctx);\n    let tasks = [];\n    map.forEach((it) => {\n        if (_.isArray(it)) {\n            tasks = tasks.concat(it);\n        }\n        else {\n            tasks.push(it);\n        }\n    });\n    return tasks;\n}\n/**\n * find tasks in Object module.\n *\n * @export\n * @param {*} target\n * @param {ITaskDecorator} [match]\n * @param {ITaskContext} [ctx]\n * @returns {ITask[]}\n */\nfunction findTasks(target, match, ctx) {\n    return findTaskMap(target, match, ctx);\n}\nexports.findTasks = findTasks;\n/**\n * decorator task define implements IContextDefine.\n *\n * @export\n * @param {Function} constructor\n */\nfunction taskdefine(target) {\n    if (_.isFunction(target)) {\n        target['__task_context'] = true;\n        return target;\n    }\n    else {\n        let tg = target;\n        return (target) => {\n            target['__task_context'] = tg || true;\n            return target;\n        };\n    }\n}\nexports.taskdefine = taskdefine;\n/**\n * get all taskdefine in module.\n *\n * @export\n * @param {any} target\n * @returns\n */\nfunction findTaskDefines(target) {\n    let defs = [];\n    if (!target) {\n        return defs;\n    }\n    if (_.isFunction(target)) {\n        if (target['__task_context']) {\n            let dc = new target();\n            if (!dc['getContext']) {\n                dc = taskDefine2Context(dc);\n            }\n            defs.push(dc);\n        }\n    }\n    else if (_.isArray(target)) {\n        _.each(target, sm => {\n            defs.concat(findTaskDefines(sm));\n        });\n    }\n    else {\n        _.each(_.keys(target), key => {\n            if (!key || !target[key] || /^[0-9]+$/.test(key)) {\n                return;\n            }\n            console.log(chalk.grey('find task define from :'), chalk.cyan(key));\n            defs = defs.concat(findTaskDefines(target[key]));\n        });\n    }\n    return defs;\n}\nexports.findTaskDefines = findTaskDefines;\n/**\n * get one taskdefine in module.\n *\n * @export\n * @param {any} target\n * @returns\n */\nfunction findTaskDefine(target) {\n    let def;\n    if (!target) {\n        return null;\n    }\n    if (_.isFunction(target)) {\n        if (target['__task_context']) {\n            let dc = new target();\n            if (dc['getContext']) {\n                def = dc;\n            }\n            else {\n                def = taskDefine2Context(dc);\n            }\n        }\n    }\n    else if (_.isArray(target)) {\n        _.each(target, sm => {\n            if (def) {\n                return false;\n            }\n            def = findTaskDefine(sm);\n            return true;\n        });\n    }\n    else {\n        _.each(_.keys(target), key => {\n            if (def) {\n                return false;\n            }\n            if (!key || !target[key] || /^[0-9]+$/.test(key)) {\n                return true;\n            }\n            console.log(chalk.grey('find task define from :'), chalk.cyan(key));\n            def = findTaskDefine(target[key]);\n            return true;\n        });\n    }\n    return def;\n}\nexports.findTaskDefine = findTaskDefine;\n/**\n * find one taskdefine in module.\n *\n * @export\n * @param {(string | Object)} md\n * @returns {Promise<IContextDefine>}\n */\nfunction findTaskDefineInModule(md) {\n    let tsdef;\n    try {\n        if (_.isString(md)) {\n            tsdef = findTaskDefine(require(md));\n        }\n        else {\n            tsdef = findTaskDefine(md);\n        }\n    }\n    catch (err) {\n        return Promise.reject(err);\n    }\n    if (tsdef) {\n        return Promise.resolve(tsdef);\n    }\n    else {\n        // console.error('can not found task config builder method in module {0}.', mdl);\n        console.log(chalk.yellow('can not found task define in module.'));\n        return Promise.resolve(null);\n    }\n}\nexports.findTaskDefineInModule = findTaskDefineInModule;\n/**\n * fund tasks in module.\n *\n * @export\n * @param {(string | Object)} md\n * @param {ITaskDecorator} [match]\n * @param {ITaskContext} [ctx]\n * @returns {Promise<ITask[]>}\n */\nfunction findTasksInModule(md, match, ctx) {\n    let mdls;\n    try {\n        if (_.isString(md)) {\n            mdls = findTasks(require(md), match, ctx);\n        }\n        else {\n            mdls = findTasks(md, match, ctx);\n        }\n    }\n    catch (err) {\n        return Promise.reject(err);\n    }\n    return Promise.resolve(mdls);\n}\nexports.findTasksInModule = findTasksInModule;\n/**\n * find one task define in directories.\n *\n * @export\n * @param {Src} dirs\n * @returns {Promise<IContextDefine>}\n */\nfunction findTaskDefineInDir(dirs) {\n    return Promise.race(_.map(_.isArray(dirs) ? dirs : [dirs], dir => {\n        return new Promise((resolve, reject) => {\n            if (fs_1.existsSync(dir)) {\n                let mdl = requireDir(dir, { duplicates: true, camelcase: true, recurse: true });\n                if (mdl) {\n                    let def = findTaskDefine(mdl);\n                    if (def) {\n                        resolve(def);\n                    }\n                }\n            }\n        });\n    }));\n}\nexports.findTaskDefineInDir = findTaskDefineInDir;\n/**\n * find tasks in directories.\n *\n * @export\n * @param {Src} dirs\n * @param {ITaskDecorator} [match]\n * @param {ITaskContext} [ctx]\n * @returns {Promise<ITask[]>}\n */\nfunction findTasksInDir(dirs, match, ctx) {\n    let map = new Map();\n    return Promise.all(_.map(_.isArray(dirs) ? dirs : [dirs], dir => {\n        console.log(chalk.grey('begin load task from dir'), chalk.cyan(dir));\n        try {\n            let mdl = requireDir(dir, { duplicates: true, camelcase: true, recurse: true });\n            return Promise.resolve(findTaskMap(mdl, match, ctx, map));\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }))\n        .then(tasks => {\n        return _.flatten(tasks);\n    });\n}\nexports.findTasksInDir = findTasksInDir;\n/**\n * task define context convert.\n *\n * @export\n * @param {ITaskDefine} tdef\n * @returns {IContextDefine}\n */\nfunction taskDefine2Context(tdef) {\n    let context = _.extend({}, tdef);\n    context['getContext'] = (cfg) => {\n        return bindingConfig_1.bindingConfig(tdef.loadConfig(cfg.option, cfg.env));\n    };\n    context['tasks'] = tdef.loadTasks ? (context) => tdef.loadTasks(context) : null;\n    return context;\n}\nexports.taskDefine2Context = taskDefine2Context;\n","import 'reflect-metadata';\r\nimport * as _ from 'lodash';\r\nimport * as chalk from 'chalk';\r\nimport { ITask, ITaskDecorator, ITaskContext, ITaskConfig, IContextDefine, ITaskDefine, Src, IDynamicTasks } from './TaskConfig';\r\nimport { generateTask } from './generateTask';\r\nimport { bindingConfig } from './bindingConfig';\r\nimport { matchCompare } from './utils';\r\nimport { existsSync } from 'fs';\r\nconst requireDir = require('require-dir');\r\n\r\n\r\n/**\r\n * task decorator.\r\n * \r\n * @export\r\n * @param {ITaskDecorator} type\r\n * @returns\r\n */\r\nexport function task<T extends Function>(target?: (new <T>() => T) | ITaskDecorator): any {\r\n    if (_.isFunction(target)) {\r\n        target['__task'] = {};\r\n        return target;\r\n    } else {\r\n        let tg = target;\r\n        return (target: any) => {\r\n            target['__task'] = tg || {};\r\n            return target;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * dynamic task decorator.\r\n * \r\n * @export\r\n * @template T\r\n * @param {((new <T>() => T) | ITaskDecorator)} [target]\r\n * @returns {*}\r\n */\r\nexport function dynamicTask<T extends Function>(target?: (new <T>() => T) | ITaskDecorator): any {\r\n    if (target && _.isFunction(target)) {\r\n        target['__dynamictask'] = {};\r\n        return target;\r\n    } else {\r\n        let tg = target;\r\n        return (target: any) => {\r\n            target['__dynamictask'] = tg || {};\r\n            return target;\r\n        }\r\n    }\r\n}\r\n\r\n\r\ntype Taskitem = ITask | ITask[];\r\n\r\nfunction findTaskset(tasks: Map<any, Taskitem>, target: any, match?: ITaskDecorator, ctx?: ITaskContext) {\r\n\r\n    if (!target) {\r\n        return;\r\n    }\r\n    if (_.isFunction(target)) {\r\n        if (target['__task']) {\r\n            let tinfo: ITaskDecorator = target['__task'];\r\n            tinfo = _.isBoolean(tinfo) ? {} : tinfo;\r\n\r\n            if (!matchCompare(tinfo, match, ctx)) {\r\n                return;\r\n            }\r\n            if (tasks.has(target)) {\r\n                return;\r\n            }\r\n\r\n            let task: ITask = new target(tinfo);\r\n            if (task.setInfo) {\r\n                task.setInfo(tinfo);\r\n            }\r\n\r\n            tasks.set(target, task);\r\n\r\n        } else if (target['__dynamictask']) {\r\n            let tinfo: ITaskDecorator = target['__dynamictask'];\r\n\r\n            if (!matchCompare(tinfo, match, ctx)) {\r\n                return;\r\n            }\r\n\r\n            if (tasks.has(target)) {\r\n                return;\r\n            }\r\n\r\n            let dyts = _.map((<IDynamicTasks>new target()).tasks(), tk => {\r\n                tk = _.extend(_.clone(tinfo), tk);\r\n                // tk.group = tk.group || tinfo.group;\r\n                return tk;\r\n            });\r\n            tasks.set(target, generateTask(dyts, match, ctx));\r\n        }\r\n    } else if (_.isArray(target)) {\r\n        _.each(target, sm => {\r\n            findTaskset(tasks, sm, match, ctx);\r\n        });\r\n    } else {\r\n        _.each(_.keys(target), key => {\r\n            if (!key || !target[key] || /^[0-9]+$/.test(key)) {\r\n                return;\r\n            }\r\n            console.log(chalk.grey('find task from :'), chalk.cyan(key));\r\n            findTaskset(tasks, target[key], match, ctx);\r\n        });\r\n    }\r\n}\r\n\r\n\r\nfunction findTaskMap(target: any, match?: ITaskDecorator, ctx?: ITaskContext, map?: Map<any, Taskitem>): ITask[] {\r\n    map = map || new Map<any, Taskitem>();\r\n    findTaskset(map, target, match, ctx);\r\n    let tasks: ITask[] = [];\r\n    map.forEach((it: Taskitem) => {\r\n        if (_.isArray(it)) {\r\n            tasks = tasks.concat(it);\r\n        } else {\r\n            tasks.push(it);\r\n        }\r\n    });\r\n    return tasks;\r\n}\r\n/**\r\n * find tasks in Object module.\r\n * \r\n * @export\r\n * @param {*} target\r\n * @param {ITaskDecorator} [match]\r\n * @param {ITaskContext} [ctx]\r\n * @returns {ITask[]}\r\n */\r\nexport function findTasks(target: any, match?: ITaskDecorator, ctx?: ITaskContext): ITask[] {\r\n    return findTaskMap(target, match, ctx);\r\n}\r\n\r\n/**\r\n * decorator task define implements IContextDefine.\r\n * \r\n * @export\r\n * @param {Function} constructor\r\n */\r\nexport function taskdefine<T extends Function>(target?: (new <T>() => T)): any {\r\n    if (_.isFunction(target)) {\r\n        target['__task_context'] = true;\r\n        return target;\r\n    } else {\r\n        let tg = target;\r\n        return (target: any) => {\r\n            target['__task_context'] = tg || true;\r\n            return target;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * get all taskdefine in module.\r\n * \r\n * @export\r\n * @param {any} target\r\n * @returns\r\n */\r\nexport function findTaskDefines(target): IContextDefine[] {\r\n    let defs: IContextDefine[] = [];\r\n    if (!target) {\r\n        return defs;\r\n    }\r\n    if (_.isFunction(target)) {\r\n        if (target['__task_context']) {\r\n            let dc = new target();\r\n            if (!dc['getContext']) {\r\n                dc = taskDefine2Context(dc);\r\n            }\r\n            defs.push(<IContextDefine>dc);\r\n        }\r\n    } else if (_.isArray(target)) {\r\n        _.each(target, sm => {\r\n            defs.concat(findTaskDefines(sm));\r\n        });\r\n    } else {\r\n        _.each(_.keys(target), key => {\r\n            if (!key || !target[key] || /^[0-9]+$/.test(key)) {\r\n                return;\r\n            }\r\n            console.log(chalk.grey('find task define from :'), chalk.cyan(key));\r\n            defs = defs.concat(findTaskDefines(target[key]));\r\n        });\r\n    }\r\n\r\n    return defs;\r\n}\r\n\r\n\r\n/**\r\n * get one taskdefine in module.\r\n * \r\n * @export\r\n * @param {any} target\r\n * @returns\r\n */\r\nexport function findTaskDefine(target): IContextDefine {\r\n    let def: IContextDefine;\r\n    if (!target) {\r\n        return null;\r\n    }\r\n    if (_.isFunction(target)) {\r\n        if (target['__task_context']) {\r\n            let dc = new target();\r\n            if (dc['getContext']) {\r\n                def = dc;\r\n            } else {\r\n                def = taskDefine2Context(dc);\r\n            }\r\n        }\r\n    } else if (_.isArray(target)) {\r\n        _.each(target, sm => {\r\n            if (def) {\r\n                return false;\r\n            }\r\n            def = findTaskDefine(sm);\r\n            return true;\r\n        });\r\n    } else {\r\n        _.each(_.keys(target), key => {\r\n            if (def) {\r\n                return false;\r\n            }\r\n            if (!key || !target[key] || /^[0-9]+$/.test(key)) {\r\n                return true;\r\n            }\r\n            console.log(chalk.grey('find task define from :'), chalk.cyan(key));\r\n            def = findTaskDefine(target[key]);\r\n            return true;\r\n        });\r\n    }\r\n\r\n    return def;\r\n}\r\n\r\n/**\r\n * find one taskdefine in module.\r\n * \r\n * @export\r\n * @param {(string | Object)} md\r\n * @returns {Promise<IContextDefine>}\r\n */\r\nexport function findTaskDefineInModule(md: string | Object): Promise<IContextDefine> {\r\n    let tsdef;\r\n    try {\r\n        if (_.isString(md)) {\r\n            tsdef = findTaskDefine(require(md));\r\n        } else {\r\n            tsdef = findTaskDefine(md);\r\n        }\r\n    } catch (err) {\r\n        return Promise.reject(err);\r\n    }\r\n\r\n    if (tsdef) {\r\n        return Promise.resolve(tsdef);\r\n    } else {\r\n        // console.error('can not found task config builder method in module {0}.', mdl);\r\n        console.log(chalk.yellow('can not found task define in module.'));\r\n        return Promise.resolve(null);\r\n    }\r\n}\r\n\r\n/**\r\n * fund tasks in module.\r\n * \r\n * @export\r\n * @param {(string | Object)} md\r\n * @param {ITaskDecorator} [match]\r\n * @param {ITaskContext} [ctx]\r\n * @returns {Promise<ITask[]>}\r\n */\r\nexport function findTasksInModule(md: string | Object, match?: ITaskDecorator, ctx?: ITaskContext): Promise<ITask[]> {\r\n    let mdls;\r\n    try {\r\n        if (_.isString(md)) {\r\n            mdls = findTasks(require(md), match, ctx);\r\n        } else {\r\n            mdls = findTasks(md, match, ctx);\r\n        }\r\n    } catch (err) {\r\n        return Promise.reject(err);\r\n    }\r\n\r\n    return Promise.resolve(mdls);\r\n}\r\n\r\n\r\n/**\r\n * find one task define in directories.\r\n * \r\n * @export\r\n * @param {Src} dirs\r\n * @returns {Promise<IContextDefine>}\r\n */\r\nexport function findTaskDefineInDir(dirs: Src): Promise<IContextDefine> {\r\n    return Promise.race<IContextDefine>(_.map(_.isArray(dirs) ? dirs : [dirs], dir => {\r\n        return new Promise<IContextDefine>((resolve, reject) => {\r\n            if (existsSync(dir)) {\r\n                let mdl = requireDir(dir, { duplicates: true, camelcase: true, recurse: true });\r\n                if (mdl) {\r\n                    let def = findTaskDefine(mdl);\r\n                    if (def) {\r\n                        resolve(def);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }));\r\n}\r\n\r\n/**\r\n * find tasks in directories.\r\n * \r\n * @export\r\n * @param {Src} dirs\r\n * @param {ITaskDecorator} [match]\r\n * @param {ITaskContext} [ctx]\r\n * @returns {Promise<ITask[]>}\r\n */\r\nexport function findTasksInDir(dirs: Src, match?: ITaskDecorator, ctx?: ITaskContext): Promise<ITask[]> {\r\n    let map = new Map<any, Taskitem>();\r\n    return Promise.all(_.map(_.isArray(dirs) ? dirs : [dirs], dir => {\r\n        console.log(chalk.grey('begin load task from dir'), chalk.cyan(dir));\r\n        try {\r\n            let mdl = requireDir(dir, { duplicates: true, camelcase: true, recurse: true });\r\n            return Promise.resolve(findTaskMap(mdl, match, ctx, map));\r\n        } catch (err) {\r\n            return Promise.reject(err);\r\n        }\r\n    }))\r\n        .then(tasks => {\r\n            return _.flatten(tasks);\r\n        });\r\n}\r\n\r\n/**\r\n * task define context convert.\r\n * \r\n * @export\r\n * @param {ITaskDefine} tdef\r\n * @returns {IContextDefine}\r\n */\r\nexport function taskDefine2Context(tdef: ITaskDefine): IContextDefine {\r\n    let context: any = _.extend({}, tdef);\r\n    context['getContext'] = (cfg: ITaskConfig) => {\r\n        return bindingConfig(tdef.loadConfig(cfg.option, cfg.env));\r\n    };\r\n\r\n    context['tasks'] = tdef.loadTasks ? (context) => tdef.loadTasks(context) : null;\r\n\r\n    return <IContextDefine>context;\r\n}\r\n"]}