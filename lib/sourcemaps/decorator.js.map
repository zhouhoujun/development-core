{"version":3,"sources":["decorator.js","decorator.ts"],"names":["task","option","target","findTasks","tasks","_","isFunction","decorator","push","isArray","each","sm","concat","keys","key","console","log","chalk","grey","cyan","taskdefine","findTaskDefine","defs","require","exports"],"mappings":"AAAA,YCcA,SAAAA,MAAqBC,GACjB,MAAO,UAACC,GAEJ,MADAA,GAAA,OAAmBD,MACZC,GAIf,QAAAC,WAA0BD,GACtB,GAAIE,KACJ,KAAKF,EACD,MAAOE,EAEX,IAAIC,EAAEC,WAAWJ,IACb,GAAIA,EAAA,OAAkB,CAClB,GAAIF,GAAc,GAAIE,EACtBF,GAAKO,UAAuBL,EAAA,OAC5BE,EAAMI,KAAKR,QAERK,GAAEI,QAAQP,GACjBG,EAAEK,KAAKR,EAAQ,SAAAS,GACXP,EAAMQ,OAAOT,UAAUQ,MAG3BN,EAAEK,KAAKL,EAAEQ,KAAKX,GAAS,SAAAY,GACfZ,EAAOY,KACPC,QAAQC,IAAIC,MAAMC,KAAK,oBAAqBD,MAAME,KAAKL,IACvDV,EAAQA,EAAMQ,OAAOT,UAAUD,EAAOY,OAKlD,OAAOV,GASX,QAAAgB,cACI,MAAO,UAAClB,GAEJ,MADAA,GAAA,cAAyB,EAClBA,GAWf,QAAAmB,gBAA+BnB,GAC3B,GAAIoB,KACJ,OAAKpB,IAGDG,EAAEC,WAAWJ,GACTA,EAAA,cACAoB,EAAKd,KAAkB,GAAIN,IAExBG,EAAEI,QAAQP,GACjBG,EAAEK,KAAKR,EAAQ,SAAAS,GACXW,EAAKV,OAAOS,eAAeV,MAG/BN,EAAEK,KAAKL,EAAEQ,KAAKX,GAAS,SAAAY,GACnBC,QAAQC,IAAIC,MAAMC,KAAK,2BAA4BD,MAAME,KAAKL,IAC1DZ,EAAOY,KACPQ,EAAOA,EAAKV,OAAOS,eAAenB,EAAOY,QAK9CQ,GAnBIA,EAvEfC,QAAO,mBACP,IAAYlB,GAACkB,QAAM,UACPN,MAAKM,QAAM,QAYPC,SAAAxB,KAAIA,KAOJwB,QAAArB,UAASA,UAiCTqB,QAAAJ,WAAUA,WAcVI,QAAAH,eAAcA","file":"../decorator.js","sourcesContent":["\"use strict\";\nrequire('reflect-metadata');\nconst _ = require('lodash');\nconst chalk = require('chalk');\nfunction task(option) {\n    return (target) => {\n        target['__task'] = option || {};\n        return target;\n    };\n}\nexports.task = task;\nfunction findTasks(target) {\n    let tasks = [];\n    if (!target) {\n        return tasks;\n    }\n    if (_.isFunction(target)) {\n        if (target['__task']) {\n            let task = new target();\n            task.decorator = target['__task'];\n            tasks.push(task);\n        }\n    }\n    else if (_.isArray(target)) {\n        _.each(target, sm => {\n            tasks.concat(findTasks(sm));\n        });\n    }\n    else {\n        _.each(_.keys(target), key => {\n            if (target[key]) {\n                console.log(chalk.grey('find task from :'), chalk.cyan(key));\n                tasks = tasks.concat(findTasks(target[key]));\n            }\n        });\n    }\n    return tasks;\n}\nexports.findTasks = findTasks;\nfunction taskdefine() {\n    return (target) => {\n        target['__taskdefine'] = true;\n        return target;\n    };\n}\nexports.taskdefine = taskdefine;\nfunction findTaskDefine(target) {\n    let defs = [];\n    if (!target) {\n        return defs;\n    }\n    if (_.isFunction(target)) {\n        if (target['__taskdefine']) {\n            defs.push(new target());\n        }\n    }\n    else if (_.isArray(target)) {\n        _.each(target, sm => {\n            defs.concat(findTaskDefine(sm));\n        });\n    }\n    else {\n        _.each(_.keys(target), key => {\n            console.log(chalk.grey('find task define from :'), chalk.cyan(key));\n            if (target[key]) {\n                defs = defs.concat(findTaskDefine(target[key]));\n            }\n        });\n    }\n    return defs;\n}\nexports.findTaskDefine = findTaskDefine;\n","import 'reflect-metadata';\r\nimport * as _ from 'lodash';\r\nimport * as chalk from 'chalk';\r\nimport { ITask, ITaskInfo, ITaskDefine } from './TaskConfig';\r\n\r\n\r\n\r\n/**\r\n * task decorator.\r\n * \r\n * @export\r\n * @param {ITaskInfo} type\r\n * @returns\r\n */\r\nexport function task(option?: ITaskInfo) {\r\n    return (target: any) => {\r\n        target['__task'] = option || {};\r\n        return target;\r\n    }\r\n}\r\n\r\nexport function findTasks(target: any): ITask[] {\r\n    let tasks: ITask[] = [];\r\n    if (!target) {\r\n        return tasks;\r\n    }\r\n    if (_.isFunction(target)) {\r\n        if (target['__task']) {\r\n            let task: ITask = new target();\r\n            task.decorator = <ITaskInfo>target['__task'];\r\n            tasks.push(task);\r\n        }\r\n    } else if (_.isArray(target)) {\r\n        _.each(target, sm => {\r\n            tasks.concat(findTasks(sm));\r\n        });\r\n    } else {\r\n        _.each(_.keys(target), key => {\r\n            if (target[key]) {\r\n                console.log(chalk.grey('find task from :'), chalk.cyan(key));\r\n                tasks = tasks.concat(findTasks(target[key]));\r\n            }\r\n        });\r\n    }\r\n\r\n    return tasks;\r\n}\r\n\r\n/**\r\n * decorator task define implements ITaskDefine.\r\n * \r\n * @export\r\n * @param {Function} constructor\r\n */\r\nexport function taskdefine() {\r\n    return (target: any) => {\r\n        target['__taskdefine'] = true;\r\n        return target;\r\n    }\r\n}\r\n\r\n/**\r\n * get taskdefine in module.\r\n * \r\n * @export\r\n * @param {any} target\r\n * @returns\r\n */\r\nexport function findTaskDefine(target): ITaskDefine[] {\r\n    let defs: ITaskDefine[] = [];\r\n    if (!target) {\r\n        return defs;\r\n    }\r\n    if (_.isFunction(target)) {\r\n        if (target['__taskdefine']) {\r\n            defs.push(<ITaskDefine>new target());\r\n        }\r\n    } else if (_.isArray(target)) {\r\n        _.each(target, sm => {\r\n            defs.concat(findTaskDefine(sm));\r\n        });\r\n    } else {\r\n        _.each(_.keys(target), key => {\r\n            console.log(chalk.grey('find task define from :'), chalk.cyan(key));\r\n            if (target[key]) {\r\n                defs = defs.concat(findTaskDefine(target[key]));\r\n            }\r\n        });\r\n    }\r\n\r\n    return defs;\r\n}\r\n"]}