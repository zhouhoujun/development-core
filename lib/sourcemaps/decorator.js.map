{"version":3,"sources":["decorator.ts"],"names":["task","target","_","isFunction","tg_1","dynamicTask","tg_2","findTaskset","tasks","match","ctx","tinfo","isBoolean","utils_1","matchCompare","has","task_1","setInfo","set","tinfo_1","dyts","map","tk","extend","clone","generateTask_1","generateTask","isArray","each","sm","keys","key","test","findTaskMap","Map","forEach","it","concat","push","findTasks","taskdefine","tg_3","findTaskDefines","defs","dc","taskDefine2Context","findTaskDefine","def","findTaskDefineInModule","md","tsdef","isString","require","err","Promise","reject","resolve","findTasksInModule","mdls","findTaskDefineInDir","dirs","race","dir","fs_1","existsSync","mdl","requireDir","duplicates","camelcase","recurse","findTasksInDir","all","console","log","chalk","grey","cyan","then","flatten","tdef","context","cfg","bindingConfig_1","bindingConfig","loadConfig","option","env","loadTasks","exports"],"mappings":"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","file":"../decorator.js","sourcesContent":["import 'reflect-metadata';\r\nimport * as _ from 'lodash';\r\nimport * as chalk from 'chalk';\r\nimport { ITask, ITaskDecorator, ITaskContext, ITaskConfig, IContextDefine, ITaskDefine, Src, IDynamicTasks } from './TaskConfig';\r\nimport { generateTask } from './generateTask';\r\nimport { bindingConfig } from './bindingConfig';\r\nimport { matchCompare } from './utils';\r\nimport { existsSync } from 'fs';\r\nconst requireDir = require('require-dir');\r\n\r\n\r\n/**\r\n * task decorator.\r\n *\r\n * @export\r\n * @param {ITaskDecorator} type\r\n * @returns\r\n */\r\nexport function task<T extends Function>(target?: (new <T>() => T) | ITaskDecorator): any {\r\n    if (_.isFunction(target)) {\r\n        target['__task'] = {};\r\n        return target;\r\n    } else {\r\n        let tg = target;\r\n        return (target: any) => {\r\n            target['__task'] = tg || {};\r\n            return target;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * dynamic task decorator.\r\n *\r\n * @export\r\n * @template T\r\n * @param {((new <T>() => T) | ITaskDecorator)} [target]\r\n * @returns {*}\r\n */\r\nexport function dynamicTask<T extends Function>(target?: (new <T>() => T) | ITaskDecorator): any {\r\n    if (target && _.isFunction(target)) {\r\n        target['__dynamictask'] = {};\r\n        return target;\r\n    } else {\r\n        let tg = target;\r\n        return (target: any) => {\r\n            target['__dynamictask'] = tg || {};\r\n            return target;\r\n        }\r\n    }\r\n}\r\n\r\n\r\ntype Taskitem = ITask | ITask[];\r\n\r\nfunction findTaskset(tasks: Map<any, Taskitem>, target: any, match?: ITaskDecorator, ctx?: ITaskContext) {\r\n\r\n    if (!target) {\r\n        return;\r\n    }\r\n    if (_.isFunction(target)) {\r\n        if (target['__task']) {\r\n            let tinfo: ITaskDecorator = target['__task'];\r\n            tinfo = _.isBoolean(tinfo) ? {} : tinfo;\r\n\r\n            if (!matchCompare(tinfo, match, ctx)) {\r\n                return;\r\n            }\r\n            if (tasks.has(target)) {\r\n                return;\r\n            }\r\n\r\n            let task: ITask = new target(tinfo);\r\n            if (task.setInfo) {\r\n                task.setInfo(tinfo);\r\n            }\r\n\r\n            tasks.set(target, task);\r\n\r\n        } else if (target['__dynamictask']) {\r\n            let tinfo: ITaskDecorator = target['__dynamictask'];\r\n\r\n            if (!matchCompare(tinfo, match, ctx)) {\r\n                return;\r\n            }\r\n\r\n            if (tasks.has(target)) {\r\n                return;\r\n            }\r\n\r\n            let dyts = _.map((<IDynamicTasks>new target()).tasks(), tk => {\r\n                tk = _.extend(_.clone(tinfo), tk);\r\n                // tk.group = tk.group || tinfo.group;\r\n                return tk;\r\n            });\r\n            tasks.set(target, generateTask(dyts, match, ctx));\r\n        }\r\n    } else if (_.isArray(target)) {\r\n        _.each(target, sm => {\r\n            findTaskset(tasks, sm, match, ctx);\r\n        });\r\n    } else {\r\n        _.each(_.keys(target), key => {\r\n            if (!key || !target[key] || /^[0-9]+$/.test(key)) {\r\n                return;\r\n            }\r\n            // console.log(chalk.grey('find task from :'), chalk.cyan(key));\r\n            findTaskset(tasks, target[key], match, ctx);\r\n        });\r\n    }\r\n}\r\n\r\n\r\nfunction findTaskMap(target: any, match?: ITaskDecorator, ctx?: ITaskContext, map?: Map<any, Taskitem>): ITask[] {\r\n    map = map || new Map<any, Taskitem>();\r\n    findTaskset(map, target, match, ctx);\r\n    let tasks: ITask[] = [];\r\n    map.forEach((it: Taskitem) => {\r\n        if (_.isArray(it)) {\r\n            tasks = tasks.concat(it);\r\n        } else {\r\n            tasks.push(it);\r\n        }\r\n    });\r\n    return tasks;\r\n}\r\n/**\r\n * find tasks in Object module.\r\n *\r\n * @export\r\n * @param {*} target\r\n * @param {ITaskDecorator} [match]\r\n * @param {ITaskContext} [ctx]\r\n * @returns {ITask[]}\r\n */\r\nexport function findTasks(target: any, match?: ITaskDecorator, ctx?: ITaskContext): ITask[] {\r\n    return findTaskMap(target, match, ctx);\r\n}\r\n\r\n/**\r\n * decorator task define implements IContextDefine.\r\n *\r\n * @export\r\n * @param {Function} constructor\r\n */\r\nexport function taskdefine<T extends Function>(target?: (new <T>() => T)): any {\r\n    if (_.isFunction(target)) {\r\n        target['__task_context'] = true;\r\n        return target;\r\n    } else {\r\n        let tg = target;\r\n        return (target: any) => {\r\n            target['__task_context'] = tg || true;\r\n            return target;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * get all taskdefine in module.\r\n *\r\n * @export\r\n * @param {any} target\r\n * @returns\r\n */\r\nexport function findTaskDefines(target): IContextDefine[] {\r\n    let defs: IContextDefine[] = [];\r\n    if (!target) {\r\n        return defs;\r\n    }\r\n    if (_.isFunction(target)) {\r\n        if (target['__task_context']) {\r\n            let dc = new target();\r\n            if (!dc['getContext']) {\r\n                dc = taskDefine2Context(dc);\r\n            }\r\n            defs.push(<IContextDefine>dc);\r\n        }\r\n    } else if (_.isArray(target)) {\r\n        _.each(target, sm => {\r\n            defs.concat(findTaskDefines(sm));\r\n        });\r\n    } else {\r\n        _.each(_.keys(target), key => {\r\n            if (!key || !target[key] || /^[0-9]+$/.test(key)) {\r\n                return;\r\n            }\r\n            // console.log(chalk.grey('find task define from :'), chalk.cyan(key));\r\n            defs = defs.concat(findTaskDefines(target[key]));\r\n        });\r\n    }\r\n\r\n    return defs;\r\n}\r\n\r\n\r\n/**\r\n * get one taskdefine in module.\r\n *\r\n * @export\r\n * @param {any} target\r\n * @returns\r\n */\r\nexport function findTaskDefine(target): IContextDefine {\r\n    let def: IContextDefine;\r\n    if (!target) {\r\n        return null;\r\n    }\r\n    if (_.isFunction(target)) {\r\n        if (target['__task_context']) {\r\n            let dc = new target();\r\n            if (dc['getContext']) {\r\n                def = dc;\r\n            } else {\r\n                def = taskDefine2Context(dc);\r\n            }\r\n        }\r\n    } else if (_.isArray(target)) {\r\n        _.each(target, sm => {\r\n            if (def) {\r\n                return false;\r\n            }\r\n            def = findTaskDefine(sm);\r\n            return true;\r\n        });\r\n    } else {\r\n        _.each(_.keys(target), key => {\r\n            if (def) {\r\n                return false;\r\n            }\r\n            if (!key || !target[key] || /^[0-9]+$/.test(key)) {\r\n                return true;\r\n            }\r\n            // console.log(chalk.grey('find task define from :'), chalk.cyan(key));\r\n            def = findTaskDefine(target[key]);\r\n            return true;\r\n        });\r\n    }\r\n\r\n    return def;\r\n}\r\n\r\n/**\r\n * find one taskdefine in module.\r\n *\r\n * @export\r\n * @param {(string | Object)} md\r\n * @returns {Promise<IContextDefine>}\r\n */\r\nexport function findTaskDefineInModule(md: string | Object): Promise<IContextDefine> {\r\n    let tsdef;\r\n    try {\r\n        if (_.isString(md)) {\r\n            tsdef = findTaskDefine(require(md));\r\n        } else {\r\n            tsdef = findTaskDefine(md);\r\n        }\r\n    } catch (err) {\r\n        return Promise.reject(err);\r\n    }\r\n\r\n    if (tsdef) {\r\n        return Promise.resolve(tsdef);\r\n    } else {\r\n        // console.error('can not found task config builder method in module {0}.', mdl);\r\n        // console.log(chalk.yellow('can not found task define in module.'));\r\n        return Promise.resolve(null);\r\n    }\r\n}\r\n\r\n/**\r\n * fund tasks in module.\r\n *\r\n * @export\r\n * @param {(string | Object)} md\r\n * @param {ITaskDecorator} [match]\r\n * @param {ITaskContext} [ctx]\r\n * @returns {Promise<ITask[]>}\r\n */\r\nexport function findTasksInModule(md: string | Object, match?: ITaskDecorator, ctx?: ITaskContext): Promise<ITask[]> {\r\n    let mdls;\r\n    try {\r\n        if (_.isString(md)) {\r\n            mdls = findTasks(require(md), match, ctx);\r\n        } else {\r\n            mdls = findTasks(md, match, ctx);\r\n        }\r\n    } catch (err) {\r\n        return Promise.reject(err);\r\n    }\r\n\r\n    return Promise.resolve(mdls);\r\n}\r\n\r\n\r\n/**\r\n * find one task define in directories.\r\n *\r\n * @export\r\n * @param {Src} dirs\r\n * @returns {Promise<IContextDefine>}\r\n */\r\nexport function findTaskDefineInDir(dirs: Src): Promise<IContextDefine> {\r\n    return Promise.race<IContextDefine>(_.map(_.isArray(dirs) ? dirs : [dirs], dir => {\r\n        return new Promise<IContextDefine>((resolve, reject) => {\r\n            if (existsSync(dir)) {\r\n                let mdl = requireDir(dir, { duplicates: true, camelcase: true, recurse: true });\r\n                if (mdl) {\r\n                    let def = findTaskDefine(mdl);\r\n                    if (def) {\r\n                        resolve(def);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }));\r\n}\r\n\r\n/**\r\n * find tasks in directories.\r\n *\r\n * @export\r\n * @param {Src} dirs\r\n * @param {ITaskDecorator} [match]\r\n * @param {ITaskContext} [ctx]\r\n * @returns {Promise<ITask[]>}\r\n */\r\nexport function findTasksInDir(dirs: Src, match?: ITaskDecorator, ctx?: ITaskContext): Promise<ITask[]> {\r\n    let map = new Map<any, Taskitem>();\r\n    return Promise.all(_.map(_.isArray(dirs) ? dirs : [dirs], dir => {\r\n        console.log(chalk.grey('begin load task from dir'), chalk.cyan(dir));\r\n        try {\r\n            let mdl = requireDir(dir, { duplicates: true, camelcase: true, recurse: true });\r\n            return Promise.resolve(findTaskMap(mdl, match, ctx, map));\r\n        } catch (err) {\r\n            return Promise.reject(err);\r\n        }\r\n    }))\r\n        .then(tasks => {\r\n            return _.flatten(tasks);\r\n        });\r\n}\r\n\r\n/**\r\n * task define context convert.\r\n *\r\n * @export\r\n * @param {ITaskDefine} tdef\r\n * @returns {IContextDefine}\r\n */\r\nexport function taskDefine2Context(tdef: ITaskDefine): IContextDefine {\r\n    let context: any = _.extend({}, tdef);\r\n    context['getContext'] = (cfg: ITaskConfig) => {\r\n        return bindingConfig(tdef.loadConfig(cfg.option, cfg.env));\r\n    };\r\n\r\n    context['tasks'] = tdef.loadTasks ? (context) => tdef.loadTasks(context) : null;\r\n\r\n    return <IContextDefine>context;\r\n}\r\n"]}