{"version":3,"sources":["decorator.js","decorator.ts"],"names":["task","option","target","dynamicTask","findTasks","oper","env","tasks","_","isFunction","decorator","push","dyts","concat","generateTask_1","generateTask","isArray","each","sm","keys","key","test","console","log","chalk","grey","cyan","taskdefine","findTaskDefines","defs","findTaskDefine","def","findTaskDefineInModule","md","tsdef","isString","require","err","Promise","reject","resolve","findTasksInModule","mdls","findTaskDefineInDir","dirs","race","map","dir","fs_1","existsSync","mdl","requireDir","findTasksInDir","all","recurse","then","flatten","exports"],"mappings":"AAAA,YCeA,SAAAA,MAAqBC,GACjB,MAAO,UAACC,GAEJ,MADAA,GAAA,OAAmBD,MACZC,GAIf,QAAAC,aAA4BD,GAExB,MADAA,GAAA,eAA0B,EACnBA,EAaX,QAAAE,WAA0BF,EAAaG,EAAkBC,GACrD,GAAIC,KACJ,KAAKL,EACD,MAAOK,EAEX,IAAIC,EAAEC,WAAWP,GAAS,CACtB,GAAIA,EAAA,OAAkB,CAClB,GAAIF,GAAc,GAAIE,EACtBF,GAAKU,UAAuBR,EAAA,OAC5BK,EAAMI,KAAKX,GAEf,GAAIE,EAAA,cAAyB,CACzB,GAAIU,IAAuB,GAAIV,IAAUK,OACzCA,GAAQA,EAAMM,OAAOC,eAAAC,aAAaH,EAAMP,EAAMC,SAE3CE,GAAEQ,QAAQd,GACjBM,EAAES,KAAKf,EAAQ,SAAAgB,GACXX,EAAMM,OAAOT,UAAUc,MAG3BV,EAAES,KAAKT,EAAEW,KAAKjB,GAAS,SAAAkB,GACdA,GAAQlB,EAAOkB,KAAQ,WAAWC,KAAKD,KAG5CE,QAAQC,IAAIC,MAAMC,KAAK,oBAAqBD,MAAME,KAAKN,IACvDb,EAAQA,EAAMM,OAAOT,UAAUF,EAAOkB,OAI9C,OAAOb,GASX,QAAAoB,cACI,MAAO,UAACzB,GAEJ,MADAA,GAAA,cAAyB,EAClBA,GAWf,QAAA0B,iBAAgC1B,GAC5B,GAAI2B,KACJ,OAAK3B,IAGDM,EAAEC,WAAWP,GACTA,EAAA,cACA2B,EAAKlB,KAAkB,GAAIT,IAExBM,EAAEQ,QAAQd,GACjBM,EAAES,KAAKf,EAAQ,SAAAgB,GACXW,EAAKhB,OAAOe,gBAAgBV,MAGhCV,EAAES,KAAKT,EAAEW,KAAKjB,GAAS,SAAAkB,GACdA,GAAQlB,EAAOkB,KAAQ,WAAWC,KAAKD,KAG5CE,QAAQC,IAAIC,MAAMC,KAAK,2BAA4BD,MAAME,KAAKN,IAC9DS,EAAOA,EAAKhB,OAAOe,gBAAgB1B,EAAOkB,QAI3CS,GApBIA,EA+Bf,QAAAC,gBAA+B5B,GAC3B,GAAI6B,GAAAA,MACJ,OAAK7B,IAGDM,EAAEC,WAAWP,GACTA,EAAA,eACA6B,EAAmB,GAAI7B,IAEpBM,EAAEQ,QAAQd,GACjBM,EAAES,KAAKf,EAAQ,SAAAgB,GACX,OAAIa,IAGJA,EAAMD,eAAeZ,IACd,KAGXV,EAAES,KAAKT,EAAEW,KAAKjB,GAAS,SAAAkB,GACnB,OAAIW,MAGCX,GAAQlB,EAAOkB,KAAQ,WAAWC,KAAKD,MAG5CE,QAAQC,IAAIC,MAAMC,KAAK,2BAA4BD,MAAME,KAAKN,IAC9DW,EAAMD,eAAe5B,EAAOkB,KACrB,MAIRW,GA5BI,KAsCf,QAAAC,wBAAuCC,GACnC,GAAIC,GAAAA,MACJ,KAEQA,EAAQJ,eADRtB,EAAE2B,SAASF,GACYG,QAAQH,GAERA,GAE7B,MAAOI,GACL,MAAOC,SAAQC,OAAOF,GAG1B,MAAIH,GACOI,QAAQE,QAAQN,GAGhBI,QAAQC,OAAO,8BAK9B,QAAAE,mBAAkCR,EAAqB5B,EAAkBC,GACrE,GAAIoC,GAAAA,MACJ,KAEQA,EADAlC,EAAE2B,SAASF,GACJ7B,UAAUgC,QAAQH,GAAK5B,EAAMC,GAE7BF,UAAU6B,EAAI5B,EAAMC,GAEjC,MAAO+B,GACL,MAAOC,SAAQC,OAAOF,GAG1B,MAAOC,SAAQE,QAAQE,GAW3B,QAAAC,qBAAoCC,GAChC,MAAON,SAAQO,KAAkBrC,EAAEsC,IAAItC,EAAEQ,QAAQ4B,GAAQA,GAAQA,GAAO,SAAAG,GACpE,MAAO,IAAIT,SAAqB,SAACE,EAASD,GACtC,GAAIS,KAAAC,WAAWF,GAAM,CACjB,GAAIG,GAAMC,WAAWJ,EACrB,IAAIG,EAAK,CACL,GAAInB,GAAMD,eAAeoB,EACrBnB,IACAS,EAAQT,UAehC,QAAAqB,gBAA+BR,EAAWvC,EAAkBC,GACxD,MAAOgC,SAAQe,IAAI7C,EAAEsC,IAAItC,EAAEQ,QAAQ4B,GAAQA,GAAQA,GAAO,SAAAG,GACtDzB,QAAQC,IAAIC,MAAMC,KAAK,4BAA6BD,MAAME,KAAKqB,GAC/D,KACI,GAAIG,GAAMC,WAAWJ,GAAOO,SAAS,GACrC,OAAOhB,SAAQE,QAAQpC,UAAU8C,EAAK7C,EAAMC,IAC9C,MAAO+B,GACL,MAAOC,SAAQC,OAAOF,OAGzBkB,KAAK,SAAAhD,GACF,MAAOC,GAAEgD,QAAQjD,KAlP7B6B,QAAO,mBACP,IAAY5B,GAAC4B,QAAM,UACPZ,MAAKY,QAAM,SAEvBtB,eAAAsB,QAA6B,kBAC7BY,KAAAZ,QAA2B,MACrBe,WAAaf,QAAQ,cASXqB,SAAAzD,KAAIA,KAOJyD,QAAAtD,YAAWA,YAeXsD,QAAArD,UAASA,UAsCTqD,QAAA9B,WAAUA,WAcV8B,QAAA7B,gBAAeA,gBAkCf6B,QAAA3B,eAAcA,eAyCd2B,QAAAzB,uBAAsBA,uBAqBtByB,QAAAhB,kBAAiBA,kBAuBjBgB,QAAAd,oBAAmBA,oBAuBnBc,QAAAL,eAAcA","file":"../decorator.js","sourcesContent":["\"use strict\";\nrequire('reflect-metadata');\nconst _ = require('lodash');\nconst chalk = require('chalk');\nconst generateTask_1 = require('./generateTask');\nconst fs_1 = require('fs');\nconst requireDir = require('require-dir');\nfunction task(option) {\n    return (target) => {\n        target['__task'] = option || {};\n        return target;\n    };\n}\nexports.task = task;\nfunction dynamicTask(target) {\n    target['__dynamictask'] = true;\n    return target;\n}\nexports.dynamicTask = dynamicTask;\nfunction findTasks(target, oper, env) {\n    let tasks = [];\n    if (!target) {\n        return tasks;\n    }\n    if (_.isFunction(target)) {\n        if (target['__task']) {\n            let task = new target();\n            task.decorator = target['__task'];\n            tasks.push(task);\n        }\n        if (target['__dynamictask']) {\n            let dyts = (new target()).tasks();\n            tasks = tasks.concat(generateTask_1.generateTask(dyts, oper, env));\n        }\n    }\n    else if (_.isArray(target)) {\n        _.each(target, sm => {\n            tasks.concat(findTasks(sm));\n        });\n    }\n    else {\n        _.each(_.keys(target), key => {\n            if (!key || !target[key] || /^[0-9]+$/.test(key)) {\n                return;\n            }\n            console.log(chalk.grey('find task from :'), chalk.cyan(key));\n            tasks = tasks.concat(findTasks(target[key]));\n        });\n    }\n    return tasks;\n}\nexports.findTasks = findTasks;\nfunction taskdefine() {\n    return (target) => {\n        target['__taskdefine'] = true;\n        return target;\n    };\n}\nexports.taskdefine = taskdefine;\nfunction findTaskDefines(target) {\n    let defs = [];\n    if (!target) {\n        return defs;\n    }\n    if (_.isFunction(target)) {\n        if (target['__taskdefine']) {\n            defs.push(new target());\n        }\n    }\n    else if (_.isArray(target)) {\n        _.each(target, sm => {\n            defs.concat(findTaskDefines(sm));\n        });\n    }\n    else {\n        _.each(_.keys(target), key => {\n            if (!key || !target[key] || /^[0-9]+$/.test(key)) {\n                return;\n            }\n            console.log(chalk.grey('find task define from :'), chalk.cyan(key));\n            defs = defs.concat(findTaskDefines(target[key]));\n        });\n    }\n    return defs;\n}\nexports.findTaskDefines = findTaskDefines;\nfunction findTaskDefine(target) {\n    let def;\n    if (!target) {\n        return null;\n    }\n    if (_.isFunction(target)) {\n        if (target['__taskdefine']) {\n            def = new target();\n        }\n    }\n    else if (_.isArray(target)) {\n        _.each(target, sm => {\n            if (def) {\n                return false;\n            }\n            def = findTaskDefine(sm);\n            return true;\n        });\n    }\n    else {\n        _.each(_.keys(target), key => {\n            if (def) {\n                return false;\n            }\n            if (!key || !target[key] || /^[0-9]+$/.test(key)) {\n                return true;\n            }\n            console.log(chalk.grey('find task define from :'), chalk.cyan(key));\n            def = findTaskDefine(target[key]);\n            return true;\n        });\n    }\n    return def;\n}\nexports.findTaskDefine = findTaskDefine;\nfunction findTaskDefineInModule(md) {\n    let tsdef;\n    try {\n        if (_.isString(md)) {\n            tsdef = findTaskDefine(require(md));\n        }\n        else {\n            tsdef = findTaskDefine(md);\n        }\n    }\n    catch (err) {\n        return Promise.reject(err);\n    }\n    if (tsdef) {\n        return Promise.resolve(tsdef);\n    }\n    else {\n        return Promise.reject('can not found task define.');\n    }\n}\nexports.findTaskDefineInModule = findTaskDefineInModule;\nfunction findTasksInModule(md, oper, env) {\n    let mdls;\n    try {\n        if (_.isString(md)) {\n            mdls = findTasks(require(md), oper, env);\n        }\n        else {\n            mdls = findTasks(md, oper, env);\n        }\n    }\n    catch (err) {\n        return Promise.reject(err);\n    }\n    return Promise.resolve(mdls);\n}\nexports.findTasksInModule = findTasksInModule;\nfunction findTaskDefineInDir(dirs) {\n    return Promise.race(_.map(_.isArray(dirs) ? dirs : [dirs], dir => {\n        return new Promise((resolve, reject) => {\n            if (fs_1.existsSync(dir)) {\n                let mdl = requireDir(dir);\n                if (mdl) {\n                    let def = findTaskDefine(mdl);\n                    if (def) {\n                        resolve(def);\n                    }\n                }\n            }\n        });\n    }));\n}\nexports.findTaskDefineInDir = findTaskDefineInDir;\nfunction findTasksInDir(dirs, oper, env) {\n    return Promise.all(_.map(_.isArray(dirs) ? dirs : [dirs], dir => {\n        console.log(chalk.grey('begin load task from dir'), chalk.cyan(dir));\n        try {\n            let mdl = requireDir(dir, { recurse: true });\n            return Promise.resolve(findTasks(mdl, oper, env));\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }))\n        .then(tasks => {\n        return _.flatten(tasks);\n    });\n}\nexports.findTasksInDir = findTasksInDir;\n","import 'reflect-metadata';\r\nimport * as _ from 'lodash';\r\nimport * as chalk from 'chalk';\r\nimport { ITask, ITaskInfo, ITaskDefine, Src, IDynamicTasks, Operation, IEnvOption } from './TaskConfig';\r\nimport { generateTask } from './generateTask';\r\nimport { existsSync } from 'fs';\r\nconst requireDir = require('require-dir');\r\n\r\n/**\r\n * task decorator.\r\n * \r\n * @export\r\n * @param {ITaskInfo} type\r\n * @returns\r\n */\r\nexport function task(option?: ITaskInfo) {\r\n    return (target: any) => {\r\n        target['__task'] = option || {};\r\n        return target;\r\n    }\r\n}\r\n\r\nexport function dynamicTask(target: any) {\r\n    target['__dynamictask'] = true;\r\n    return target;\r\n}\r\n\r\n\r\n/**\r\n * find tasks in Object module.\r\n * \r\n * @export\r\n * @param {*} target\r\n * @param {Operation} [oper]\r\n * @param {IEnvOption} [env]\r\n * @returns {ITask[]}\r\n */\r\nexport function findTasks(target: any, oper?: Operation, env?: IEnvOption): ITask[] {\r\n    let tasks: ITask[] = [];\r\n    if (!target) {\r\n        return tasks;\r\n    }\r\n    if (_.isFunction(target)) {\r\n        if (target['__task']) {\r\n            let task: ITask = new target();\r\n            task.decorator = <ITaskInfo>target['__task'];\r\n            tasks.push(task);\r\n        }\r\n        if (target['__dynamictask']) {\r\n            let dyts = (<IDynamicTasks>new target()).tasks()\r\n            tasks = tasks.concat(generateTask(dyts, oper, env));\r\n        }\r\n    } else if (_.isArray(target)) {\r\n        _.each(target, sm => {\r\n            tasks.concat(findTasks(sm));\r\n        });\r\n    } else {\r\n        _.each(_.keys(target), key => {\r\n            if (!key || !target[key] || /^[0-9]+$/.test(key)) {\r\n                return;\r\n            }\r\n            console.log(chalk.grey('find task from :'), chalk.cyan(key));\r\n            tasks = tasks.concat(findTasks(target[key]));\r\n        });\r\n    }\r\n\r\n    return tasks;\r\n}\r\n\r\n/**\r\n * decorator task define implements ITaskDefine.\r\n * \r\n * @export\r\n * @param {Function} constructor\r\n */\r\nexport function taskdefine() {\r\n    return (target: any) => {\r\n        target['__taskdefine'] = true;\r\n        return target;\r\n    }\r\n}\r\n\r\n/**\r\n * get all taskdefine in module.\r\n * \r\n * @export\r\n * @param {any} target\r\n * @returns\r\n */\r\nexport function findTaskDefines(target): ITaskDefine[] {\r\n    let defs: ITaskDefine[] = [];\r\n    if (!target) {\r\n        return defs;\r\n    }\r\n    if (_.isFunction(target)) {\r\n        if (target['__taskdefine']) {\r\n            defs.push(<ITaskDefine>new target());\r\n        }\r\n    } else if (_.isArray(target)) {\r\n        _.each(target, sm => {\r\n            defs.concat(findTaskDefines(sm));\r\n        });\r\n    } else {\r\n        _.each(_.keys(target), key => {\r\n            if (!key || !target[key] || /^[0-9]+$/.test(key)) {\r\n                return;\r\n            }\r\n            console.log(chalk.grey('find task define from :'), chalk.cyan(key));\r\n            defs = defs.concat(findTaskDefines(target[key]));\r\n        });\r\n    }\r\n\r\n    return defs;\r\n}\r\n\r\n\r\n/**\r\n * get one taskdefine in module.\r\n * \r\n * @export\r\n * @param {any} target\r\n * @returns\r\n */\r\nexport function findTaskDefine(target): ITaskDefine {\r\n    let def: ITaskDefine;\r\n    if (!target) {\r\n        return null;\r\n    }\r\n    if (_.isFunction(target)) {\r\n        if (target['__taskdefine']) {\r\n            def = <ITaskDefine>new target();\r\n        }\r\n    } else if (_.isArray(target)) {\r\n        _.each(target, sm => {\r\n            if (def) {\r\n                return false;\r\n            }\r\n            def = findTaskDefine(sm);\r\n            return true;\r\n        });\r\n    } else {\r\n        _.each(_.keys(target), key => {\r\n            if (def) {\r\n                return false;\r\n            }\r\n            if (!key || !target[key] || /^[0-9]+$/.test(key)) {\r\n                return true;\r\n            }\r\n            console.log(chalk.grey('find task define from :'), chalk.cyan(key));\r\n            def = findTaskDefine(target[key]);\r\n            return true;\r\n        });\r\n    }\r\n\r\n    return def;\r\n}\r\n\r\n/**\r\n * find one taskdefine in module.\r\n * \r\n * @export\r\n * @param {(string | Object)} md\r\n * @returns {Promise<ITaskDefine>}\r\n */\r\nexport function findTaskDefineInModule(md: string | Object): Promise<ITaskDefine> {\r\n    let tsdef;\r\n    try {\r\n        if (_.isString(md)) {\r\n            tsdef = findTaskDefine(require(md));\r\n        } else {\r\n            tsdef = findTaskDefine(md);\r\n        }\r\n    } catch (err) {\r\n        return Promise.reject(err);\r\n    }\r\n\r\n    if (tsdef) {\r\n        return Promise.resolve(tsdef);\r\n    } else {\r\n        // console.error('can not found task config builder method in module {0}.', mdl);\r\n        return Promise.reject('can not found task define.');\r\n    }\r\n}\r\n\r\n\r\nexport function findTasksInModule(md: string | Object, oper?: Operation, env?: IEnvOption): Promise<ITask[]> {\r\n    let mdls;\r\n    try {\r\n        if (_.isString(md)) {\r\n            mdls = findTasks(require(md), oper, env);\r\n        } else {\r\n            mdls = findTasks(md, oper, env);\r\n        }\r\n    } catch (err) {\r\n        return Promise.reject(err);\r\n    }\r\n\r\n    return Promise.resolve(mdls);\r\n}\r\n\r\n\r\n/**\r\n * find one task define in directories.\r\n * \r\n * @export\r\n * @param {Src} dirs\r\n * @returns {Promise<ITaskDefine>}\r\n */\r\nexport function findTaskDefineInDir(dirs: Src): Promise<ITaskDefine> {\r\n    return Promise.race<ITaskDefine>(_.map(_.isArray(dirs) ? dirs : [dirs], dir => {\r\n        return new Promise<ITaskDefine>((resolve, reject) => {\r\n            if (existsSync(dir)) {\r\n                let mdl = requireDir(dir);\r\n                if (mdl) {\r\n                    let def = findTaskDefine(mdl);\r\n                    if (def) {\r\n                        resolve(def);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }));\r\n}\r\n\r\n/**\r\n * find tasks in directories.\r\n * \r\n * @export\r\n * @param {Src} dirs\r\n * @returns {Promise<ITask[]>}\r\n */\r\nexport function findTasksInDir(dirs: Src, oper?: Operation, env?: IEnvOption): Promise<ITask[]> {\r\n    return Promise.all(_.map(_.isArray(dirs) ? dirs : [dirs], dir => {\r\n        console.log(chalk.grey('begin load task from dir'), chalk.cyan(dir));\r\n        try {\r\n            let mdl = requireDir(dir, { recurse: true });\r\n            return Promise.resolve(findTasks(mdl, oper, env));\r\n        } catch (err) {\r\n            return Promise.reject(err);\r\n        }\r\n    }))\r\n        .then(tasks => {\r\n            return _.flatten(tasks);\r\n        });\r\n}"]}