{"version":3,"sources":["decorator.ts"],"names":["task","target","_","isFunction","tg_1","dynamicTask","tg_2","findTaskset","tasks","match","ctx","tinfo","isBoolean","utils_1","matchCompare","has","task_1","setInfo","set","tinfo_1","dyts","map","tk","extend","clone","generateTask_1","generateTask","isArray","each","sm","keys","key","test","console","log","chalk","grey","cyan","findTaskMap","Map","forEach","it","concat","push","findTasks","taskdefine","tg_3","findTaskDefines","defs","dc","taskDefine2Context","findTaskDefine","def","findTaskDefineInModule","md","tsdef","isString","require","err","Promise","reject","resolve","yellow","findTasksInModule","mdls","findTaskDefineInDir","dirs","race","dir","fs_1","existsSync","mdl","requireDir","duplicates","camelcase","recurse","findTasksInDir","all","then","flatten","tdef","context","cfg","bindingConfig_1","bindingConfig","loadConfig","option","env","loadTasks","exports"],"mappings":"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","file":"../decorator.js","sourcesContent":["import 'reflect-metadata';\r\nimport * as _ from 'lodash';\r\nimport * as chalk from 'chalk';\r\nimport { ITask, ITaskDecorator, ITaskContext, ITaskConfig, IContextDefine, ITaskDefine, Src, IDynamicTasks } from './TaskConfig';\r\nimport { generateTask } from './generateTask';\r\nimport { bindingConfig } from './bindingConfig';\r\nimport { matchCompare } from './utils';\r\nimport { existsSync } from 'fs';\r\nconst requireDir = require('require-dir');\r\n\r\n\r\n/**\r\n * task decorator.\r\n * \r\n * @export\r\n * @param {ITaskDecorator} type\r\n * @returns\r\n */\r\nexport function task<T extends Function>(target?: (new <T>() => T) | ITaskDecorator): any {\r\n    if (_.isFunction(target)) {\r\n        target['__task'] = {};\r\n        return target;\r\n    } else {\r\n        let tg = target;\r\n        return (target: any) => {\r\n            target['__task'] = tg || {};\r\n            return target;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * dynamic task decorator.\r\n * \r\n * @export\r\n * @template T\r\n * @param {((new <T>() => T) | ITaskDecorator)} [target]\r\n * @returns {*}\r\n */\r\nexport function dynamicTask<T extends Function>(target?: (new <T>() => T) | ITaskDecorator): any {\r\n    if (target && _.isFunction(target)) {\r\n        target['__dynamictask'] = {};\r\n        return target;\r\n    } else {\r\n        let tg = target;\r\n        return (target: any) => {\r\n            target['__dynamictask'] = tg || {};\r\n            return target;\r\n        }\r\n    }\r\n}\r\n\r\n\r\ntype Taskitem = ITask | ITask[];\r\n\r\nfunction findTaskset(tasks: Map<any, Taskitem>, target: any, match?: ITaskDecorator, ctx?: ITaskContext) {\r\n\r\n    if (!target) {\r\n        return;\r\n    }\r\n    if (_.isFunction(target)) {\r\n        if (target['__task']) {\r\n            let tinfo: ITaskDecorator = target['__task'];\r\n            tinfo = _.isBoolean(tinfo) ? {} : tinfo;\r\n\r\n            if (!matchCompare(tinfo, match, ctx)) {\r\n                return;\r\n            }\r\n            if (tasks.has(target)) {\r\n                return;\r\n            }\r\n\r\n            let task: ITask = new target(tinfo);\r\n            if (task.setInfo) {\r\n                task.setInfo(tinfo);\r\n            }\r\n\r\n            tasks.set(target, task);\r\n\r\n        } else if (target['__dynamictask']) {\r\n            let tinfo: ITaskDecorator = target['__dynamictask'];\r\n\r\n            if (!matchCompare(tinfo, match, ctx)) {\r\n                return;\r\n            }\r\n\r\n            if (tasks.has(target)) {\r\n                return;\r\n            }\r\n\r\n            let dyts = _.map((<IDynamicTasks>new target()).tasks(), tk => {\r\n                tk = _.extend(_.clone(tinfo), tk);\r\n                // tk.group = tk.group || tinfo.group;\r\n                return tk;\r\n            });\r\n            tasks.set(target, generateTask(dyts, match, ctx));\r\n        }\r\n    } else if (_.isArray(target)) {\r\n        _.each(target, sm => {\r\n            findTaskset(tasks, sm, match, ctx);\r\n        });\r\n    } else {\r\n        _.each(_.keys(target), key => {\r\n            if (!key || !target[key] || /^[0-9]+$/.test(key)) {\r\n                return;\r\n            }\r\n            console.log(chalk.grey('find task from :'), chalk.cyan(key));\r\n            findTaskset(tasks, target[key], match, ctx);\r\n        });\r\n    }\r\n}\r\n\r\n\r\nfunction findTaskMap(target: any, match?: ITaskDecorator, ctx?: ITaskContext, map?: Map<any, Taskitem>): ITask[] {\r\n    map = map || new Map<any, Taskitem>();\r\n    findTaskset(map, target, match, ctx);\r\n    let tasks: ITask[] = [];\r\n    map.forEach((it: Taskitem) => {\r\n        if (_.isArray(it)) {\r\n            tasks = tasks.concat(it);\r\n        } else {\r\n            tasks.push(it);\r\n        }\r\n    });\r\n    return tasks;\r\n}\r\n/**\r\n * find tasks in Object module.\r\n * \r\n * @export\r\n * @param {*} target\r\n * @param {ITaskDecorator} [match]\r\n * @param {ITaskContext} [ctx]\r\n * @returns {ITask[]}\r\n */\r\nexport function findTasks(target: any, match?: ITaskDecorator, ctx?: ITaskContext): ITask[] {\r\n    return findTaskMap(target, match, ctx);\r\n}\r\n\r\n/**\r\n * decorator task define implements IContextDefine.\r\n * \r\n * @export\r\n * @param {Function} constructor\r\n */\r\nexport function taskdefine<T extends Function>(target?: (new <T>() => T)): any {\r\n    if (_.isFunction(target)) {\r\n        target['__task_context'] = true;\r\n        return target;\r\n    } else {\r\n        let tg = target;\r\n        return (target: any) => {\r\n            target['__task_context'] = tg || true;\r\n            return target;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * get all taskdefine in module.\r\n * \r\n * @export\r\n * @param {any} target\r\n * @returns\r\n */\r\nexport function findTaskDefines(target): IContextDefine[] {\r\n    let defs: IContextDefine[] = [];\r\n    if (!target) {\r\n        return defs;\r\n    }\r\n    if (_.isFunction(target)) {\r\n        if (target['__task_context']) {\r\n            let dc = new target();\r\n            if (!dc['getContext']) {\r\n                dc = taskDefine2Context(dc);\r\n            }\r\n            defs.push(<IContextDefine>dc);\r\n        }\r\n    } else if (_.isArray(target)) {\r\n        _.each(target, sm => {\r\n            defs.concat(findTaskDefines(sm));\r\n        });\r\n    } else {\r\n        _.each(_.keys(target), key => {\r\n            if (!key || !target[key] || /^[0-9]+$/.test(key)) {\r\n                return;\r\n            }\r\n            console.log(chalk.grey('find task define from :'), chalk.cyan(key));\r\n            defs = defs.concat(findTaskDefines(target[key]));\r\n        });\r\n    }\r\n\r\n    return defs;\r\n}\r\n\r\n\r\n/**\r\n * get one taskdefine in module.\r\n * \r\n * @export\r\n * @param {any} target\r\n * @returns\r\n */\r\nexport function findTaskDefine(target): IContextDefine {\r\n    let def: IContextDefine;\r\n    if (!target) {\r\n        return null;\r\n    }\r\n    if (_.isFunction(target)) {\r\n        if (target['__task_context']) {\r\n            let dc = new target();\r\n            if (dc['getContext']) {\r\n                def = dc;\r\n            } else {\r\n                def = taskDefine2Context(dc);\r\n            }\r\n        }\r\n    } else if (_.isArray(target)) {\r\n        _.each(target, sm => {\r\n            if (def) {\r\n                return false;\r\n            }\r\n            def = findTaskDefine(sm);\r\n            return true;\r\n        });\r\n    } else {\r\n        _.each(_.keys(target), key => {\r\n            if (def) {\r\n                return false;\r\n            }\r\n            if (!key || !target[key] || /^[0-9]+$/.test(key)) {\r\n                return true;\r\n            }\r\n            console.log(chalk.grey('find task define from :'), chalk.cyan(key));\r\n            def = findTaskDefine(target[key]);\r\n            return true;\r\n        });\r\n    }\r\n\r\n    return def;\r\n}\r\n\r\n/**\r\n * find one taskdefine in module.\r\n * \r\n * @export\r\n * @param {(string | Object)} md\r\n * @returns {Promise<IContextDefine>}\r\n */\r\nexport function findTaskDefineInModule(md: string | Object): Promise<IContextDefine> {\r\n    let tsdef;\r\n    try {\r\n        if (_.isString(md)) {\r\n            tsdef = findTaskDefine(require(md));\r\n        } else {\r\n            tsdef = findTaskDefine(md);\r\n        }\r\n    } catch (err) {\r\n        return Promise.reject(err);\r\n    }\r\n\r\n    if (tsdef) {\r\n        return Promise.resolve(tsdef);\r\n    } else {\r\n        // console.error('can not found task config builder method in module {0}.', mdl);\r\n        console.log(chalk.yellow('can not found task define in module.'));\r\n        return Promise.resolve(null);\r\n    }\r\n}\r\n\r\n/**\r\n * fund tasks in module.\r\n * \r\n * @export\r\n * @param {(string | Object)} md\r\n * @param {ITaskDecorator} [match]\r\n * @param {ITaskContext} [ctx]\r\n * @returns {Promise<ITask[]>}\r\n */\r\nexport function findTasksInModule(md: string | Object, match?: ITaskDecorator, ctx?: ITaskContext): Promise<ITask[]> {\r\n    let mdls;\r\n    try {\r\n        if (_.isString(md)) {\r\n            mdls = findTasks(require(md), match, ctx);\r\n        } else {\r\n            mdls = findTasks(md, match, ctx);\r\n        }\r\n    } catch (err) {\r\n        return Promise.reject(err);\r\n    }\r\n\r\n    return Promise.resolve(mdls);\r\n}\r\n\r\n\r\n/**\r\n * find one task define in directories.\r\n * \r\n * @export\r\n * @param {Src} dirs\r\n * @returns {Promise<IContextDefine>}\r\n */\r\nexport function findTaskDefineInDir(dirs: Src): Promise<IContextDefine> {\r\n    return Promise.race<IContextDefine>(_.map(_.isArray(dirs) ? dirs : [dirs], dir => {\r\n        return new Promise<IContextDefine>((resolve, reject) => {\r\n            if (existsSync(dir)) {\r\n                let mdl = requireDir(dir, { duplicates: true, camelcase: true, recurse: true });\r\n                if (mdl) {\r\n                    let def = findTaskDefine(mdl);\r\n                    if (def) {\r\n                        resolve(def);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }));\r\n}\r\n\r\n/**\r\n * find tasks in directories.\r\n * \r\n * @export\r\n * @param {Src} dirs\r\n * @param {ITaskDecorator} [match]\r\n * @param {ITaskContext} [ctx]\r\n * @returns {Promise<ITask[]>}\r\n */\r\nexport function findTasksInDir(dirs: Src, match?: ITaskDecorator, ctx?: ITaskContext): Promise<ITask[]> {\r\n    let map = new Map<any, Taskitem>();\r\n    return Promise.all(_.map(_.isArray(dirs) ? dirs : [dirs], dir => {\r\n        console.log(chalk.grey('begin load task from dir'), chalk.cyan(dir));\r\n        try {\r\n            let mdl = requireDir(dir, { duplicates: true, camelcase: true, recurse: true });\r\n            return Promise.resolve(findTaskMap(mdl, match, ctx, map));\r\n        } catch (err) {\r\n            return Promise.reject(err);\r\n        }\r\n    }))\r\n        .then(tasks => {\r\n            return _.flatten(tasks);\r\n        });\r\n}\r\n\r\n/**\r\n * task define context convert.\r\n * \r\n * @export\r\n * @param {ITaskDefine} tdef\r\n * @returns {IContextDefine}\r\n */\r\nexport function taskDefine2Context(tdef: ITaskDefine): IContextDefine {\r\n    let context: any = _.extend({}, tdef);\r\n    context['getContext'] = (cfg: ITaskConfig) => {\r\n        return bindingConfig(tdef.loadConfig(cfg.option, cfg.env));\r\n    };\r\n\r\n    context['tasks'] = tdef.loadTasks ? (context) => tdef.loadTasks(context) : null;\r\n\r\n    return <IContextDefine>context;\r\n}\r\n"]}