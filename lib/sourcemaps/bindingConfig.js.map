{"version":3,"sources":["bindingConfig.js","bindingConfig.ts"],"names":["bindingConfig","cfg","parent","createContext","TaskContext","currentOperation","env","oper","deploy","TaskConfig_1","Operation","release","build","watch","test","serve","e2e","getAssertSrc","assert","src","testSrc","e2eSrc","watchSrc","clean","cleanSrc","dist","getCurrentDist","ds","ctx","deployDist","taskStringVal","releaseDist","e2eDist","buildDist","testDist","files","express","filter","mapping","Promise","resolve","globby","then","_","map","taskSourceVal","isFunction","name","require","generateTask_1","taskSequence_1","utils_1","decorator_1","path","fs","exports","globals","_classCallCheck","this","setupTasks","children","packages","option","context","push","items","remove","each","i","mode","item","isFinded","contexts","r","route","eachChildren","trans","task","match","matchCompare","relative","arguments","length","undefined","c","absoluteSrc","root","absolutePath","ext","isString","optName","indexOf","lang","printHelp","module","findTasksInModule","extend","dirs","findTasksInDir","findTaskDefineInModule","findTaskDefineInDir","gulp","tasks","runSequence","generateTask","sequence","addToSequence","getFolders","getRootPath","pathstr","_this","dir","readdirSync","folders","d","sf","join","f","lstatSync","isDirectory","fl","getDist","source","basePath","toPath","replace","filename","packageFile","toRootPath","toStr","rs","setup","concat","keys"],"mappings":"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","file":"../bindingConfig.js","sourcesContent":["\"use strict\";\nconst _ = require('lodash');\nconst TaskConfig_1 = require('./TaskConfig');\nconst generateTask_1 = require('./generateTask');\nconst taskSequence_1 = require('./taskSequence');\nconst utils_1 = require('./utils');\nconst decorator_1 = require('./decorator');\nconst path = require('path');\nconst fs = require('fs');\nconst globby = require('globby');\n/**\n * binding Config, create task context.\n *\n * @export\n * @param {ITaskConfig} cfg\n * @param {ITaskContext} [parent]\n * @returns {ITaskContext}\n */\nfunction bindingConfig(cfg, parent) {\n    if (cfg.createContext) {\n        return cfg.createContext(cfg, parent);\n    }\n    return new TaskContext(cfg, parent);\n}\nexports.bindingConfig = bindingConfig;\n/**\n * global data.\n */\nlet globals = {};\n/**\n * TaskContext\n *\n * @export\n * @class TaskContext\n * @implements {ITaskContext}\n */\nclass TaskContext {\n    constructor(cfg, parent) {\n        this.cfg = cfg;\n        this.parent = parent;\n        this.setupTasks = [];\n        this.children = [];\n        this.packages = {};\n        this.env = cfg.env;\n        this.oper = currentOperation(cfg.env);\n        this.option = cfg.option;\n        this.globals = cfg.globals || globals;\n    }\n    /**\n     * add sub ITaskContext\n     *\n     * @param {ITaskContext} context\n     *\n     * @memberOf ITaskContext\n     */\n    add(context) {\n        context.parent = this;\n        this.children.push(context);\n    }\n    /**\n     * remove sub ITaskContext.\n     *\n     * @param {ITaskContext} [context]\n     *\n     * @memberOf ITaskContext\n     */\n    remove(context) {\n        let items = _.remove(this.children, context);\n        _.each(items, i => {\n            if (i) {\n                i.parent = null;\n            }\n        });\n        return items;\n    }\n    /**\n     * find sub context via express.\n     *\n     * @param {(ITaskContext | ((item: ITaskContext) => boolean))} express\n     * @param {string} [mode] {enum:['route','children', traverse']} default traverse.\n     * @returns {ITaskContext}\n     *\n     * @memberOf ITaskContext\n     */\n    find(express, mode) {\n        let context;\n        this.each(item => {\n            if (context) {\n                return false;\n            }\n            let isFinded = _.isFunction(express) ? express(item) : express === item;\n            if (isFinded) {\n                context = item;\n                return false;\n            }\n            return true;\n        }, mode);\n        return context;\n    }\n    /**\n     * filter items.\n     *\n     * @param {(((item: ITaskContext) => void | boolean))} express\n     * @param {string} [mode] {enum:['route','children', traverse']} default traverse.\n     * @returns {ITaskContext[]}\n     *\n     * @memberOf ITaskContext\n     */\n    filter(express, mode) {\n        let contexts = [];\n        this.each(item => {\n            if (express(item)) {\n                contexts.push(item);\n            }\n        }, mode);\n        return contexts;\n    }\n    /**\n     * find parent context via express.\n     *\n     * @param {(ITaskContext | ((item: ITaskContext) => boolean))} express\n     * @param {string} [mode] {enum:['route','children', traverse']} default traverse.\n     *\n     * @memberOf ITaskContext\n     */\n    each(express, mode) {\n        mode = mode || '';\n        let r;\n        switch (mode) {\n            case 'route':\n                r = this.route(express);\n                break;\n            case 'children':\n                r = this.eachChildren(express);\n                break;\n            case 'traverse':\n                r = this.trans(express);\n                break;\n            default:\n                r = this.trans(express);\n                break;\n        }\n        return r;\n    }\n    eachChildren(express) {\n        _.each(this.children, item => {\n            return express(item);\n        });\n    }\n    /**\n     * do express work in routing.\n     *\n     * @param {(((item: ITaskContext) => void | boolean))} express\n     *\n     * @memberOf ITaskContext\n     */\n    route(express) {\n        if (!express(this)) {\n            return false;\n        }\n        ;\n        if (this.parent && this.parent.route) {\n            return this.parent.route(express);\n        }\n    }\n    /**\n     * translate all sub context to do express work.\n     *\n     * @param {(((item: ITaskContext) => void | boolean))} express\n     *\n     * @memberOf ITaskContext\n     */\n    trans(express) {\n        if (express(this) === false) {\n            return false;\n        }\n        _.each(this.children, item => {\n            return item.trans(express);\n        });\n        return true;\n    }\n    matchCompare(task, match) {\n        if (this.option.match) {\n            return this.option.match(task, match);\n        }\n        return utils_1.matchCompare(task, match);\n    }\n    getSrc(task, relative = false) {\n        let src;\n        let ctx = this;\n        let oper = task ? (task.oper || ctx.oper) : ctx.oper;\n        if (task && task.assert) {\n            src = taskSourceVal(getAssertSrc(task.assert, oper), ctx);\n        }\n        if (!src) {\n            this.route(c => {\n                src = taskSourceVal(getAssertSrc(c.option, oper), c);\n                if (src) {\n                    return false;\n                }\n                return true;\n            });\n        }\n        return (relative !== false) ? src : utils_1.absoluteSrc(ctx.env.root, src);\n    }\n    getDist(task, relative = false) {\n        let dist;\n        let ctx = this;\n        // let oper = task ? (task.oper || context.oper) : context.oper;\n        if (task && task.assert) {\n            dist = getCurrentDist(task.assert, ctx);\n        }\n        if (!dist) {\n            this.route(c => {\n                dist = getCurrentDist(c.option, c);\n                if (dist) {\n                    return false;\n                }\n                return true;\n            });\n        }\n        return (relative !== false) ? dist : utils_1.absolutePath(ctx.env.root, dist);\n    }\n    subTaskName(task, ext = '') {\n        let ctx = this;\n        let name = '';\n        // let oper = context.oper;\n        if (_.isString(task)) {\n            name = task;\n        }\n        else if (task && task !== ctx.option) {\n            // oper = task.oper || context.oper;\n            if (task.name) {\n                name = taskStringVal(task.name, ctx);\n            }\n            if (!name && task.assert && task.assert.name) {\n                name = taskStringVal(task.assert.name, ctx);\n            }\n        }\n        let optName;\n        this.route(c => {\n            optName = taskStringVal(c.option.name, c);\n            if (optName) {\n                return false;\n            }\n            return true;\n        });\n        if (optName) {\n            if (name.indexOf(optName + '-') === 0) {\n                return name;\n            }\n            // avoid soma name.\n            if (name && optName !== name) {\n                return `${optName}-${name}` + ext;\n            }\n            return optName + ext;\n        }\n        else {\n            return name + ext;\n        }\n    }\n    printHelp(lang) {\n        if (this.cfg.printHelp) {\n            this.cfg.printHelp(lang);\n        }\n    }\n    findTasks(module, match) {\n        let ctx = this;\n        return decorator_1.findTasksInModule(module, _.extend({ oper: ctx.oper }, match || {}), this);\n    }\n    findTasksInDir(dirs, match) {\n        let ctx = this;\n        return decorator_1.findTasksInDir(dirs, _.extend({ oper: ctx.oper }, match || {}), this);\n    }\n    findTaskDefine(module) {\n        return decorator_1.findTaskDefineInModule(module);\n    }\n    findTaskDefineInDir(dirs) {\n        return decorator_1.findTaskDefineInDir(dirs);\n    }\n    fileFilter(express, filter, mapping) {\n        return files(express, filter, mapping);\n    }\n    runSequence(gulp, tasks) {\n        return taskSequence_1.runSequence(gulp, tasks);\n    }\n    generateTask(tasks, match) {\n        let ctx = this;\n        return generateTask_1.generateTask(tasks, _.extend({ oper: ctx.oper }, match || {}), this);\n    }\n    addToSequence(sequence, task) {\n        if (this.cfg.addToSequence) {\n            return this.cfg.addToSequence(sequence, task);\n        }\n        return taskSequence_1.addToSequence(sequence, task, this);\n    }\n    getRootPath() {\n        return this.env.root;\n    }\n    getRootFolders(express) {\n        return this.getFolders(this.getRootPath(), express);\n    }\n    getFolders(pathstr, express) {\n        let dir = fs.readdirSync(pathstr);\n        let folders = [];\n        _.each(dir, (d) => {\n            let sf = path.join(pathstr, d);\n            let f = fs.lstatSync(sf);\n            if (f.isDirectory()) {\n                if (express) {\n                    let fl = express(sf, d, this);\n                    if (fl) {\n                        folders.push(fl);\n                    }\n                }\n                else {\n                    folders.push(sf);\n                }\n            }\n        });\n        return folders;\n    }\n    getDistFolders(express, task) {\n        return this.getFolders(this.getDist(task), express);\n    }\n    toRootSrc(src) {\n        return utils_1.absoluteSrc(this.cfg.env.root, src);\n    }\n    toRootPath(pathstr) {\n        return utils_1.absolutePath(this.cfg.env.root, pathstr);\n    }\n    toDistSrc(src, task) {\n        return utils_1.absoluteSrc(this.getDist(task), src);\n    }\n    toDistPath(pathstr, task) {\n        return utils_1.absolutePath(this.getDist(task), pathstr);\n    }\n    toSrc(source) {\n        return taskSourceVal(source, this);\n    }\n    toStr(name) {\n        return taskStringVal(name, this);\n    }\n    toUrl(basePath, toPath) {\n        return (toPath ? path.relative(basePath, toPath) : basePath).replace(/\\\\/g, '/').replace(/^\\//g, '');\n    }\n    getPackage(filename) {\n        filename = filename || this.cfg.packageFile;\n        let name = this.toRootPath(this.toStr(filename) || 'package.json');\n        if (!this.packages[name]) {\n            this.packages[name] = require(name);\n        }\n        return this.packages[name];\n    }\n    setup(task, gulp) {\n        let rs = task.setup(this, gulp);\n        this.setupTasks.push(task);\n        return rs;\n    }\n    tasks(express) {\n        return express ? _.filter(this.setupTasks, express) : this.setupTasks;\n    }\n    registerTasks(express) {\n        let tasks = [];\n        this.each(c => {\n            tasks = tasks.concat(c.tasks(express));\n        });\n        return tasks;\n    }\n    globalTasks() {\n        return _.keys(this.globals.tasks || {});\n    }\n}\nexports.TaskContext = TaskContext;\n/**\n * get current env Operation.\n *\n * @export\n * @param {EnvOption} env\n * @returns\n */\nfunction currentOperation(env) {\n    let oper;\n    if (env.deploy) {\n        oper = TaskConfig_1.Operation.deploy;\n    }\n    else if (env.release) {\n        oper = TaskConfig_1.Operation.release;\n    }\n    else {\n        oper = TaskConfig_1.Operation.build;\n    }\n    if (env.watch) {\n        oper = oper | TaskConfig_1.Operation.watch;\n    }\n    if (env.test) {\n        oper = oper | TaskConfig_1.Operation.test;\n    }\n    if (env.serve) {\n        oper = oper | TaskConfig_1.Operation.serve;\n    }\n    if (env.e2e) {\n        oper = oper | TaskConfig_1.Operation.e2e;\n    }\n    return oper;\n}\nexports.currentOperation = currentOperation;\n/**\n * get assert source.\n *\n * @param {IAssertDist} assert\n * @param {Operation} oper\n * @returns\n */\nfunction getAssertSrc(assert, oper) {\n    let src = null;\n    if ((oper & TaskConfig_1.Operation.test) > 0) {\n        src = assert.testSrc;\n    }\n    else if ((oper & TaskConfig_1.Operation.e2e) > 0) {\n        src = assert.e2eSrc;\n    }\n    else if ((oper & TaskConfig_1.Operation.watch) > 0) {\n        src = assert.watchSrc;\n    }\n    else if ((oper & TaskConfig_1.Operation.clean) > 0) {\n        src = assert.cleanSrc || assert.dist;\n    }\n    return src || assert.src;\n}\n/**\n * get dist.\n *\n * @param {IAssertDist} ds\n * @param {ITaskContext} ctx\n * @returns\n */\nfunction getCurrentDist(ds, ctx) {\n    let dist;\n    let env = ctx.env;\n    let oper = ctx.oper;\n    if (env.deploy || (oper & TaskConfig_1.Operation.deploy) > 0) {\n        dist = ds.deployDist || taskStringVal(ds.dist, ctx);\n    }\n    else if (env.release || (oper & TaskConfig_1.Operation.release) > 0) {\n        dist = ds.releaseDist || taskStringVal(ds.dist, ctx);\n    }\n    else if (env.e2e || (oper & TaskConfig_1.Operation.e2e) > 0) {\n        dist = ds.e2eDist || ds.buildDist || taskStringVal(ds.dist, ctx);\n    }\n    else if (env.test || (oper & TaskConfig_1.Operation.test) > 0) {\n        dist = ds.testDist || ds.buildDist || taskStringVal(ds.dist, ctx);\n    }\n    else if ((oper & TaskConfig_1.Operation.build) > 0) {\n        dist = ds.buildDist || taskStringVal(ds.dist, ctx);\n    }\n    return dist;\n}\n/**\n * filter fileName in directory.\n *\n * @export\n * @param {string} directory\n * @param {((fileName: string) => boolean)} [express]\n * @returns {string[]}\n */\nfunction files(express, filter, mapping) {\n    return Promise.resolve(globby(express))\n        .then((files) => {\n        if (filter) {\n            files = _.filter(files, filter);\n        }\n        if (mapping) {\n            files = _.map(files, mapping);\n        }\n        return files;\n    });\n}\nexports.files = files;\n/**\n * task src, string or array string.\n *\n * @export\n * @param {TaskSource} src\n * @param {Operation} oper runtime Operation\n * @param {IEnvOption} [env]\n * @returns\n */\nfunction taskSourceVal(src, ctx) {\n    return _.isFunction(src) ? src(ctx) : (src || '');\n}\nexports.taskSourceVal = taskSourceVal;\n/**\n * task string.\n *\n * @export\n * @param {TaskString} name\n * @param {ITaskContext} ctx\n * @returns\n */\nfunction taskStringVal(name, ctx) {\n    return _.isFunction(name) ? name(ctx) : (name || '');\n}\nexports.taskStringVal = taskStringVal;\n","import * as _ from 'lodash';\r\nimport { Gulp } from 'gulp';\r\nimport {\r\n    ITask, ITaskDefine, TaskResult, IAssertDist, IEnvOption, Operation, ITaskContext\r\n    , ITaskConfig, ITaskInfo, Src, TaskSource, IAsserts, TaskString, folderCallback\r\n} from './TaskConfig';\r\nimport { generateTask } from './generateTask';\r\nimport { runSequence, addToSequence } from './taskSequence';\r\nimport { matchCompare, absoluteSrc, absolutePath } from './utils';\r\nimport { findTasksInModule, findTaskDefineInModule, findTasksInDir, findTaskDefineInDir } from './decorator';\r\nimport * as path from 'path';\r\nimport * as fs from 'fs';\r\nconst globby = require('globby');\r\n\r\n/**\r\n * binding Config, create task context.\r\n * \r\n * @export\r\n * @param {ITaskConfig} cfg\r\n * @param {ITaskContext} [parent]\r\n * @returns {ITaskContext}\r\n */\r\nexport function bindingConfig(cfg: ITaskConfig, parent?: ITaskContext): ITaskContext {\r\n    if (cfg.createContext) {\r\n        return cfg.createContext(cfg, parent);\r\n    }\r\n    return new TaskContext(cfg, parent);\r\n}\r\n\r\n/**\r\n * global data.\r\n */\r\nlet globals = {};\r\n\r\n/**\r\n * TaskContext\r\n * \r\n * @export\r\n * @class TaskContext\r\n * @implements {ITaskContext}\r\n */\r\nexport class TaskContext implements ITaskContext {\r\n    public oper: Operation;\r\n    public option: IAsserts;\r\n    public env: IEnvOption;\r\n    public globals: any;\r\n    protected setupTasks: ITask[] = [];\r\n    protected children: ITaskContext[] = [];\r\n    constructor(private cfg: ITaskConfig, public parent?: ITaskContext) {\r\n        this.env = cfg.env;\r\n        this.oper = currentOperation(cfg.env);\r\n        this.option = cfg.option;\r\n        this.globals = cfg.globals || globals;\r\n    }\r\n\r\n    /**\r\n     * add sub ITaskContext\r\n     * \r\n     * @param {ITaskContext} context\r\n     * \r\n     * @memberOf ITaskContext\r\n     */\r\n    add(context: ITaskContext): void {\r\n        context.parent = this;\r\n        this.children.push(context);\r\n    }\r\n    /**\r\n     * remove sub ITaskContext.\r\n     * \r\n     * @param {ITaskContext} [context]\r\n     * \r\n     * @memberOf ITaskContext\r\n     */\r\n    remove(context?: ITaskContext): ITaskContext[] {\r\n        let items = _.remove(this.children, context);\r\n        _.each(items, i => {\r\n            if (i) {\r\n                i.parent = null;\r\n            }\r\n        });\r\n        return items;\r\n    }\r\n\r\n    /**\r\n     * find sub context via express.\r\n     * \r\n     * @param {(ITaskContext | ((item: ITaskContext) => boolean))} express\r\n     * @param {string} [mode] {enum:['route','children', traverse']} default traverse.\r\n     * @returns {ITaskContext}\r\n     * \r\n     * @memberOf ITaskContext\r\n     */\r\n    find(express: ITaskContext | ((item: ITaskContext) => boolean), mode?: string): ITaskContext {\r\n        let context: ITaskContext;\r\n        this.each(item => {\r\n            if (context) {\r\n                return false;\r\n            }\r\n            let isFinded = _.isFunction(express) ? express(item) : (<ITaskContext>express) === item;\r\n            if (isFinded) {\r\n                context = item;\r\n                return false;\r\n            }\r\n            return true;\r\n        }, mode);\r\n        return context;\r\n    }\r\n\r\n    /**\r\n     * filter items.\r\n     * \r\n     * @param {(((item: ITaskContext) => void | boolean))} express\r\n     * @param {string} [mode] {enum:['route','children', traverse']} default traverse.\r\n     * @returns {ITaskContext[]}\r\n     * \r\n     * @memberOf ITaskContext\r\n     */\r\n    filter(express: ((item: ITaskContext) => void | boolean), mode?: string): ITaskContext[] {\r\n        let contexts: ITaskContext[] = [];\r\n        this.each(item => {\r\n            if (express(item)) {\r\n                contexts.push(item);\r\n            }\r\n        }, mode);\r\n        return contexts;\r\n    }\r\n    /**\r\n     * find parent context via express.\r\n     * \r\n     * @param {(ITaskContext | ((item: ITaskContext) => boolean))} express\r\n     * @param {string} [mode] {enum:['route','children', traverse']} default traverse.\r\n     * \r\n     * @memberOf ITaskContext\r\n     */\r\n    each(express: ((item: ITaskContext) => void | boolean), mode?: string) {\r\n        mode = mode || '';\r\n        let r;\r\n        switch (mode) {\r\n            case 'route':\r\n                r = this.route(express);\r\n                break;\r\n            case 'children':\r\n                r = this.eachChildren(express);\r\n                break;\r\n\r\n            case 'traverse':\r\n                r = this.trans(express);\r\n                break;\r\n            default:\r\n                r = this.trans(express);\r\n                break;\r\n        }\r\n        return r;\r\n    }\r\n\r\n    eachChildren(express: ((item: ITaskContext) => void | boolean)) {\r\n        _.each(this.children, item => {\r\n            return express(item);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * do express work in routing.\r\n     * \r\n     * @param {(((item: ITaskContext) => void | boolean))} express\r\n     * \r\n     * @memberOf ITaskContext\r\n     */\r\n    route(express: ((item: ITaskContext) => void | boolean)) {\r\n        if (!express(this)) {\r\n            return false;\r\n        };\r\n        if (this.parent && this.parent.route) {\r\n            return this.parent.route(express);\r\n        }\r\n    }\r\n    /**\r\n     * translate all sub context to do express work.\r\n     * \r\n     * @param {(((item: ITaskContext) => void | boolean))} express\r\n     * \r\n     * @memberOf ITaskContext\r\n     */\r\n    trans(express: ((item: ITaskContext) => void | boolean)) {\r\n        if (express(this) === false) {\r\n            return false;\r\n        }\r\n        _.each(this.children, item => {\r\n            return item.trans(express);\r\n        });\r\n        return true;\r\n    }\r\n\r\n    matchCompare(task: ITaskInfo, match: ITaskInfo): boolean {\r\n        if (this.option.match) {\r\n            return this.option.match(task, match);\r\n        }\r\n        return matchCompare(task, match);\r\n    }\r\n\r\n    getSrc(task?: ITaskInfo, relative = false): Src {\r\n        let src: Src;\r\n        let ctx = this;\r\n        let oper = task ? (task.oper || ctx.oper) : ctx.oper;\r\n        if (task && task.assert) {\r\n            src = taskSourceVal(getAssertSrc(task.assert, oper), ctx)\r\n        }\r\n\r\n        if (!src) {\r\n            this.route(c => {\r\n                src = taskSourceVal(getAssertSrc(c.option, oper), c);\r\n                if (src) {\r\n                    return false;\r\n                }\r\n                return true;\r\n            });\r\n        }\r\n        return (relative !== false) ? src : absoluteSrc(ctx.env.root, src);\r\n    }\r\n\r\n    getDist(task?: ITaskInfo, relative = false): string {\r\n        let dist: string;\r\n        let ctx = this;\r\n        // let oper = task ? (task.oper || context.oper) : context.oper;\r\n        if (task && task.assert) {\r\n            dist = getCurrentDist(task.assert, ctx);\r\n        }\r\n        if (!dist) {\r\n            this.route(c => {\r\n                dist = getCurrentDist(c.option, c);\r\n                if (dist) {\r\n                    return false;\r\n                }\r\n                return true;\r\n            });\r\n        }\r\n\r\n        return (relative !== false) ? dist : absolutePath(ctx.env.root, dist);\r\n    }\r\n\r\n    subTaskName(task, ext = '') {\r\n        let ctx = this;\r\n        let name = '';\r\n        // let oper = context.oper;\r\n        if (_.isString(task)) {\r\n            name = task;\r\n        } else if (task && task !== ctx.option) {\r\n            // oper = task.oper || context.oper;\r\n            if (task.name) {\r\n                name = taskStringVal(task.name, ctx)\r\n            }\r\n            if (!name && task.assert && task.assert.name) {\r\n                name = taskStringVal(task.assert.name, ctx)\r\n            }\r\n        }\r\n        let optName: string;\r\n        this.route(c => {\r\n            optName = taskStringVal(c.option.name, c);\r\n            if (optName) {\r\n                return false;\r\n            }\r\n            return true;\r\n        })\r\n\r\n        if (optName) {\r\n            if (name.indexOf(optName + '-') === 0) {\r\n                return name;\r\n            }\r\n            // avoid soma name.\r\n            if (name && optName !== name) {\r\n                return `${optName}-${name}` + ext;\r\n            }\r\n            return optName + ext;\r\n        } else {\r\n            return name + ext;\r\n        }\r\n    }\r\n\r\n    printHelp(lang: string): void {\r\n        if (this.cfg.printHelp) {\r\n            this.cfg.printHelp(lang);\r\n        }\r\n    }\r\n\r\n    findTasks(module: string | Object, match?: ITaskInfo): Promise<ITask[]> {\r\n        let ctx = this;\r\n        return findTasksInModule(module, _.extend({ oper: ctx.oper }, match || {}), this);\r\n    }\r\n\r\n    findTasksInDir(dirs: Src, match?: ITaskInfo): Promise<ITask[]> {\r\n        let ctx = this;\r\n        return findTasksInDir(dirs, _.extend({ oper: ctx.oper }, match || {}), this);\r\n    }\r\n\r\n    findTaskDefine(module: string | Object): Promise<ITaskDefine> {\r\n        return findTaskDefineInModule(module);\r\n    }\r\n\r\n    findTaskDefineInDir(dirs: Src): Promise<ITaskDefine> {\r\n        return findTaskDefineInDir(dirs);\r\n    }\r\n\r\n    fileFilter(express: Src, filter?: (fileName: string) => boolean, mapping?: (filename: string) => string): Promise<string[]> {\r\n        return files(express, filter, mapping);\r\n    }\r\n\r\n    runSequence(gulp: Gulp, tasks: Src[]): Promise<any> {\r\n        return runSequence(gulp, tasks);\r\n    }\r\n\r\n    generateTask(tasks, match?) {\r\n        let ctx = this;\r\n        return generateTask(tasks, _.extend({ oper: ctx.oper }, match || {}), this);\r\n    }\r\n\r\n    addToSequence(sequence: Src[], task: ITaskInfo): Src[] {\r\n        if (this.cfg.addToSequence) {\r\n            return this.cfg.addToSequence(sequence, task);\r\n        }\r\n        return addToSequence(sequence, task, this);\r\n    }\r\n\r\n    getRootPath() {\r\n        return this.env.root;\r\n    }\r\n\r\n    getRootFolders(express?: folderCallback): string[] {\r\n        return this.getFolders(this.getRootPath(), express);\r\n    }\r\n\r\n    getFolders(pathstr: string, express?: folderCallback): string[] {\r\n        let dir = fs.readdirSync(pathstr);\r\n        let folders = [];\r\n        _.each(dir, (d: string) => {\r\n            let sf = path.join(pathstr, d);\r\n            let f = fs.lstatSync(sf);\r\n            if (f.isDirectory()) {\r\n                if (express) {\r\n                    let fl = express(sf, d, this);\r\n                    if (fl) {\r\n                        folders.push(fl);\r\n                    }\r\n                } else {\r\n                    folders.push(sf);\r\n                }\r\n            }\r\n        });\r\n        return folders;\r\n    }\r\n\r\n    getDistFolders(express?: folderCallback, task?: ITaskInfo): string[] {\r\n        return this.getFolders(this.getDist(task), express);\r\n    }\r\n\r\n    toRootSrc(src: Src): Src {\r\n        return absoluteSrc(this.cfg.env.root, src);\r\n    }\r\n\r\n    toRootPath(pathstr: string): string {\r\n        return absolutePath(this.cfg.env.root, pathstr);\r\n    }\r\n\r\n    toDistSrc(src: Src, task?: ITaskInfo): Src {\r\n        return absoluteSrc(this.getDist(task), src);\r\n    }\r\n\r\n    toDistPath(pathstr: string, task?: ITaskInfo): string {\r\n        return absolutePath(this.getDist(task), pathstr);\r\n    }\r\n\r\n    toSrc(source: TaskSource): Src {\r\n        return taskSourceVal(source, this);\r\n    }\r\n\r\n    toStr(name: TaskString): string {\r\n        return taskStringVal(name, this);\r\n    }\r\n\r\n    toUrl(basePath: string, toPath?: string): string {\r\n        return (toPath ? path.relative(basePath, toPath) : basePath).replace(/\\\\/g, '/').replace(/^\\//g, '');\r\n    }\r\n\r\n    private packages = {};\r\n    getPackage(filename?: TaskString): any {\r\n        filename = filename || this.cfg.packageFile;\r\n        let name = this.toRootPath(this.toStr(filename) || 'package.json');\r\n        if (!this.packages[name]) {\r\n            this.packages[name] = require(name);\r\n        }\r\n        return this.packages[name]\r\n    }\r\n\r\n    setup(task: ITask, gulp?: Gulp): TaskResult {\r\n        let rs = task.setup(this, gulp);\r\n        this.setupTasks.push(task);\r\n        return rs;\r\n    }\r\n\r\n    tasks(express?: (item: ITask) => boolean): ITask[] {\r\n        return express ? _.filter(this.setupTasks, express) : this.setupTasks;\r\n    }\r\n\r\n    registerTasks(express?: (item: ITask) => boolean): ITask[] {\r\n        let tasks = [];\r\n        this.each(c => {\r\n            tasks = tasks.concat(c.tasks(express));\r\n        });\r\n        return tasks;\r\n    }\r\n\r\n    globalTasks(): string[] {\r\n        return _.keys(this.globals.tasks || {});\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * get current env Operation.\r\n * \r\n * @export\r\n * @param {EnvOption} env\r\n * @returns\r\n */\r\nexport function currentOperation(env: IEnvOption) {\r\n    let oper: Operation;\r\n    if (env.deploy) {\r\n        oper = Operation.deploy;\r\n    } else if (env.release) {\r\n        oper = Operation.release;\r\n    } else {\r\n        oper = Operation.build;\r\n    }\r\n\r\n    if (env.watch) {\r\n        oper = oper | Operation.watch;\r\n    }\r\n    if (env.test) {\r\n        oper = oper | Operation.test;\r\n    }\r\n    if (env.serve) {\r\n        oper = oper | Operation.serve;\r\n    }\r\n    if (env.e2e) {\r\n        oper = oper | Operation.e2e;\r\n    }\r\n\r\n    return oper;\r\n}\r\n\r\n/**\r\n * get assert source.\r\n * \r\n * @param {IAssertDist} assert\r\n * @param {Operation} oper\r\n * @returns\r\n */\r\nfunction getAssertSrc(assert: IAssertDist, oper: Operation) {\r\n    let src = null;\r\n\r\n    if ((oper & Operation.test) > 0) {\r\n        src = assert.testSrc;\r\n    } else if ((oper & Operation.e2e) > 0) {\r\n        src = assert.e2eSrc;\r\n    } else if ((oper & Operation.watch) > 0) {\r\n        src = assert.watchSrc;\r\n    } else if ((oper & Operation.clean) > 0) {\r\n        src = assert.cleanSrc || assert.dist;\r\n    }\r\n\r\n\r\n    return src || assert.src;\r\n}\r\n\r\n/**\r\n * get dist.\r\n * \r\n * @param {IAssertDist} ds\r\n * @param {ITaskContext} ctx\r\n * @returns\r\n */\r\nfunction getCurrentDist(ds: IAssertDist, ctx: ITaskContext) {\r\n    let dist: string;\r\n    let env = ctx.env;\r\n    let oper = ctx.oper;\r\n    if (env.deploy || (oper & Operation.deploy) > 0) {\r\n        dist = ds.deployDist || taskStringVal(ds.dist, ctx);\r\n    } else if (env.release || (oper & Operation.release) > 0) {\r\n        dist = ds.releaseDist || taskStringVal(ds.dist, ctx);\r\n    } else if (env.e2e || (oper & Operation.e2e) > 0) {\r\n        dist = ds.e2eDist || ds.buildDist || taskStringVal(ds.dist, ctx);\r\n    } else if (env.test || (oper & Operation.test) > 0) {\r\n        dist = ds.testDist || ds.buildDist || taskStringVal(ds.dist, ctx);\r\n    } else if ((oper & Operation.build) > 0) {\r\n        dist = ds.buildDist || taskStringVal(ds.dist, ctx);\r\n    }\r\n\r\n    return dist;\r\n}\r\n\r\n\r\n/**\r\n * filter fileName in directory.\r\n * \r\n * @export\r\n * @param {string} directory\r\n * @param {((fileName: string) => boolean)} [express]\r\n * @returns {string[]}\r\n */\r\nexport function files(express: Src, filter?: (fileName: string) => boolean, mapping?: (filename: string) => string): Promise<string[]> {\r\n    return Promise.resolve(globby(express))\r\n        .then((files: string[]) => {\r\n            if (filter) {\r\n                files = _.filter(files, filter)\r\n            }\r\n            if (mapping) {\r\n                files = _.map(files, mapping);\r\n            }\r\n            return files;\r\n        })\r\n}\r\n\r\n/**\r\n * task src, string or array string.\r\n * \r\n * @export\r\n * @param {TaskSource} src\r\n * @param {Operation} oper runtime Operation\r\n * @param {IEnvOption} [env]\r\n * @returns\r\n */\r\nexport function taskSourceVal(src: TaskSource, ctx: ITaskContext) {\r\n    return _.isFunction(src) ? src(ctx) : (src || '');\r\n}\r\n\r\n/**\r\n * task string.\r\n * \r\n * @export\r\n * @param {TaskString} name\r\n * @param {ITaskContext} ctx\r\n * @returns\r\n */\r\nexport function taskStringVal(name: TaskString, ctx: ITaskContext) {\r\n    return _.isFunction(name) ? name(ctx) : (name || '');\r\n}\r\n"]}