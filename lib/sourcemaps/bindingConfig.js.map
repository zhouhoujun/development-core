{"version":3,"sources":["bindingConfig.js","bindingConfig.ts"],"names":["_","require","TaskConfig_1","generateTask_1","taskSequence_1","utils_1","decorator_1","path","fs","globby","bindingConfig","cfg","parent","createContext","TaskContext","exports","globals","setupTasks","packages","env","oper","currentOperation","option","task","match","matchCompare","relative","src","ctx","assert","taskSourceVal","getAssertSrc","absoluteSrc","root","dist","getCurrentDist","absolutePath","ext","name","isString","taskStringVal","optName","indexOf","lang","printHelp","module","findTasksInModule","extend","dirs","findTasksInDir","findTaskDefineInModule","findTaskDefineInDir","express","filter","mapping","files","gulp","tasks","runSequence","generateTask","sequence","addToSequence","getFolders","getRootPath","pathstr","dir","readdirSync","folders","each","d","sf","join","f","lstatSync","isDirectory","fl","push","getDist","source","basePath","toPath","replace","filename","packageFile","toRootPath","toStr","rs","setup","keys","deploy","Operation","release","build","watch","test","serve","e2e","testSrc","e2eSrc","watchSrc","clean","cleanSrc","ds","deployDist","releaseDist","e2eDist","buildDist","testDist","Promise","resolve","then","map","isFunction"],"mappings":"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","file":"../bindingConfig.js","sourcesContent":["\"use strict\";\nconst _ = require('lodash');\nconst TaskConfig_1 = require('./TaskConfig');\nconst generateTask_1 = require('./generateTask');\nconst taskSequence_1 = require('./taskSequence');\nconst utils_1 = require('./utils');\nconst decorator_1 = require('./decorator');\nconst path = require('path');\nconst fs = require('fs');\nconst globby = require('globby');\n/**\n * binding Config, create task context.\n *\n * @export\n * @param {ITaskConfig} cfg\n * @param {ITaskContext} [parent]\n * @returns {ITaskContext}\n */\nfunction bindingConfig(cfg, parent) {\n    if (cfg.createContext) {\n        return cfg.createContext(cfg, parent);\n    }\n    return new TaskContext(cfg, parent);\n}\nexports.bindingConfig = bindingConfig;\n/**\n * global data.\n */\nlet globals = {};\n/**\n * TaskContext\n *\n * @export\n * @class TaskContext\n * @implements {ITaskContext}\n */\nclass TaskContext {\n    constructor(cfg, parent) {\n        this.cfg = cfg;\n        this.parent = parent;\n        this.setupTasks = [];\n        this.packages = {};\n        this.env = cfg.env;\n        this.oper = currentOperation(cfg.env);\n        this.option = cfg.option;\n        this.globals = cfg.globals || globals;\n    }\n    matchCompare(task, match) {\n        if (this.option.match) {\n            return this.option.match(task, match);\n        }\n        return utils_1.matchCompare(task, match);\n    }\n    getSrc(task, relative = false) {\n        let src;\n        let ctx = this;\n        let oper = task ? (task.oper || ctx.oper) : ctx.oper;\n        if (task && task.assert) {\n            src = taskSourceVal(getAssertSrc(task.assert, oper), ctx);\n        }\n        if (!src) {\n            src = taskSourceVal(getAssertSrc(ctx.option, oper), ctx);\n        }\n        return (relative !== false) ? src : utils_1.absoluteSrc(ctx.env.root, src);\n    }\n    getDist(task, relative = false) {\n        let dist;\n        let ctx = this;\n        // let oper = task ? (task.oper || context.oper) : context.oper;\n        if (task && task.assert) {\n            dist = getCurrentDist(task.assert, ctx);\n        }\n        dist = dist || getCurrentDist(ctx.option, ctx);\n        return (relative !== false) ? dist : utils_1.absolutePath(ctx.env.root, dist);\n    }\n    subTaskName(task, ext = '') {\n        let ctx = this;\n        let name = '';\n        // let oper = context.oper;\n        if (_.isString(task)) {\n            name = task;\n        }\n        else if (task && task !== ctx.option) {\n            // oper = task.oper || context.oper;\n            if (task.name) {\n                name = taskStringVal(task.name, ctx);\n            }\n            if (!name && task.assert && task.assert.name) {\n                name = taskStringVal(task.assert.name, ctx);\n            }\n        }\n        let optName = taskStringVal(ctx.option.name, ctx);\n        if (optName) {\n            if (name.indexOf(optName + '-') === 0) {\n                return name;\n            }\n            // avoid soma name.\n            if (name && optName !== name) {\n                return `${optName}-${name}` + ext;\n            }\n            return optName + ext;\n        }\n        else {\n            return name + ext;\n        }\n    }\n    printHelp(lang) {\n        if (this.cfg.printHelp) {\n            this.cfg.printHelp(lang);\n        }\n    }\n    findTasks(module, match) {\n        let ctx = this;\n        return decorator_1.findTasksInModule(module, _.extend({ oper: ctx.oper }, match || {}), this);\n    }\n    findTasksInDir(dirs, match) {\n        let ctx = this;\n        return decorator_1.findTasksInDir(dirs, _.extend({ oper: ctx.oper }, match || {}), this);\n    }\n    findTaskDefine(module) {\n        return decorator_1.findTaskDefineInModule(module);\n    }\n    findTaskDefineInDir(dirs) {\n        return decorator_1.findTaskDefineInDir(dirs);\n    }\n    fileFilter(express, filter, mapping) {\n        return files(express, filter, mapping);\n    }\n    runSequence(gulp, tasks) {\n        return taskSequence_1.runSequence(gulp, tasks);\n    }\n    generateTask(tasks, match) {\n        let ctx = this;\n        return generateTask_1.generateTask(tasks, _.extend({ oper: ctx.oper }, match || {}), this);\n    }\n    addToSequence(sequence, task) {\n        if (this.cfg.addToSequence) {\n            return this.cfg.addToSequence(sequence, task);\n        }\n        return taskSequence_1.addToSequence(sequence, task, this);\n    }\n    getRootPath() {\n        return this.env.root;\n    }\n    getRootFolders(express) {\n        return this.getFolders(this.getRootPath(), express);\n    }\n    getFolders(pathstr, express) {\n        let dir = fs.readdirSync(pathstr);\n        let folders = [];\n        _.each(dir, (d) => {\n            let sf = path.join(pathstr, d);\n            let f = fs.lstatSync(sf);\n            if (f.isDirectory()) {\n                if (express) {\n                    let fl = express(sf, d, this);\n                    if (fl) {\n                        folders.push(fl);\n                    }\n                }\n                else {\n                    folders.push(sf);\n                }\n            }\n        });\n        return folders;\n    }\n    getDistFolders(express, task) {\n        return this.getFolders(this.getDist(task), express);\n    }\n    toRootSrc(src) {\n        return utils_1.absoluteSrc(this.cfg.env.root, src);\n    }\n    toRootPath(pathstr) {\n        return utils_1.absolutePath(this.cfg.env.root, pathstr);\n    }\n    toDistSrc(src, task) {\n        return utils_1.absoluteSrc(this.getDist(task), src);\n    }\n    toDistPath(pathstr, task) {\n        return utils_1.absolutePath(this.getDist(task), pathstr);\n    }\n    toSrc(source) {\n        return taskSourceVal(source, this);\n    }\n    toStr(name) {\n        return taskStringVal(name, this);\n    }\n    toUrl(basePath, toPath) {\n        return (toPath ? path.relative(basePath, toPath) : basePath).replace(/\\\\/g, '/').replace(/^\\//g, '');\n    }\n    getPackage(filename) {\n        filename = filename || this.cfg.packageFile;\n        let name = this.toRootPath(this.toStr(filename) || 'package.json');\n        if (!this.packages[name]) {\n            this.packages[name] = require(name);\n        }\n        return this.packages[name];\n    }\n    setup(task, gulp) {\n        let rs = task.setup(this, gulp);\n        this.setupTasks.push(task);\n        return rs;\n    }\n    tasks(express) {\n        return express ? _.filter(this.setupTasks, express) : this.setupTasks;\n    }\n    registerTasks(express) {\n        return this.tasks(express);\n    }\n    globalTasks() {\n        return _.keys(this.globals.tasks || {});\n    }\n}\nexports.TaskContext = TaskContext;\n/**\n * get current env Operation.\n *\n * @export\n * @param {EnvOption} env\n * @returns\n */\nfunction currentOperation(env) {\n    let oper;\n    if (env.deploy) {\n        oper = TaskConfig_1.Operation.deploy;\n    }\n    else if (env.release) {\n        oper = TaskConfig_1.Operation.release;\n    }\n    else {\n        oper = TaskConfig_1.Operation.build;\n    }\n    if (env.watch) {\n        oper = oper | TaskConfig_1.Operation.watch;\n    }\n    if (env.test) {\n        oper = oper | TaskConfig_1.Operation.test;\n    }\n    if (env.serve) {\n        oper = oper | TaskConfig_1.Operation.serve;\n    }\n    if (env.e2e) {\n        oper = oper | TaskConfig_1.Operation.e2e;\n    }\n    return oper;\n}\nexports.currentOperation = currentOperation;\n/**\n * get assert source.\n *\n * @param {IAssertDist} assert\n * @param {Operation} oper\n * @returns\n */\nfunction getAssertSrc(assert, oper) {\n    let src = null;\n    if ((oper & TaskConfig_1.Operation.test) > 0) {\n        src = assert.testSrc;\n    }\n    else if ((oper & TaskConfig_1.Operation.e2e) > 0) {\n        src = assert.e2eSrc;\n    }\n    else if ((oper & TaskConfig_1.Operation.watch) > 0) {\n        src = assert.watchSrc;\n    }\n    else if ((oper & TaskConfig_1.Operation.clean) > 0) {\n        src = assert.cleanSrc || assert.dist;\n    }\n    return src || assert.src;\n}\n/**\n * get dist.\n *\n * @param {IAssertDist} ds\n * @param {ITaskContext} ctx\n * @returns\n */\nfunction getCurrentDist(ds, ctx) {\n    let dist;\n    let env = ctx.env;\n    let oper = ctx.oper;\n    if (env.deploy || (oper & TaskConfig_1.Operation.deploy) > 0) {\n        dist = ds.deployDist || taskStringVal(ds.dist, ctx);\n    }\n    else if (env.release || (oper & TaskConfig_1.Operation.release) > 0) {\n        dist = ds.releaseDist || taskStringVal(ds.dist, ctx);\n    }\n    else if (env.e2e || (oper & TaskConfig_1.Operation.e2e) > 0) {\n        dist = ds.e2eDist || ds.buildDist || taskStringVal(ds.dist, ctx);\n    }\n    else if (env.test || (oper & TaskConfig_1.Operation.test) > 0) {\n        dist = ds.testDist || ds.buildDist || taskStringVal(ds.dist, ctx);\n    }\n    else if ((oper & TaskConfig_1.Operation.build) > 0) {\n        dist = ds.buildDist || taskStringVal(ds.dist, ctx);\n    }\n    return dist;\n}\n/**\n * filter fileName in directory.\n *\n * @export\n * @param {string} directory\n * @param {((fileName: string) => boolean)} [express]\n * @returns {string[]}\n */\nfunction files(express, filter, mapping) {\n    return Promise.resolve(globby(express))\n        .then((files) => {\n        if (filter) {\n            files = _.filter(files, filter);\n        }\n        if (mapping) {\n            files = _.map(files, mapping);\n        }\n        return files;\n    });\n}\nexports.files = files;\n/**\n * task src, string or array string.\n *\n * @export\n * @param {TaskSource} src\n * @param {Operation} oper runtime Operation\n * @param {IEnvOption} [env]\n * @returns\n */\nfunction taskSourceVal(src, ctx) {\n    return _.isFunction(src) ? src(ctx) : (src || '');\n}\nexports.taskSourceVal = taskSourceVal;\n/**\n * task string.\n *\n * @export\n * @param {TaskString} name\n * @param {ITaskContext} ctx\n * @returns\n */\nfunction taskStringVal(name, ctx) {\n    return _.isFunction(name) ? name(ctx) : (name || '');\n}\nexports.taskStringVal = taskStringVal;\n","import * as _ from 'lodash';\r\nimport { Gulp } from 'gulp';\r\nimport { ITask, ITaskDefine, TaskResult, IAssertDist, IEnvOption, Operation, ITaskContext\r\n    , ITaskConfig, ITaskInfo, Src, TaskSource, IAsserts, TaskString, folderCallback } from './TaskConfig';\r\nimport { generateTask } from './generateTask';\r\nimport { runSequence, addToSequence } from './taskSequence';\r\nimport { matchCompare, absoluteSrc, absolutePath } from './utils';\r\nimport { findTasksInModule, findTaskDefineInModule, findTasksInDir, findTaskDefineInDir } from './decorator';\r\nimport * as path from 'path';\r\nimport * as fs from 'fs';\r\nconst globby = require('globby');\r\n\r\n/**\r\n * binding Config, create task context.\r\n * \r\n * @export\r\n * @param {ITaskConfig} cfg\r\n * @param {ITaskContext} [parent]\r\n * @returns {ITaskContext}\r\n */\r\nexport function bindingConfig(cfg: ITaskConfig, parent?: ITaskContext): ITaskContext {\r\n    if (cfg.createContext) {\r\n        return cfg.createContext(cfg, parent);\r\n    }\r\n    return new TaskContext(cfg, parent);\r\n}\r\n\r\n/**\r\n * global data.\r\n */\r\nlet globals = {};\r\n\r\n/**\r\n * TaskContext\r\n * \r\n * @export\r\n * @class TaskContext\r\n * @implements {ITaskContext}\r\n */\r\nexport class TaskContext implements ITaskContext {\r\n    public oper: Operation;\r\n    public option: IAsserts;\r\n    public env: IEnvOption;\r\n    public globals: any;\r\n    protected setupTasks: ITask[] = [];\r\n    constructor(private cfg: ITaskConfig, public parent?: ITaskContext) {\r\n        this.env = cfg.env;\r\n        this.oper = currentOperation(cfg.env);\r\n        this.option = cfg.option;\r\n        this.globals = cfg.globals || globals;\r\n    }\r\n\r\n    matchCompare(task: ITaskInfo, match: ITaskInfo): boolean {\r\n        if (this.option.match) {\r\n            return this.option.match(task, match);\r\n        }\r\n        return matchCompare(task, match);\r\n    }\r\n\r\n    getSrc(task?: ITaskInfo, relative = false): Src {\r\n        let src: Src;\r\n        let ctx = this;\r\n        let oper = task ? (task.oper || ctx.oper) : ctx.oper;\r\n        if (task && task.assert) {\r\n            src = taskSourceVal(getAssertSrc(task.assert, oper), ctx)\r\n        }\r\n        if (!src) {\r\n            src = taskSourceVal(getAssertSrc(ctx.option, oper), ctx)\r\n        }\r\n        return (relative !== false) ? src : absoluteSrc(ctx.env.root, src);\r\n    }\r\n\r\n    getDist(task?: ITaskInfo, relative = false) {\r\n        let dist;\r\n        let ctx = this;\r\n        // let oper = task ? (task.oper || context.oper) : context.oper;\r\n        if (task && task.assert) {\r\n            dist = getCurrentDist(task.assert, ctx);\r\n        }\r\n        dist = dist || getCurrentDist(ctx.option, ctx);\r\n\r\n        return (relative !== false) ? dist : absolutePath(ctx.env.root, dist);\r\n    }\r\n\r\n    subTaskName(task, ext = '') {\r\n        let ctx = this;\r\n        let name = '';\r\n        // let oper = context.oper;\r\n        if (_.isString(task)) {\r\n            name = task;\r\n        } else if (task && task !== ctx.option) {\r\n            // oper = task.oper || context.oper;\r\n            if (task.name) {\r\n                name = taskStringVal(task.name, ctx)\r\n            }\r\n            if (!name && task.assert && task.assert.name) {\r\n                name = taskStringVal(task.assert.name, ctx)\r\n            }\r\n        }\r\n\r\n        let optName = taskStringVal(ctx.option.name, ctx);\r\n        if (optName) {\r\n            if (name.indexOf(optName + '-') === 0) {\r\n                return name;\r\n            }\r\n            // avoid soma name.\r\n            if (name && optName !== name) {\r\n                return `${optName}-${name}` + ext;\r\n            }\r\n            return optName + ext;\r\n        } else {\r\n            return name + ext;\r\n        }\r\n    }\r\n\r\n    printHelp(lang: string): void {\r\n        if (this.cfg.printHelp) {\r\n            this.cfg.printHelp(lang);\r\n        }\r\n    }\r\n\r\n    findTasks(module: string | Object, match?: ITaskInfo): Promise<ITask[]> {\r\n        let ctx = this;\r\n        return findTasksInModule(module, _.extend({ oper: ctx.oper }, match || {}), this);\r\n    }\r\n\r\n    findTasksInDir(dirs: Src, match?: ITaskInfo): Promise<ITask[]> {\r\n        let ctx = this;\r\n        return findTasksInDir(dirs, _.extend({ oper: ctx.oper }, match || {}), this);\r\n    }\r\n\r\n    findTaskDefine(module: string | Object): Promise<ITaskDefine> {\r\n        return findTaskDefineInModule(module);\r\n    }\r\n\r\n    findTaskDefineInDir(dirs: Src): Promise<ITaskDefine> {\r\n        return findTaskDefineInDir(dirs);\r\n    }\r\n\r\n    fileFilter(express: Src, filter?: (fileName: string) => boolean, mapping?: (filename: string) => string): Promise<string[]> {\r\n        return files(express, filter, mapping);\r\n    }\r\n\r\n    runSequence(gulp: Gulp, tasks: Src[]): Promise<any> {\r\n        return runSequence(gulp, tasks);\r\n    }\r\n\r\n    generateTask(tasks, match?) {\r\n        let ctx = this;\r\n        return generateTask(tasks, _.extend({ oper: ctx.oper }, match || {}), this);\r\n    }\r\n\r\n    addToSequence(sequence: Src[], task: ITaskInfo): Src[] {\r\n        if (this.cfg.addToSequence) {\r\n            return this.cfg.addToSequence(sequence, task);\r\n        }\r\n        return addToSequence(sequence, task, this);\r\n    }\r\n\r\n    getRootPath() {\r\n        return this.env.root;\r\n    }\r\n\r\n    getRootFolders(express?: folderCallback): string[] {\r\n        return this.getFolders(this.getRootPath(), express);\r\n    }\r\n\r\n    getFolders(pathstr: string, express?: folderCallback): string[] {\r\n        let dir = fs.readdirSync(pathstr);\r\n        let folders = [];\r\n        _.each(dir, (d: string) => {\r\n            let sf = path.join(pathstr, d);\r\n            let f = fs.lstatSync(sf);\r\n            if (f.isDirectory()) {\r\n                if (express) {\r\n                    let fl = express(sf, d, this);\r\n                    if (fl) {\r\n                        folders.push(fl);\r\n                    }\r\n                } else {\r\n                    folders.push(sf);\r\n                }\r\n            }\r\n        });\r\n        return folders;\r\n    }\r\n\r\n    getDistFolders(express?: folderCallback, task?: ITaskInfo): string[] {\r\n        return this.getFolders(this.getDist(task), express);\r\n    }\r\n\r\n    toRootSrc(src: Src): Src {\r\n        return absoluteSrc(this.cfg.env.root, src);\r\n    }\r\n\r\n    toRootPath(pathstr: string): string {\r\n        return absolutePath(this.cfg.env.root, pathstr);\r\n    }\r\n\r\n    toDistSrc(src: Src, task?: ITaskInfo): Src {\r\n        return absoluteSrc(this.getDist(task), src);\r\n    }\r\n\r\n    toDistPath(pathstr: string, task?: ITaskInfo): string {\r\n        return absolutePath(this.getDist(task), pathstr);\r\n    }\r\n\r\n    toSrc(source: TaskSource): Src {\r\n        return taskSourceVal(source, this);\r\n    }\r\n\r\n    toStr(name: TaskString): string {\r\n        return taskStringVal(name, this);\r\n    }\r\n\r\n    toUrl(basePath: string, toPath?: string): string {\r\n        return (toPath ? path.relative(basePath, toPath) : basePath).replace(/\\\\/g, '/').replace(/^\\//g, '');\r\n    }\r\n\r\n    private packages = {};\r\n    getPackage(filename?: TaskString): any {\r\n        filename = filename || this.cfg.packageFile;\r\n        let name = this.toRootPath(this.toStr(filename) || 'package.json');\r\n        if (!this.packages[name]) {\r\n            this.packages[name] = require(name);\r\n        }\r\n        return this.packages[name]\r\n    }\r\n\r\n    setup(task: ITask, gulp?: Gulp): TaskResult {\r\n        let rs = task.setup(this, gulp);\r\n        this.setupTasks.push(task);\r\n        return rs;\r\n    }\r\n\r\n    tasks(express?: (item: ITask) => boolean): ITask[] {\r\n        return express ? _.filter(this.setupTasks, express) : this.setupTasks;\r\n    }\r\n\r\n    registerTasks(express?: (item: ITask) => boolean): ITask[] {\r\n        return this.tasks(express);\r\n    }\r\n\r\n    globalTasks(): string[] {\r\n        return _.keys(this.globals.tasks || {});\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * get current env Operation.\r\n * \r\n * @export\r\n * @param {EnvOption} env\r\n * @returns\r\n */\r\nexport function currentOperation(env: IEnvOption) {\r\n    let oper: Operation;\r\n    if (env.deploy) {\r\n        oper = Operation.deploy;\r\n    } else if (env.release) {\r\n        oper = Operation.release;\r\n    } else {\r\n        oper = Operation.build;\r\n    }\r\n\r\n    if (env.watch) {\r\n        oper = oper | Operation.watch;\r\n    }\r\n    if (env.test) {\r\n        oper = oper | Operation.test;\r\n    }\r\n    if (env.serve) {\r\n        oper = oper | Operation.serve;\r\n    }\r\n    if (env.e2e) {\r\n        oper = oper | Operation.e2e;\r\n    }\r\n\r\n    return oper;\r\n}\r\n\r\n/**\r\n * get assert source.\r\n * \r\n * @param {IAssertDist} assert\r\n * @param {Operation} oper\r\n * @returns\r\n */\r\nfunction getAssertSrc(assert: IAssertDist, oper: Operation) {\r\n    let src = null;\r\n\r\n    if ((oper & Operation.test) > 0) {\r\n        src = assert.testSrc;\r\n    } else if ((oper & Operation.e2e) > 0) {\r\n        src = assert.e2eSrc;\r\n    } else if ((oper & Operation.watch) > 0) {\r\n        src = assert.watchSrc;\r\n    } else if ((oper & Operation.clean) > 0) {\r\n        src = assert.cleanSrc || assert.dist;\r\n    }\r\n\r\n\r\n    return src || assert.src;\r\n}\r\n\r\n/**\r\n * get dist.\r\n * \r\n * @param {IAssertDist} ds\r\n * @param {ITaskContext} ctx\r\n * @returns\r\n */\r\nfunction getCurrentDist(ds: IAssertDist, ctx: ITaskContext) {\r\n    let dist: string;\r\n    let env = ctx.env;\r\n    let oper = ctx.oper;\r\n    if (env.deploy || (oper & Operation.deploy) > 0) {\r\n        dist = ds.deployDist || taskStringVal(ds.dist, ctx);\r\n    } else if (env.release || (oper & Operation.release) > 0) {\r\n        dist = ds.releaseDist || taskStringVal(ds.dist, ctx);\r\n    } else if (env.e2e || (oper & Operation.e2e) > 0) {\r\n        dist = ds.e2eDist || ds.buildDist || taskStringVal(ds.dist, ctx);\r\n    } else if (env.test || (oper & Operation.test) > 0) {\r\n        dist = ds.testDist || ds.buildDist || taskStringVal(ds.dist, ctx);\r\n    } else if ((oper & Operation.build) > 0) {\r\n        dist = ds.buildDist || taskStringVal(ds.dist, ctx);\r\n    }\r\n\r\n    return dist;\r\n}\r\n\r\n\r\n/**\r\n * filter fileName in directory.\r\n * \r\n * @export\r\n * @param {string} directory\r\n * @param {((fileName: string) => boolean)} [express]\r\n * @returns {string[]}\r\n */\r\nexport function files(express: Src, filter?: (fileName: string) => boolean, mapping?: (filename: string) => string): Promise<string[]> {\r\n    return Promise.resolve(globby(express))\r\n        .then((files: string[]) => {\r\n            if (filter) {\r\n                files = _.filter(files, filter)\r\n            }\r\n            if (mapping) {\r\n                files = _.map(files, mapping);\r\n            }\r\n            return files;\r\n        })\r\n}\r\n\r\n/**\r\n * task src, string or array string.\r\n * \r\n * @export\r\n * @param {TaskSource} src\r\n * @param {Operation} oper runtime Operation\r\n * @param {IEnvOption} [env]\r\n * @returns\r\n */\r\nexport function taskSourceVal(src: TaskSource, ctx: ITaskContext) {\r\n    return _.isFunction(src) ? src(ctx) : (src || '');\r\n}\r\n\r\n/**\r\n * task string.\r\n * \r\n * @export\r\n * @param {TaskString} name\r\n * @param {ITaskContext} ctx\r\n * @returns\r\n */\r\nexport function taskStringVal(name: TaskString, ctx: ITaskContext) {\r\n    return _.isFunction(name) ? name(ctx) : (name || '');\r\n}\r\n"]}