{"version":3,"sources":["bindingConfig.ts"],"names":["bindingConfig","cfg","parent","createContext","TaskContext","currentOperation","env","oper","deploy","TaskConfig_1","Operation","release","build","watch","test","serve","e2e","getAssertSrc","assert","src","testSrc","e2eSrc","watchSrc","clean","cleanSrc","dist","getCurrentDist","ds","ctx","taskStringVal","deployDist","releaseDist","e2eDist","testDist","buildDist","files","express","filter","mapping","Promise","resolve","globby","then","_","map","taskSourceVal","isFunction","name","require","generateTask_1","taskSequence_1","utils_1","decorator_1","path","fs","exports","globals","this","setupTasks","children","packages","option","prototype","add","context","push","remove","items","each","i","find","mode","item","isFinded","contexts","r","route","eachChildren","trans","matchCompare","task","match","getSrc","relative","c","absoluteSrc","root","getDist","absolutePath","subTaskName","ext","isString","optName","indexOf","printHelp","lang","findTasks","module","findTasksInModule","extend","findTasksInDir","dirs","findTaskDefine","findTaskDefineInModule","findTaskDefineInDir","fileFilter","runSequence","gulp","tasks","generateTask","addToSequence","sequence","getRootPath","getRootFolders","getFolders","pathstr","_this","dir","readdirSync","folders","d","sf","join","f","lstatSync","isDirectory","fl","getDistFolders","toRootSrc","toRootPath","toDistSrc","toDistPath","to","setting","toSrc","source","toStr","toUrl","basePath","toPath","replace","getPackage","filename","packageFile","setup","rs","registerTasks","concat","globalTasks","keys"],"mappings":"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","file":"../bindingConfig.js","sourcesContent":["import * as _ from 'lodash';\r\nimport { Gulp } from 'gulp';\r\nimport {\r\n    ITask, ITaskDefine, IContextDefine, TaskResult, IAssertDist, IEnvOption, Operation, ITaskContext\r\n    , ITaskConfig, ITaskInfo, Src, TaskSource, IAsserts, TaskString, folderCallback\r\n} from './TaskConfig';\r\nimport { generateTask } from './generateTask';\r\nimport { runSequence, addToSequence } from './taskSequence';\r\nimport { matchCompare, absoluteSrc, absolutePath } from './utils';\r\nimport { findTasksInModule, findTaskDefineInModule, findTasksInDir, findTaskDefineInDir } from './decorator';\r\nimport * as path from 'path';\r\nimport * as fs from 'fs';\r\nconst globby = require('globby');\r\n\r\n/**\r\n * binding Config, create task context.\r\n * \r\n * @export\r\n * @param {ITaskConfig} cfg\r\n * @param {ITaskContext} [parent]\r\n * @returns {ITaskContext}\r\n */\r\nexport function bindingConfig(cfg: ITaskConfig, parent?: ITaskContext): ITaskContext {\r\n    if (cfg.createContext) {\r\n        return cfg.createContext(cfg, parent);\r\n    }\r\n    return new TaskContext(cfg, parent);\r\n}\r\n\r\n/**\r\n * global data.\r\n */\r\nlet globals = {};\r\n\r\n/**\r\n * TaskContext\r\n * \r\n * @export\r\n * @class TaskContext\r\n * @implements {ITaskContext}\r\n */\r\nexport class TaskContext implements ITaskContext {\r\n    public oper: Operation;\r\n    public option: IAsserts;\r\n    public env: IEnvOption;\r\n    public globals: any;\r\n    protected setupTasks: ITask[] = [];\r\n    protected children: ITaskContext[] = [];\r\n    constructor(private cfg: ITaskConfig, public parent?: ITaskContext) {\r\n        this.env = cfg.env;\r\n        this.oper = currentOperation(cfg.env);\r\n        this.option = cfg.option;\r\n        this.globals = cfg.globals || globals;\r\n    }\r\n\r\n    /**\r\n     * add sub ITaskContext\r\n     * \r\n     * @param {ITaskContext} context\r\n     * \r\n     * @memberOf ITaskContext\r\n     */\r\n    add(context: ITaskContext): void {\r\n        context.parent = this;\r\n        this.children.push(context);\r\n    }\r\n    /**\r\n     * remove sub ITaskContext.\r\n     * \r\n     * @param {ITaskContext} [context]\r\n     * \r\n     * @memberOf ITaskContext\r\n     */\r\n    remove(context?: ITaskContext): ITaskContext[] {\r\n        let items = _.remove(this.children, context);\r\n        _.each(items, i => {\r\n            if (i) {\r\n                i.parent = null;\r\n            }\r\n        });\r\n        return items;\r\n    }\r\n\r\n    /**\r\n     * find sub context via express.\r\n     * \r\n     * @param {(ITaskContext | ((item: ITaskContext) => boolean))} express\r\n     * @param {string} [mode] {enum:['route','children', traverse']} default traverse.\r\n     * @returns {ITaskContext}\r\n     * \r\n     * @memberOf ITaskContext\r\n     */\r\n    find(express: ITaskContext | ((item: ITaskContext) => boolean), mode?: string): ITaskContext {\r\n        let context: ITaskContext;\r\n        this.each(item => {\r\n            if (context) {\r\n                return false;\r\n            }\r\n            let isFinded = _.isFunction(express) ? express(item) : (<ITaskContext>express) === item;\r\n            if (isFinded) {\r\n                context = item;\r\n                return false;\r\n            }\r\n            return true;\r\n        }, mode);\r\n        return context;\r\n    }\r\n\r\n    /**\r\n     * filter items.\r\n     * \r\n     * @param {(((item: ITaskContext) => void | boolean))} express\r\n     * @param {string} [mode] {enum:['route','children', traverse']} default traverse.\r\n     * @returns {ITaskContext[]}\r\n     * \r\n     * @memberOf ITaskContext\r\n     */\r\n    filter(express: ((item: ITaskContext) => void | boolean), mode?: string): ITaskContext[] {\r\n        let contexts: ITaskContext[] = [];\r\n        this.each(item => {\r\n            if (express(item)) {\r\n                contexts.push(item);\r\n            }\r\n        }, mode);\r\n        return contexts;\r\n    }\r\n    /**\r\n     * find parent context via express.\r\n     * \r\n     * @param {(ITaskContext | ((item: ITaskContext) => boolean))} express\r\n     * @param {string} [mode] {enum:['route','children', traverse']} default traverse.\r\n     * \r\n     * @memberOf ITaskContext\r\n     */\r\n    each(express: ((item: ITaskContext) => void | boolean), mode?: string) {\r\n        mode = mode || '';\r\n        let r;\r\n        switch (mode) {\r\n            case 'route':\r\n                r = this.route(express);\r\n                break;\r\n            case 'children':\r\n                r = this.eachChildren(express);\r\n                break;\r\n\r\n            case 'traverse':\r\n                r = this.trans(express);\r\n                break;\r\n            default:\r\n                r = this.trans(express);\r\n                break;\r\n        }\r\n        return r;\r\n    }\r\n\r\n    eachChildren(express: ((item: ITaskContext) => void | boolean)) {\r\n        _.each(this.children, item => {\r\n            return express(item);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * do express work in routing.\r\n     * \r\n     * @param {(((item: ITaskContext) => void | boolean))} express\r\n     * \r\n     * @memberOf ITaskContext\r\n     */\r\n    route(express: ((item: ITaskContext) => void | boolean)) {\r\n        if (!express(this)) {\r\n            return false;\r\n        };\r\n        if (this.parent && this.parent.route) {\r\n            return this.parent.route(express);\r\n        }\r\n    }\r\n    /**\r\n     * translate all sub context to do express work.\r\n     * \r\n     * @param {(((item: ITaskContext) => void | boolean))} express\r\n     * \r\n     * @memberOf ITaskContext\r\n     */\r\n    trans(express: ((item: ITaskContext) => void | boolean)) {\r\n        if (express(this) === false) {\r\n            return false;\r\n        }\r\n        _.each(this.children, item => {\r\n            return item.trans(express);\r\n        });\r\n        return true;\r\n    }\r\n\r\n    matchCompare(task: ITaskInfo, match: ITaskInfo): boolean {\r\n        if (this.option.match) {\r\n            return this.option.match(task, match);\r\n        }\r\n        return matchCompare(task, match);\r\n    }\r\n\r\n    getSrc(task?: ITaskInfo, relative = false): Src {\r\n        let src: Src;\r\n        let ctx = this;\r\n        let oper = task ? (task.oper || ctx.oper) : ctx.oper;\r\n        if (task && task.assert) {\r\n            src = taskSourceVal(getAssertSrc(task.assert, oper), ctx)\r\n        }\r\n\r\n        if (!src) {\r\n            this.route(c => {\r\n                src = taskSourceVal(getAssertSrc(c.option, oper), c);\r\n                if (src) {\r\n                    return false;\r\n                }\r\n                return true;\r\n            });\r\n        }\r\n        return (relative !== false) ? src : absoluteSrc(ctx.env.root, src);\r\n    }\r\n\r\n    getDist(task?: ITaskInfo, relative = false): string {\r\n        let dist: string;\r\n        let ctx = this;\r\n        // let oper = task ? (task.oper || context.oper) : context.oper;\r\n        if (task && task.assert) {\r\n            dist = getCurrentDist(task.assert, ctx);\r\n        }\r\n        if (!dist) {\r\n            this.route(c => {\r\n                dist = getCurrentDist(c.option, c);\r\n                if (dist) {\r\n                    return false;\r\n                }\r\n                return true;\r\n            });\r\n        }\r\n\r\n        return (relative !== false) ? dist : absolutePath(ctx.env.root, dist);\r\n    }\r\n\r\n    subTaskName(task, ext = '') {\r\n        let ctx = this;\r\n        let name = '';\r\n        // let oper = context.oper;\r\n        if (_.isString(task)) {\r\n            name = task;\r\n        } else if (task && task !== ctx.option) {\r\n            // oper = task.oper || context.oper;\r\n            if (task.name) {\r\n                name = taskStringVal(task.name, ctx)\r\n            }\r\n            if (!name && task.assert && task.assert.name) {\r\n                name = taskStringVal(task.assert.name, ctx)\r\n            }\r\n        }\r\n        let optName: string;\r\n        this.route(c => {\r\n            optName = taskStringVal(c.option.name, c);\r\n            if (optName) {\r\n                return false;\r\n            }\r\n            return true;\r\n        })\r\n\r\n        if (optName) {\r\n            if (name.indexOf(optName + '-') === 0) {\r\n                return name;\r\n            }\r\n            // avoid soma name.\r\n            if (name && optName !== name) {\r\n                return `${optName}-${name}` + ext;\r\n            }\r\n            return optName + ext;\r\n        } else {\r\n            return name + ext;\r\n        }\r\n    }\r\n\r\n    printHelp(lang: string): void {\r\n        if (this.cfg.printHelp) {\r\n            this.cfg.printHelp(lang);\r\n        }\r\n    }\r\n\r\n    findTasks(module: string | Object, match?: ITaskInfo): Promise<ITask[]> {\r\n        let ctx = this;\r\n        return findTasksInModule(module, _.extend({ oper: ctx.oper }, match || {}), this);\r\n    }\r\n\r\n    findTasksInDir(dirs: Src, match?: ITaskInfo): Promise<ITask[]> {\r\n        let ctx = this;\r\n        return findTasksInDir(dirs, _.extend({ oper: ctx.oper }, match || {}), this);\r\n    }\r\n\r\n    findTaskDefine(module: string | Object): Promise<IContextDefine> {\r\n        return findTaskDefineInModule(module);\r\n    }\r\n\r\n    findTaskDefineInDir(dirs: Src): Promise<IContextDefine> {\r\n        return findTaskDefineInDir(dirs);\r\n    }\r\n\r\n    fileFilter(express: Src, filter?: (fileName: string) => boolean, mapping?: (filename: string) => string): Promise<string[]> {\r\n        return files(express, filter, mapping);\r\n    }\r\n\r\n    runSequence(gulp: Gulp, tasks: Src[]): Promise<any> {\r\n        return runSequence(gulp, tasks);\r\n    }\r\n\r\n    generateTask(tasks, match?) {\r\n        let ctx = this;\r\n        return generateTask(tasks, _.extend({ oper: ctx.oper }, match || {}), this);\r\n    }\r\n\r\n    addToSequence(sequence: Src[], task: ITaskInfo): Src[] {\r\n        if (this.cfg.addToSequence) {\r\n            return this.cfg.addToSequence(sequence, task);\r\n        }\r\n        return addToSequence(sequence, task, this);\r\n    }\r\n\r\n    getRootPath() {\r\n        return this.env.root;\r\n    }\r\n\r\n    getRootFolders(express?: folderCallback): string[] {\r\n        return this.getFolders(this.getRootPath(), express);\r\n    }\r\n\r\n    getFolders(pathstr: string, express?: folderCallback): string[] {\r\n        let dir = fs.readdirSync(pathstr);\r\n        let folders = [];\r\n        _.each(dir, (d: string) => {\r\n            let sf = path.join(pathstr, d);\r\n            let f = fs.lstatSync(sf);\r\n            if (f.isDirectory()) {\r\n                if (express) {\r\n                    let fl = express(sf, d, this);\r\n                    if (fl) {\r\n                        folders.push(fl);\r\n                    }\r\n                } else {\r\n                    folders.push(sf);\r\n                }\r\n            }\r\n        });\r\n        return folders;\r\n    }\r\n\r\n    getDistFolders(express?: folderCallback, task?: ITaskInfo): string[] {\r\n        return this.getFolders(this.getDist(task), express);\r\n    }\r\n\r\n    toRootSrc(src: Src): Src {\r\n        return absoluteSrc(this.cfg.env.root, src);\r\n    }\r\n\r\n    toRootPath(pathstr: string): string {\r\n        return absolutePath(this.cfg.env.root, pathstr);\r\n    }\r\n\r\n    toDistSrc(src: Src, task?: ITaskInfo): Src {\r\n        return absoluteSrc(this.getDist(task), src);\r\n    }\r\n\r\n    toDistPath(pathstr: string, task?: ITaskInfo): string {\r\n        return absolutePath(this.getDist(task), pathstr);\r\n    }\r\n\r\n    to<T>(setting: T | ((ctx: ITaskContext) => T)): T {\r\n        return _.isFunction(setting) ? setting(this) : setting;\r\n    }\r\n\r\n    toSrc(source: TaskSource): Src {\r\n        return taskSourceVal(source, this);\r\n    }\r\n\r\n    toStr(name: TaskString): string {\r\n        return taskStringVal(name, this);\r\n    }\r\n\r\n    toUrl(basePath: string, toPath?: string): string {\r\n        return (toPath ? path.relative(basePath, toPath) : basePath).replace(/\\\\/g, '/').replace(/^\\//g, '');\r\n    }\r\n\r\n    private packages = {};\r\n    getPackage(filename?: TaskString): any {\r\n        filename = filename || this.cfg.packageFile;\r\n        let name = this.toRootPath(this.toStr(filename) || 'package.json');\r\n        if (!this.packages[name]) {\r\n            this.packages[name] = require(name);\r\n        }\r\n        return this.packages[name]\r\n    }\r\n\r\n    setup(task: ITask, gulp?: Gulp): TaskResult {\r\n        let rs = task.setup(this, gulp);\r\n        this.setupTasks.push(task);\r\n        return rs;\r\n    }\r\n\r\n    tasks(express?: (item: ITask) => boolean): ITask[] {\r\n        return express ? _.filter(this.setupTasks, express) : this.setupTasks;\r\n    }\r\n\r\n    registerTasks(express?: (item: ITask) => boolean): ITask[] {\r\n        let tasks = [];\r\n        this.each(c => {\r\n            tasks = tasks.concat(c.tasks(express));\r\n        });\r\n        return tasks;\r\n    }\r\n\r\n    globalTasks(): string[] {\r\n        return _.keys(this.globals.tasks || {});\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * get current env Operation.\r\n * \r\n * @export\r\n * @param {EnvOption} env\r\n * @returns\r\n */\r\nexport function currentOperation(env: IEnvOption) {\r\n    let oper: Operation;\r\n    if (env.deploy) {\r\n        oper = Operation.deploy | Operation.release;\r\n    } else if (env.release) {\r\n        oper = Operation.release;\r\n    } else {\r\n        oper = Operation.build;\r\n    }\r\n\r\n    if (env.watch) {\r\n        oper = oper | Operation.watch;\r\n    }\r\n    if (env.test) {\r\n        oper = oper | Operation.test;\r\n    }\r\n    if (env.serve) {\r\n        oper = oper | Operation.serve;\r\n    }\r\n    if (env.e2e) {\r\n        oper = oper | Operation.e2e;\r\n    }\r\n\r\n    return oper;\r\n}\r\n\r\n/**\r\n * get assert source.\r\n * \r\n * @param {IAssertDist} assert\r\n * @param {Operation} oper\r\n * @returns\r\n */\r\nfunction getAssertSrc(assert: IAssertDist, oper: Operation) {\r\n    let src = null;\r\n\r\n    if ((oper & Operation.test) > 0) {\r\n        src = assert.testSrc;\r\n    } else if ((oper & Operation.e2e) > 0) {\r\n        src = assert.e2eSrc;\r\n    } else if ((oper & Operation.watch) > 0) {\r\n        src = assert.watchSrc;\r\n    } else if ((oper & Operation.clean) > 0) {\r\n        src = assert.cleanSrc || assert.dist;\r\n    }\r\n\r\n\r\n    return src || assert.src;\r\n}\r\n\r\n/**\r\n * get dist.\r\n * \r\n * @param {IAssertDist} ds\r\n * @param {ITaskContext} ctx\r\n * @returns\r\n */\r\nfunction getCurrentDist(ds: IAssertDist, ctx: ITaskContext) {\r\n    let dist: string;\r\n    let env = ctx.env;\r\n    let oper = ctx.oper;\r\n    if (env.deploy || (oper & Operation.deploy) > 0) {\r\n        dist = taskStringVal(ds.deployDist, ctx);\r\n    }\r\n    if (!dist && (env.release || (oper & Operation.release) > 0)) {\r\n        dist = taskStringVal(ds.releaseDist, ctx);\r\n    }\r\n    if (!dist && (env.e2e || (oper & Operation.e2e) > 0)) {\r\n        dist = taskStringVal(ds.e2eDist, ctx);\r\n    }\r\n    if (!dist && (env.test || (oper & Operation.test) > 0)) {\r\n        dist = taskStringVal(ds.testDist, ctx);\r\n    }\r\n    if (!dist && ((oper & Operation.build) > 0)) {\r\n        dist = taskStringVal(ds.buildDist, ctx);\r\n    }\r\n    if (!dist) {\r\n        dist = taskStringVal(ds.dist, ctx);\r\n    }\r\n\r\n    return dist;\r\n}\r\n\r\n\r\n/**\r\n * filter fileName in directory.\r\n * \r\n * @export\r\n * @param {string} directory\r\n * @param {((fileName: string) => boolean)} [express]\r\n * @returns {string[]}\r\n */\r\nexport function files(express: Src, filter?: (fileName: string) => boolean, mapping?: (filename: string) => string): Promise<string[]> {\r\n    return Promise.resolve(globby(express))\r\n        .then((files: string[]) => {\r\n            if (filter) {\r\n                files = _.filter(files, filter)\r\n            }\r\n            if (mapping) {\r\n                files = _.map(files, mapping);\r\n            }\r\n            return files;\r\n        })\r\n}\r\n\r\n/**\r\n * task src, string or array string.\r\n * \r\n * @export\r\n * @param {TaskSource} src\r\n * @param {Operation} oper runtime Operation\r\n * @param {IEnvOption} [env]\r\n * @returns\r\n */\r\nexport function taskSourceVal(src: TaskSource, ctx: ITaskContext) {\r\n    return _.isFunction(src) ? src(ctx) : (src || '');\r\n}\r\n\r\n/**\r\n * task string.\r\n * \r\n * @export\r\n * @param {TaskString} name\r\n * @param {ITaskContext} ctx\r\n * @returns\r\n */\r\nexport function taskStringVal(name: TaskString, ctx: ITaskContext) {\r\n    return _.isFunction(name) ? name(ctx) : (name || '');\r\n}\r\n"]}