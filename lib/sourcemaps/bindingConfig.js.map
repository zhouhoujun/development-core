{"version":3,"sources":["bindingConfig.js","bindingConfig.ts"],"names":["bindingConfig","cfg","currentOperation","env","fileFilter","utils_1","files","runSequence","taskSequence_1","addToSequence","generateTask","tasks","match","generateTask_1","_","extend","createDefaultMatch","findTasks","mdl","decorator_1","findTasksInModule","findTasksInDir","dirs","findTaskDefine","findTaskDefineInModule","bind","findTaskDefineInDir","subTaskName","dt","deft","arguments","length","undefined","name","isString","option","taskStringVal","oper","parentName","getSrc","assert","taskinfo","src","taskSourceVal","getAssertSrc","autoJoinRoot","absoluteSrc","root","getDist","ds","dist","getCurrentDist","absolutePath","toRootSrc","toRootPath","pathstr","deploy","TaskConfig_1","Operation","release","build","watch","test","serve","e2e","default","testSrc","e2eSrc","watchSrc","clean","cleanSrc","buildDist","releaseDist","deployDist","testDist","e2eDist","require","exports","anothor"],"mappings":"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","file":"../bindingConfig.js","sourcesContent":["\"use strict\";\nconst _ = require('lodash');\nconst TaskConfig_1 = require('./TaskConfig');\nconst generateTask_1 = require('./generateTask');\nconst taskSequence_1 = require('./taskSequence');\nconst utils_1 = require('./utils');\nconst decorator_1 = require('./decorator');\n/**\n * binding Config to implement default func.\n *\n * @export\n * @param {TaskConfig} cfg\n * @returns {TaskConfig}\n */\nfunction bindingConfig(cfg) {\n    // if (!cfg.oper) {\n    //     cfg.oper = currentOperation(cfg.env);\n    // }\n    currentOperation(cfg.env, cfg);\n    cfg.fileFilter = cfg.fileFilter || utils_1.files;\n    cfg.runSequence = cfg.runSequence || taskSequence_1.runSequence;\n    cfg.addToSequence = cfg.addToSequence || taskSequence_1.addToSequence;\n    cfg.generateTask = cfg.generateTask || ((tasks, match) => {\n        return generateTask_1.generateTask(tasks, _.extend(createDefaultMatch(cfg), match || {}));\n    });\n    cfg.findTasks = cfg.findTasks || ((mdl, match) => {\n        return decorator_1.findTasksInModule(mdl, _.extend(createDefaultMatch(cfg), match || {}));\n    });\n    cfg.findTasksInDir = cfg.findTasksInDir || ((dirs, match) => {\n        return decorator_1.findTasksInDir(dirs, _.extend(createDefaultMatch(cfg), match || {}));\n    });\n    cfg.findTaskDefine = cfg.findTaskDefine || decorator_1.findTaskDefineInModule.bind(cfg);\n    cfg.findTaskDefineInDir = cfg.findTaskDefineInDir || decorator_1.findTaskDefineInDir.bind(cfg);\n    cfg.subTaskName = cfg.subTaskName || ((dt, deft = '') => {\n        let name = '';\n        if (_.isString(dt)) {\n            name = dt;\n        }\n        else if (dt && cfg.option !== dt) {\n            name = utils_1.taskStringVal(dt.name, cfg.oper);\n        }\n        else {\n            name = deft;\n        }\n        let parentName = utils_1.taskStringVal(cfg.option.name, cfg.oper);\n        return parentName ? `${parentName}-${name}` : name;\n    });\n    cfg.getSrc = cfg.getSrc || ((assert, taskinfo) => {\n        let src;\n        if (assert) {\n            src = utils_1.taskSourceVal(getAssertSrc(assert, taskinfo), cfg.oper);\n        }\n        if (!src) {\n            src = utils_1.taskSourceVal(getAssertSrc(cfg.option, taskinfo), cfg.oper);\n        }\n        return (cfg.autoJoinRoot === false) ? src : utils_1.absoluteSrc(cfg.env.root, src);\n    });\n    cfg.getDist = cfg.getDist || ((ds) => {\n        let dist;\n        if (ds) {\n            dist = getCurrentDist(ds, cfg.oper);\n        }\n        dist = dist || getCurrentDist(cfg.option, cfg.oper);\n        return (cfg.autoJoinRoot === false) ? dist : utils_1.absolutePath(cfg.env.root, dist);\n    });\n    cfg.toRootSrc = cfg.toRootSrc || ((src) => {\n        return utils_1.absoluteSrc(cfg.env.root, src);\n    });\n    cfg.toRootPath = cfg.toRootPath || ((pathstr) => {\n        return utils_1.absolutePath(cfg.env.root, pathstr);\n    });\n    return cfg;\n}\nexports.bindingConfig = bindingConfig;\nlet createDefaultMatch = (cfg) => {\n    let match = { oper: cfg.oper };\n    if (cfg.match) {\n        match.match = (anothor) => {\n            return cfg.match(match, anothor);\n        };\n    }\n    return match;\n};\n/**\n * get current env Operation.\n *\n * @export\n * @param {EnvOption} env\n * @returns\n */\nfunction currentOperation(env, cfg) {\n    let oper;\n    if (env.deploy) {\n        oper = TaskConfig_1.Operation.deploy;\n    }\n    else if (env.release) {\n        oper = TaskConfig_1.Operation.release;\n    }\n    else {\n        oper = TaskConfig_1.Operation.build;\n    }\n    if (env.watch) {\n        oper = oper | TaskConfig_1.Operation.watch;\n    }\n    if (env.test) {\n        oper = oper | TaskConfig_1.Operation.test;\n    }\n    if (env.serve) {\n        oper = oper | TaskConfig_1.Operation.serve;\n    }\n    if (env.e2e) {\n        oper = oper | TaskConfig_1.Operation.e2e;\n    }\n    if (cfg) {\n        cfg.oper = (cfg.oper || 0) | oper;\n        return cfg.oper;\n    }\n    else {\n        return oper;\n    }\n}\nexports.currentOperation = currentOperation;\nfunction getAssertSrc(assert, taskinfo) {\n    let src = null;\n    if (taskinfo) {\n        taskinfo.oper = taskinfo.oper || TaskConfig_1.Operation.default;\n        if ((taskinfo.oper & TaskConfig_1.Operation.test) > 0) {\n            src = assert.testSrc;\n        }\n        else if ((taskinfo.oper & TaskConfig_1.Operation.e2e) > 0) {\n            src = assert.e2eSrc;\n        }\n        else if ((taskinfo.oper & TaskConfig_1.Operation.watch) > 0) {\n            src = assert.watchSrc;\n        }\n        else if ((taskinfo.oper & TaskConfig_1.Operation.clean) > 0) {\n            src = assert.cleanSrc || assert.dist;\n        }\n    }\n    return src || assert.src;\n}\n/**\n * get dist.\n *\n * @param {OutputDist} ds\n * @param {Operation} oper\n * @returns\n */\nfunction getCurrentDist(ds, oper) {\n    let dist;\n    if ((oper & TaskConfig_1.Operation.build) > 0) {\n        dist = ds.buildDist || utils_1.taskStringVal(ds.dist, oper);\n    }\n    else if ((oper & TaskConfig_1.Operation.release) > 0) {\n        dist = ds.releaseDist || utils_1.taskStringVal(ds.dist, oper);\n    }\n    else if ((oper & TaskConfig_1.Operation.deploy) > 0) {\n        dist = ds.deployDist || utils_1.taskStringVal(ds.dist, oper);\n    }\n    else if ((oper & TaskConfig_1.Operation.test) > 0) {\n        dist = ds.testDist || ds.buildDist || utils_1.taskStringVal(ds.dist, oper);\n    }\n    else if ((oper & TaskConfig_1.Operation.e2e) > 0) {\n        dist = ds.e2eDist || ds.buildDist || utils_1.taskStringVal(ds.dist, oper);\n    }\n    return dist;\n}\n","import * as _ from 'lodash';\r\nimport { IAssertDist, IEnvOption, Operation, ITaskConfig, ITaskInfo, Src } from './TaskConfig';\r\nimport { generateTask } from './generateTask';\r\nimport { runSequence, addToSequence } from './taskSequence';\r\nimport { files, taskStringVal, taskSourceVal, absoluteSrc, absolutePath } from './utils';\r\nimport { findTasksInModule, findTaskDefineInModule, findTasksInDir, findTaskDefineInDir } from './decorator';\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * binding Config to implement default func.\r\n * \r\n * @export\r\n * @param {TaskConfig} cfg\r\n * @returns {TaskConfig}\r\n */\r\nexport function bindingConfig(cfg: ITaskConfig): ITaskConfig {\r\n    // if (!cfg.oper) {\r\n    //     cfg.oper = currentOperation(cfg.env);\r\n    // }\r\n    currentOperation(cfg.env, cfg);\r\n\r\n    cfg.fileFilter = cfg.fileFilter || files;\r\n    cfg.runSequence = cfg.runSequence || runSequence;\r\n    cfg.addToSequence = cfg.addToSequence || addToSequence;\r\n    cfg.generateTask = cfg.generateTask || ((tasks, match?) => {\r\n        return generateTask(tasks, _.extend(createDefaultMatch(cfg), match || {}));\r\n    });\r\n\r\n    cfg.findTasks = cfg.findTasks || ((mdl, match?) => {\r\n        return findTasksInModule(mdl, _.extend(createDefaultMatch(cfg), match || {}));\r\n    });\r\n    cfg.findTasksInDir = cfg.findTasksInDir || ((dirs, match?) => {\r\n        return findTasksInDir(dirs, _.extend(createDefaultMatch(cfg), match || {}));\r\n    });\r\n\r\n    cfg.findTaskDefine = cfg.findTaskDefine || findTaskDefineInModule.bind(cfg);\r\n    cfg.findTaskDefineInDir = cfg.findTaskDefineInDir || findTaskDefineInDir.bind(cfg);\r\n\r\n    cfg.subTaskName = cfg.subTaskName || ((dt, deft = '') => {\r\n        let name = '';\r\n        if (_.isString(dt)) {\r\n            name = dt;\r\n        } else if (dt && cfg.option !== dt) {\r\n            name = taskStringVal(dt.name, cfg.oper)\r\n        } else {\r\n            name = deft;\r\n        }\r\n        let parentName = taskStringVal(cfg.option.name, cfg.oper);\r\n\r\n        return parentName ? `${parentName}-${name}` : name;\r\n    });\r\n\r\n    cfg.getSrc = cfg.getSrc || ((assert?: IAssertDist, taskinfo?: ITaskInfo): Src => {\r\n        let src: Src;\r\n        if (assert) {\r\n            src = taskSourceVal(getAssertSrc(assert, taskinfo), cfg.oper)\r\n        }\r\n        if (!src) {\r\n            src = taskSourceVal(getAssertSrc(cfg.option, taskinfo), cfg.oper)\r\n        }\r\n        return (cfg.autoJoinRoot === false) ? src : absoluteSrc(cfg.env.root, src);\r\n    });\r\n\r\n    cfg.getDist = cfg.getDist || ((ds?: IAssertDist) => {\r\n        let dist;\r\n        if (ds) {\r\n            dist = getCurrentDist(ds, cfg.oper);\r\n        }\r\n        dist = dist || getCurrentDist(cfg.option, cfg.oper);\r\n\r\n        return (cfg.autoJoinRoot === false) ? dist : absolutePath(cfg.env.root, dist);\r\n    });\r\n\r\n    cfg.toRootSrc = cfg.toRootSrc || ((src: Src): Src => {\r\n        return absoluteSrc(cfg.env.root, src);\r\n    });\r\n\r\n    cfg.toRootPath = cfg.toRootPath || ((pathstr: string): string => {\r\n        return absolutePath(cfg.env.root, pathstr);\r\n    });\r\n\r\n    return cfg;\r\n}\r\n\r\nlet createDefaultMatch = (cfg: ITaskConfig) => {\r\n    let match: ITaskInfo = { oper: cfg.oper };\r\n    if (cfg.match) {\r\n        match.match = (anothor: ITaskInfo) => {\r\n            return cfg.match(match, anothor);\r\n        }\r\n    }\r\n    return match;\r\n}\r\n\r\n\r\n/**\r\n * get current env Operation.\r\n * \r\n * @export\r\n * @param {EnvOption} env\r\n * @returns\r\n */\r\nexport function currentOperation(env: IEnvOption, cfg?: ITaskConfig) {\r\n    let oper: Operation;\r\n    if (env.deploy) {\r\n        oper = Operation.deploy;\r\n    } else if (env.release) {\r\n        oper = Operation.release;\r\n    } else {\r\n        oper = Operation.build;\r\n    }\r\n\r\n    if (env.watch) {\r\n        oper = oper | Operation.watch;\r\n    }\r\n    if (env.test) {\r\n        oper = oper | Operation.test;\r\n    }\r\n    if (env.serve) {\r\n        oper = oper | Operation.serve;\r\n    }\r\n    if (env.e2e) {\r\n        oper = oper | Operation.e2e;\r\n    }\r\n\r\n\r\n    if (cfg) {\r\n        cfg.oper = (cfg.oper || 0) | oper;\r\n        return cfg.oper;\r\n    } else {\r\n        return oper;\r\n    }\r\n}\r\n\r\n\r\nfunction getAssertSrc(assert: IAssertDist, taskinfo?: ITaskInfo) {\r\n    let src = null;\r\n    if (taskinfo) {\r\n        taskinfo.oper = taskinfo.oper || Operation.default;\r\n        if ((taskinfo.oper & Operation.test) > 0) {\r\n            src = assert.testSrc;\r\n        } else if ((taskinfo.oper & Operation.e2e) > 0) {\r\n            src = assert.e2eSrc;\r\n        } else if ((taskinfo.oper & Operation.watch) > 0) {\r\n            src = assert.watchSrc;\r\n        } else if ((taskinfo.oper & Operation.clean) > 0) {\r\n            src = assert.cleanSrc || assert.dist;\r\n        }\r\n    }\r\n\r\n    return src || assert.src;\r\n}\r\n\r\n/**\r\n * get dist.\r\n * \r\n * @param {OutputDist} ds\r\n * @param {Operation} oper\r\n * @returns\r\n */\r\nfunction getCurrentDist(ds: IAssertDist, oper: Operation) {\r\n    let dist: string;\r\n    if ((oper & Operation.build) > 0) {\r\n        dist = ds.buildDist || taskStringVal(ds.dist, oper);\r\n    } else if ((oper & Operation.release) > 0) {\r\n        dist = ds.releaseDist || taskStringVal(ds.dist, oper);\r\n    } else if ((oper & Operation.deploy) > 0) {\r\n        dist = ds.deployDist || taskStringVal(ds.dist, oper);\r\n    } else if ((oper & Operation.test) > 0) {\r\n        dist = ds.testDist || ds.buildDist || taskStringVal(ds.dist, oper);\r\n    } else if ((oper & Operation.e2e) > 0) {\r\n        dist = ds.e2eDist || ds.buildDist || taskStringVal(ds.dist, oper);\r\n    }\r\n\r\n    return dist;\r\n}\r\n\r\n\r\n"]}