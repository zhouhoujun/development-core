{"version":3,"sources":["bindingConfig.js","bindingConfig.ts"],"names":["bindingConfig","cfg","oper","currentOperation","env","context","globals","option","runTasks","fileFilter","utils_1","files","runSequence","taskSequence_1","addToSequence","generateTask","tasks","match","generateTask_1","_","extend","createDefaultMatch","findTasks","mdl","decorator_1","findTasksInModule","findTasksInDir","dirs","findTaskDefine","findTaskDefineInModule","bind","this","findTaskDefineInDir","subTaskName","task","ext","arguments","length","undefined","name","isString","taskStringVal","assert","optName","indexOf","getSrc","relative","src","taskSourceVal","getAssertSrc","absoluteSrc","root","getDist","dist","getCurrentDist","absolutePath","toRootSrc","toRootPath","pathstr","pipeOption","express","opt","pipe","pipes","source","output","deploy","TaskConfig_1","Operation","release","build","watch","test","serve","e2e","testSrc","e2eSrc","watchSrc","clean","cleanSrc","ds","ctx","deployDist","releaseDist","e2eDist","buildDist","testDist","require","exports","anothor"],"mappings":"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","file":"../bindingConfig.js","sourcesContent":["\"use strict\";\nconst _ = require('lodash');\nconst TaskConfig_1 = require('./TaskConfig');\nconst generateTask_1 = require('./generateTask');\nconst taskSequence_1 = require('./taskSequence');\nconst utils_1 = require('./utils');\nconst decorator_1 = require('./decorator');\n/**\n * binding Config to implement default func.\n *\n * @export\n * @param {ITaskConfig} cfg\n * @returns {ITaskContext}\n */\nfunction bindingConfig(cfg) {\n    let oper = currentOperation(cfg.env);\n    let context = {\n        oper: oper,\n        env: cfg.env,\n        globals: cfg.globals || {},\n        option: cfg.option,\n        runTasks: cfg.runTasks,\n        fileFilter: utils_1.files,\n        runSequence: taskSequence_1.runSequence,\n        addToSequence: cfg.addToSequence || taskSequence_1.addToSequence,\n        generateTask(tasks, match) {\n            return generateTask_1.generateTask(tasks, _.extend(createDefaultMatch(context), match || {}));\n        },\n        findTasks(mdl, match) {\n            return decorator_1.findTasksInModule(mdl, _.extend(createDefaultMatch(context), match || {}));\n        },\n        findTasksInDir(dirs, match) {\n            return decorator_1.findTasksInDir(dirs, _.extend(createDefaultMatch(context), match || {}));\n        },\n        findTaskDefine: decorator_1.findTaskDefineInModule.bind(this),\n        findTaskDefineInDir: decorator_1.findTaskDefineInDir.bind(this),\n        subTaskName(task, ext = '') {\n            let name = '';\n            // let oper = context.oper;\n            if (_.isString(task)) {\n                name = task;\n            }\n            else if (task && task !== context.option) {\n                // oper = task.oper || context.oper;\n                if (task.name) {\n                    name = utils_1.taskStringVal(task.name, context);\n                }\n                if (!name && task.assert && task.assert.name) {\n                    name = utils_1.taskStringVal(task.assert.name, context);\n                }\n            }\n            let optName = utils_1.taskStringVal(cfg.option.name, context);\n            if (optName) {\n                if (name.indexOf(optName + '-') === 0) {\n                    return name;\n                }\n                // avoid soma name.\n                if (name && optName !== name) {\n                    return `${optName}-${name}` + ext;\n                }\n                return optName + ext;\n            }\n            else {\n                return name + ext;\n            }\n        },\n        getSrc(task, relative = false) {\n            let src;\n            let oper = task ? (task.oper || context.oper) : context.oper;\n            if (task && task.assert) {\n                src = utils_1.taskSourceVal(getAssertSrc(task.assert, oper), context);\n            }\n            if (!src) {\n                src = utils_1.taskSourceVal(getAssertSrc(cfg.option, oper), context);\n            }\n            return (relative !== false) ? src : utils_1.absoluteSrc(cfg.env.root, src);\n        },\n        getDist(task, relative = false) {\n            let dist;\n            // let oper = task ? (task.oper || context.oper) : context.oper;\n            if (task && task.assert) {\n                dist = getCurrentDist(task.assert, context);\n            }\n            dist = dist || getCurrentDist(context.option, context);\n            return (relative !== false) ? dist : utils_1.absolutePath(cfg.env.root, dist);\n        },\n        toRootSrc(src) {\n            return utils_1.absoluteSrc(cfg.env.root, src);\n        },\n        toRootPath(pathstr) {\n            return utils_1.absolutePath(cfg.env.root, pathstr);\n        },\n        pipeOption(express) {\n            if (context.option) {\n                let option = context.option;\n                if (option['loader']) {\n                    let opt = option['loader'];\n                    if (opt.pipe || opt.pipes || opt.source || opt.output) {\n                        express(opt);\n                    }\n                }\n                if (option.pipe || option.pipes || option.source || option.output) {\n                    express(option);\n                }\n            }\n        }\n    };\n    return context;\n}\nexports.bindingConfig = bindingConfig;\nlet createDefaultMatch = (ctx) => {\n    let match = { oper: ctx.oper };\n    if (ctx.match) {\n        match.match = (anothor) => {\n            return ctx.match(match, anothor);\n        };\n    }\n    return match;\n};\n/**\n * get current env Operation.\n *\n * @export\n * @param {EnvOption} env\n * @returns\n */\nfunction currentOperation(env) {\n    let oper;\n    if (env.deploy) {\n        oper = TaskConfig_1.Operation.deploy;\n    }\n    else if (env.release) {\n        oper = TaskConfig_1.Operation.release;\n    }\n    else {\n        oper = TaskConfig_1.Operation.build;\n    }\n    if (env.watch) {\n        oper = oper | TaskConfig_1.Operation.watch;\n    }\n    if (env.test) {\n        oper = oper | TaskConfig_1.Operation.test;\n    }\n    if (env.serve) {\n        oper = oper | TaskConfig_1.Operation.serve;\n    }\n    if (env.e2e) {\n        oper = oper | TaskConfig_1.Operation.e2e;\n    }\n    return oper;\n}\nexports.currentOperation = currentOperation;\n/**\n * get assert source.\n *\n * @param {IAssertDist} assert\n * @param {Operation} oper\n * @returns\n */\nfunction getAssertSrc(assert, oper) {\n    let src = null;\n    if ((oper & TaskConfig_1.Operation.test) > 0) {\n        src = assert.testSrc;\n    }\n    else if ((oper & TaskConfig_1.Operation.e2e) > 0) {\n        src = assert.e2eSrc;\n    }\n    else if ((oper & TaskConfig_1.Operation.watch) > 0) {\n        src = assert.watchSrc;\n    }\n    else if ((oper & TaskConfig_1.Operation.clean) > 0) {\n        src = assert.cleanSrc || assert.dist;\n    }\n    return src || assert.src;\n}\n/**\n * get dist.\n *\n * @param {IAssertDist} ds\n * @param {ITaskContext} ctx\n * @returns\n */\nfunction getCurrentDist(ds, ctx) {\n    let dist;\n    let env = ctx.env;\n    let oper = ctx.oper;\n    if (env.deploy || (oper & TaskConfig_1.Operation.deploy) > 0) {\n        dist = ds.deployDist || utils_1.taskStringVal(ds.dist, ctx);\n    }\n    else if (env.release || (oper & TaskConfig_1.Operation.release) > 0) {\n        dist = ds.releaseDist || utils_1.taskStringVal(ds.dist, ctx);\n    }\n    else if (env.e2e || (oper & TaskConfig_1.Operation.e2e) > 0) {\n        dist = ds.e2eDist || ds.buildDist || utils_1.taskStringVal(ds.dist, ctx);\n    }\n    else if (env.test || (oper & TaskConfig_1.Operation.test) > 0) {\n        dist = ds.testDist || ds.buildDist || utils_1.taskStringVal(ds.dist, ctx);\n    }\n    else if ((oper & TaskConfig_1.Operation.build) > 0) {\n        dist = ds.buildDist || utils_1.taskStringVal(ds.dist, ctx);\n    }\n    return dist;\n}\n","import * as _ from 'lodash';\r\nimport { IAssertDist, IEnvOption, Operation, ITaskContext, ITaskConfig, ITaskInfo, Src, IPipeOption } from './TaskConfig';\r\nimport { generateTask } from './generateTask';\r\nimport { runSequence, addToSequence } from './taskSequence';\r\nimport { files, taskStringVal, taskSourceVal, absoluteSrc, absolutePath } from './utils';\r\nimport { findTasksInModule, findTaskDefineInModule, findTasksInDir, findTaskDefineInDir } from './decorator';\r\n\r\n\r\n\r\n\r\n/**\r\n * binding Config to implement default func.\r\n * \r\n * @export\r\n * @param {ITaskConfig} cfg\r\n * @returns {ITaskContext}\r\n */\r\nexport function bindingConfig(cfg: ITaskConfig): ITaskContext {\r\n\r\n    let oper = currentOperation(cfg.env);\r\n\r\n    let context: ITaskContext = <ITaskContext>{\r\n        oper: oper,\r\n\r\n        env: cfg.env,\r\n        globals: cfg.globals || {},\r\n        option: cfg.option,\r\n        runTasks: cfg.runTasks,\r\n\r\n        fileFilter: files,\r\n        runSequence: runSequence,\r\n        addToSequence: cfg.addToSequence || addToSequence,\r\n        generateTask(tasks, match?) {\r\n            return generateTask(tasks, _.extend(createDefaultMatch(context), match || {}));\r\n        },\r\n        findTasks(mdl, match?) {\r\n            return findTasksInModule(mdl, _.extend(createDefaultMatch(context), match || {}));\r\n        },\r\n        findTasksInDir(dirs, match?) {\r\n            return findTasksInDir(dirs, _.extend(createDefaultMatch(context), match || {}));\r\n        },\r\n\r\n        findTaskDefine: findTaskDefineInModule.bind(this),\r\n\r\n        findTaskDefineInDir: findTaskDefineInDir.bind(this),\r\n\r\n        subTaskName(task, ext = '') {\r\n            let name = '';\r\n            // let oper = context.oper;\r\n            if (_.isString(task)) {\r\n                name = task;\r\n            } else if (task && task !== context.option) {\r\n                // oper = task.oper || context.oper;\r\n                if (task.name) {\r\n                    name = taskStringVal(task.name, context)\r\n                }\r\n                if (!name && task.assert && task.assert.name) {\r\n                    name = taskStringVal(task.assert.name, context)\r\n                }\r\n            }\r\n\r\n            let optName = taskStringVal(cfg.option.name, context);\r\n            if (optName) {\r\n                if (name.indexOf(optName + '-') === 0) {\r\n                    return name;\r\n                }\r\n                // avoid soma name.\r\n                if (name && optName !== name) {\r\n                    return `${optName}-${name}` + ext;\r\n                }\r\n                return optName + ext;\r\n            } else {\r\n                return name + ext;\r\n            }\r\n        },\r\n\r\n        getSrc(task: ITaskInfo, relative = false): Src {\r\n            let src: Src;\r\n            let oper = task ? (task.oper || context.oper) : context.oper;\r\n            if (task && task.assert) {\r\n                src = taskSourceVal(getAssertSrc(task.assert, oper), context)\r\n            }\r\n            if (!src) {\r\n                src = taskSourceVal(getAssertSrc(cfg.option, oper), context)\r\n            }\r\n            return (relative !== false) ? src : absoluteSrc(cfg.env.root, src);\r\n        },\r\n\r\n        getDist(task: ITaskInfo, relative = false) {\r\n            let dist;\r\n            // let oper = task ? (task.oper || context.oper) : context.oper;\r\n            if (task && task.assert) {\r\n                dist = getCurrentDist(task.assert, context);\r\n            }\r\n            dist = dist || getCurrentDist(context.option, context);\r\n\r\n            return (relative !== false) ? dist : absolutePath(cfg.env.root, dist);\r\n        },\r\n\r\n        toRootSrc(src: Src): Src {\r\n            return absoluteSrc(cfg.env.root, src);\r\n        },\r\n        toRootPath(pathstr: string): string {\r\n            return absolutePath(cfg.env.root, pathstr);\r\n        },\r\n\r\n        pipeOption(express) {\r\n            if (context.option) {\r\n                let option = context.option;\r\n                if (option['loader']) {\r\n                    let opt = <IPipeOption>option['loader'];\r\n                    if (opt.pipe || opt.pipes || opt.source || opt.output) {\r\n                        express(opt);\r\n                    }\r\n                }\r\n                if (option.pipe || option.pipes || option.source || option.output) {\r\n                    express(option);\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    return context;\r\n}\r\n\r\nlet createDefaultMatch = (ctx: ITaskContext) => {\r\n    let match: ITaskInfo = { oper: ctx.oper };\r\n    if (ctx.match) {\r\n        match.match = (anothor: ITaskInfo) => {\r\n            return ctx.match(match, anothor);\r\n        }\r\n    }\r\n    return match;\r\n}\r\n\r\n\r\n/**\r\n * get current env Operation.\r\n * \r\n * @export\r\n * @param {EnvOption} env\r\n * @returns\r\n */\r\nexport function currentOperation(env: IEnvOption) {\r\n    let oper: Operation;\r\n    if (env.deploy) {\r\n        oper = Operation.deploy;\r\n    } else if (env.release) {\r\n        oper = Operation.release;\r\n    } else {\r\n        oper = Operation.build;\r\n    }\r\n\r\n    if (env.watch) {\r\n        oper = oper | Operation.watch;\r\n    }\r\n    if (env.test) {\r\n        oper = oper | Operation.test;\r\n    }\r\n    if (env.serve) {\r\n        oper = oper | Operation.serve;\r\n    }\r\n    if (env.e2e) {\r\n        oper = oper | Operation.e2e;\r\n    }\r\n\r\n    return oper;\r\n}\r\n\r\n/**\r\n * get assert source.\r\n * \r\n * @param {IAssertDist} assert\r\n * @param {Operation} oper\r\n * @returns\r\n */\r\nfunction getAssertSrc(assert: IAssertDist, oper: Operation) {\r\n    let src = null;\r\n\r\n    if ((oper & Operation.test) > 0) {\r\n        src = assert.testSrc;\r\n    } else if ((oper & Operation.e2e) > 0) {\r\n        src = assert.e2eSrc;\r\n    } else if ((oper & Operation.watch) > 0) {\r\n        src = assert.watchSrc;\r\n    } else if ((oper & Operation.clean) > 0) {\r\n        src = assert.cleanSrc || assert.dist;\r\n    }\r\n\r\n\r\n    return src || assert.src;\r\n}\r\n\r\n/**\r\n * get dist.\r\n * \r\n * @param {IAssertDist} ds\r\n * @param {ITaskContext} ctx\r\n * @returns\r\n */\r\nfunction getCurrentDist(ds: IAssertDist, ctx: ITaskContext) {\r\n    let dist: string;\r\n    let env = ctx.env;\r\n    let oper = ctx.oper;\r\n    if (env.deploy || (oper & Operation.deploy) > 0) {\r\n        dist = ds.deployDist || taskStringVal(ds.dist, ctx);\r\n    } else if (env.release || (oper & Operation.release) > 0) {\r\n        dist = ds.releaseDist || taskStringVal(ds.dist, ctx);\r\n    } else if (env.e2e || (oper & Operation.e2e) > 0) {\r\n        dist = ds.e2eDist || ds.buildDist || taskStringVal(ds.dist, ctx);\r\n    } else if (env.test || (oper & Operation.test) > 0) {\r\n        dist = ds.testDist || ds.buildDist || taskStringVal(ds.dist, ctx);\r\n    } else if ((oper & Operation.build) > 0) {\r\n        dist = ds.buildDist || taskStringVal(ds.dist, ctx);\r\n    }\r\n\r\n    return dist;\r\n}\r\n"]}