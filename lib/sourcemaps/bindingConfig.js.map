{"version":3,"sources":["bindingConfig.js","bindingConfig.ts"],"names":["_","require","TaskConfig_1","generateTask_1","taskSequence_1","utils_1","decorator_1","bindingConfig","cfg","oper","currentOperation","env","context","globals","option","runTasks","fileFilter","files","runSequence","addToSequence","generateTask","tasks","match","extend","createDefaultMatch","findTasks","mdl","findTasksInModule","findTasksInDir","dirs","findTaskDefine","findTaskDefineInModule","bind","findTaskDefineInDir","subTaskName","task","deft","name","isString","n","assert","taskStringVal","parentName","getSrc","relative","src","taskSourceVal","getAssertSrc","absoluteSrc","root","getDist","dist","getCurrentDist","absolutePath","toRootSrc","toRootPath","pathstr","exports","ctx","anothor","deploy","Operation","release","build","watch","test","serve","e2e","testSrc","e2eSrc","watchSrc","clean","cleanSrc","ds","deployDist","releaseDist","e2eDist","buildDist","testDist"],"mappings":"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","file":"../bindingConfig.js","sourcesContent":["\"use strict\";\nconst _ = require('lodash');\nconst TaskConfig_1 = require('./TaskConfig');\nconst generateTask_1 = require('./generateTask');\nconst taskSequence_1 = require('./taskSequence');\nconst utils_1 = require('./utils');\nconst decorator_1 = require('./decorator');\n/**\n * binding Config to implement default func.\n *\n * @export\n * @param {ITaskConfig} cfg\n * @returns {ITaskContext}\n */\nfunction bindingConfig(cfg) {\n    let oper = currentOperation(cfg.env);\n    let context = {\n        oper: oper,\n        env: cfg.env,\n        globals: cfg.globals || {},\n        option: cfg.option,\n        runTasks: cfg.runTasks,\n        fileFilter: utils_1.files,\n        runSequence: taskSequence_1.runSequence,\n        addToSequence: cfg.addToSequence || taskSequence_1.addToSequence,\n        generateTask(tasks, match) {\n            return generateTask_1.generateTask(tasks, _.extend(createDefaultMatch(context), match || {}));\n        },\n        findTasks(mdl, match) {\n            return decorator_1.findTasksInModule(mdl, _.extend(createDefaultMatch(context), match || {}));\n        },\n        findTasksInDir(dirs, match) {\n            return decorator_1.findTasksInDir(dirs, _.extend(createDefaultMatch(context), match || {}));\n        },\n        findTaskDefine: decorator_1.findTaskDefineInModule.bind(this),\n        findTaskDefineInDir: decorator_1.findTaskDefineInDir.bind(this),\n        subTaskName(task, deft = '') {\n            let name = '';\n            // let oper = context.oper;\n            if (_.isString(task)) {\n                name = task;\n            }\n            else if (task && task !== context.option) {\n                // oper = task.oper || context.oper;\n                let n = task.name;\n                if (!n) {\n                    n = task.assert ? task.assert.name : '';\n                }\n                name = utils_1.taskStringVal(n, context.oper, cfg.env);\n            }\n            else {\n                name = deft;\n            }\n            let parentName = utils_1.taskStringVal(cfg.option.name, context.oper, cfg.env);\n            return parentName ? `${parentName}-${name}` : name;\n        },\n        getSrc(task, relative = false) {\n            let src;\n            let oper = task ? (task.oper || context.oper) : context.oper;\n            if (task && task.assert) {\n                src = utils_1.taskSourceVal(getAssertSrc(task.assert, oper), context.oper, cfg.env);\n            }\n            if (!src) {\n                src = utils_1.taskSourceVal(getAssertSrc(cfg.option, oper), context.oper, cfg.env);\n            }\n            return (relative !== false) ? src : utils_1.absoluteSrc(cfg.env.root, src);\n        },\n        getDist(task, relative = false) {\n            let dist;\n            // let oper = task ? (task.oper || context.oper) : context.oper;\n            if (task && task.assert) {\n                dist = getCurrentDist(task.assert, context.oper, cfg.env);\n            }\n            dist = dist || getCurrentDist(context.option, context.oper, cfg.env);\n            return (relative !== false) ? dist : utils_1.absolutePath(cfg.env.root, dist);\n        },\n        toRootSrc(src) {\n            return utils_1.absoluteSrc(cfg.env.root, src);\n        },\n        toRootPath(pathstr) {\n            return utils_1.absolutePath(cfg.env.root, pathstr);\n        }\n    };\n    return context;\n}\nexports.bindingConfig = bindingConfig;\nlet createDefaultMatch = (ctx) => {\n    let match = { oper: ctx.oper };\n    if (ctx.match) {\n        match.match = (anothor) => {\n            return ctx.match(match, anothor);\n        };\n    }\n    return match;\n};\n/**\n * get current env Operation.\n *\n * @export\n * @param {EnvOption} env\n * @returns\n */\nfunction currentOperation(env) {\n    let oper;\n    if (env.deploy) {\n        oper = TaskConfig_1.Operation.deploy;\n    }\n    else if (env.release) {\n        oper = TaskConfig_1.Operation.release;\n    }\n    else {\n        oper = TaskConfig_1.Operation.build;\n    }\n    if (env.watch) {\n        oper = oper | TaskConfig_1.Operation.watch;\n    }\n    if (env.test) {\n        oper = oper | TaskConfig_1.Operation.test;\n    }\n    if (env.serve) {\n        oper = oper | TaskConfig_1.Operation.serve;\n    }\n    if (env.e2e) {\n        oper = oper | TaskConfig_1.Operation.e2e;\n    }\n    return oper;\n}\nexports.currentOperation = currentOperation;\n/**\n * get assert source.\n *\n * @param {IAssertDist} assert\n * @param {Operation} oper\n * @returns\n */\nfunction getAssertSrc(assert, oper) {\n    let src = null;\n    if ((oper & TaskConfig_1.Operation.test) > 0) {\n        src = assert.testSrc;\n    }\n    else if ((oper & TaskConfig_1.Operation.e2e) > 0) {\n        src = assert.e2eSrc;\n    }\n    else if ((oper & TaskConfig_1.Operation.watch) > 0) {\n        src = assert.watchSrc;\n    }\n    else if ((oper & TaskConfig_1.Operation.clean) > 0) {\n        src = assert.cleanSrc || assert.dist;\n    }\n    return src || assert.src;\n}\n/**\n * get dist.\n *\n * @param {OutputDist} ds\n * @param {Operation} oper runtime Operation.\n * @returns\n */\nfunction getCurrentDist(ds, oper, env) {\n    let dist;\n    if (env.deploy || (oper & TaskConfig_1.Operation.deploy) > 0) {\n        dist = ds.deployDist || utils_1.taskStringVal(ds.dist, oper, env);\n    }\n    else if (env.release || (oper & TaskConfig_1.Operation.release) > 0) {\n        dist = ds.releaseDist || utils_1.taskStringVal(ds.dist, oper, env);\n    }\n    else if (env.e2e || (oper & TaskConfig_1.Operation.e2e) > 0) {\n        dist = ds.e2eDist || ds.buildDist || utils_1.taskStringVal(ds.dist, oper, env);\n    }\n    else if (env.test || (oper & TaskConfig_1.Operation.test) > 0) {\n        dist = ds.testDist || ds.buildDist || utils_1.taskStringVal(ds.dist, oper, env);\n    }\n    else if ((oper & TaskConfig_1.Operation.build) > 0) {\n        dist = ds.buildDist || utils_1.taskStringVal(ds.dist, oper, env);\n    }\n    return dist;\n}\n","import * as _ from 'lodash';\r\nimport { IAssertDist, IEnvOption, Operation, ITaskContext, ITaskConfig, ITaskInfo, Src } from './TaskConfig';\r\nimport { generateTask } from './generateTask';\r\nimport { runSequence, addToSequence } from './taskSequence';\r\nimport { files, taskStringVal, taskSourceVal, absoluteSrc, absolutePath } from './utils';\r\nimport { findTasksInModule, findTaskDefineInModule, findTasksInDir, findTaskDefineInDir } from './decorator';\r\n\r\n\r\n\r\n\r\n/**\r\n * binding Config to implement default func.\r\n * \r\n * @export\r\n * @param {ITaskConfig} cfg\r\n * @returns {ITaskContext}\r\n */\r\nexport function bindingConfig(cfg: ITaskConfig): ITaskContext {\r\n\r\n    let oper = currentOperation(cfg.env);\r\n\r\n    let context: ITaskContext = <ITaskContext>{\r\n        oper: oper,\r\n\r\n        env: cfg.env,\r\n        globals: cfg.globals || {},\r\n        option: cfg.option,\r\n        runTasks: cfg.runTasks,\r\n\r\n        fileFilter: files,\r\n        runSequence: runSequence,\r\n        addToSequence: cfg.addToSequence || addToSequence,\r\n        generateTask(tasks, match?) {\r\n            return generateTask(tasks, _.extend(createDefaultMatch(context), match || {}));\r\n        },\r\n        findTasks(mdl, match?) {\r\n            return findTasksInModule(mdl, _.extend(createDefaultMatch(context), match || {}));\r\n        },\r\n        findTasksInDir(dirs, match?) {\r\n            return findTasksInDir(dirs, _.extend(createDefaultMatch(context), match || {}));\r\n        },\r\n\r\n        findTaskDefine: findTaskDefineInModule.bind(this),\r\n\r\n        findTaskDefineInDir: findTaskDefineInDir.bind(this),\r\n\r\n        subTaskName(task, deft = '') {\r\n            let name = '';\r\n            // let oper = context.oper;\r\n            if (_.isString(task)) {\r\n                name = task;\r\n            } else if (task && task !== context.option) {\r\n                // oper = task.oper || context.oper;\r\n                let n = task.name;\r\n                if (!n) {\r\n                    n = task.assert ? task.assert.name : '';\r\n                }\r\n                name = taskStringVal(n, context.oper, cfg.env)\r\n            } else {\r\n                name = deft;\r\n            }\r\n            let parentName = taskStringVal(cfg.option.name, context.oper, cfg.env);\r\n\r\n            return parentName ? `${parentName}-${name}` : name;\r\n        },\r\n\r\n        getSrc(task: ITaskInfo, relative = false): Src {\r\n            let src: Src;\r\n            let oper = task ? (task.oper || context.oper) : context.oper;\r\n            if (task && task.assert) {\r\n                src = taskSourceVal(getAssertSrc(task.assert, oper), context.oper, cfg.env)\r\n            }\r\n            if (!src) {\r\n                src = taskSourceVal(getAssertSrc(cfg.option, oper), context.oper, cfg.env)\r\n            }\r\n            return (relative !== false) ? src : absoluteSrc(cfg.env.root, src);\r\n        },\r\n\r\n        getDist(task: ITaskInfo, relative = false) {\r\n            let dist;\r\n            // let oper = task ? (task.oper || context.oper) : context.oper;\r\n            if (task && task.assert) {\r\n                dist = getCurrentDist(task.assert, context.oper, cfg.env);\r\n            }\r\n            dist = dist || getCurrentDist(context.option, context.oper, cfg.env);\r\n\r\n            return (relative !== false) ? dist : absolutePath(cfg.env.root, dist);\r\n        },\r\n\r\n        toRootSrc(src: Src): Src {\r\n            return absoluteSrc(cfg.env.root, src);\r\n        },\r\n        toRootPath(pathstr: string): string {\r\n            return absolutePath(cfg.env.root, pathstr);\r\n        }\r\n    };\r\n\r\n    return context;\r\n}\r\n\r\nlet createDefaultMatch = (ctx: ITaskContext) => {\r\n    let match: ITaskInfo = { oper: ctx.oper };\r\n    if (ctx.match) {\r\n        match.match = (anothor: ITaskInfo) => {\r\n            return ctx.match(match, anothor);\r\n        }\r\n    }\r\n    return match;\r\n}\r\n\r\n\r\n/**\r\n * get current env Operation.\r\n * \r\n * @export\r\n * @param {EnvOption} env\r\n * @returns\r\n */\r\nexport function currentOperation(env: IEnvOption) {\r\n    let oper: Operation;\r\n    if (env.deploy) {\r\n        oper = Operation.deploy;\r\n    } else if (env.release) {\r\n        oper = Operation.release;\r\n    } else {\r\n        oper = Operation.build;\r\n    }\r\n\r\n    if (env.watch) {\r\n        oper = oper | Operation.watch;\r\n    }\r\n    if (env.test) {\r\n        oper = oper | Operation.test;\r\n    }\r\n    if (env.serve) {\r\n        oper = oper | Operation.serve;\r\n    }\r\n    if (env.e2e) {\r\n        oper = oper | Operation.e2e;\r\n    }\r\n\r\n    return oper;\r\n}\r\n\r\n/**\r\n * get assert source.\r\n * \r\n * @param {IAssertDist} assert\r\n * @param {Operation} oper\r\n * @returns\r\n */\r\nfunction getAssertSrc(assert: IAssertDist, oper: Operation) {\r\n    let src = null;\r\n\r\n    if ((oper & Operation.test) > 0) {\r\n        src = assert.testSrc;\r\n    } else if ((oper & Operation.e2e) > 0) {\r\n        src = assert.e2eSrc;\r\n    } else if ((oper & Operation.watch) > 0) {\r\n        src = assert.watchSrc;\r\n    } else if ((oper & Operation.clean) > 0) {\r\n        src = assert.cleanSrc || assert.dist;\r\n    }\r\n\r\n\r\n    return src || assert.src;\r\n}\r\n\r\n/**\r\n * get dist.\r\n * \r\n * @param {OutputDist} ds\r\n * @param {Operation} oper runtime Operation.\r\n * @returns\r\n */\r\nfunction getCurrentDist(ds: IAssertDist, oper: Operation, env: IEnvOption) {\r\n    let dist: string;\r\n    if (env.deploy || (oper & Operation.deploy) > 0) {\r\n        dist = ds.deployDist || taskStringVal(ds.dist, oper, env);\r\n    } else if (env.release || (oper & Operation.release) > 0) {\r\n        dist = ds.releaseDist || taskStringVal(ds.dist, oper, env);\r\n    } else if (env.e2e || (oper & Operation.e2e) > 0) {\r\n        dist = ds.e2eDist || ds.buildDist || taskStringVal(ds.dist, oper, env);\r\n    } else if (env.test || (oper & Operation.test) > 0) {\r\n        dist = ds.testDist || ds.buildDist || taskStringVal(ds.dist, oper, env);\r\n    } else if ((oper & Operation.build) > 0) {\r\n        dist = ds.buildDist || taskStringVal(ds.dist, oper, env);\r\n    }\r\n\r\n    return dist;\r\n}\r\n"]}