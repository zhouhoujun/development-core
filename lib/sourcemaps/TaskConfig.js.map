{"version":3,"sources":["TaskConfig.js","TaskConfig.ts"],"names":["task","constructor","Object","seal","prototype","bindingConfig","cfg","fileFilter","files","runSequence","addTask","generateTask","tasks","oper","env","subTaskName","name","deft","arguments","length","undefined","option","getDist","ds","dist","getCurrentDist","currentOperation","deploy","Operation","release","e2e","test","build","toSequence","seq","_","filter","it","len","orderBy","t","isString","isArray","order","each","push","flatten","gulp","ps","Promise","resolve","then","taskErr","taskStop","reslove","reject","tskmap","err","e","some","values","on","start","console","error","directory","express","res","fn","fs_1","readdirSync","fname","filePn","fst","lstatSync","isDirectory","concat","taskseq","dt","watch","log","chalk","cyan","createWatchTask","isFunction","createTask","createPipesTask","taskSequence","rst","isNumber","splice","tk","watchs","last","event","watchChanged","map","w","call","src","pipes","p","psrc","stram","pipe","stream","output","outputs","all","once","dest","catch","red","require","exports"],"mappings":"AAAA,YCyFA,SAAAA,MAAqBC,GACjBC,OAAOC,KAAKF,GACZC,OAAOC,KAAKF,EAAYG,WAimB5B,QAAAC,eAA8BC,GAoB1B,MAnBAA,GAAIC,WAAaD,EAAIC,YAAcC,MACnCF,EAAIG,YAAcH,EAAIG,aAAeA,YACrCH,EAAII,QAAUJ,EAAII,SAAWA,QAC7BJ,EAAIK,aAAeL,EAAIK,cAAiB,SAACC,GACrC,MAAOD,cAAaC,EAAON,EAAIO,KAAMP,EAAIQ,MAE7CR,EAAIS,YAAcT,EAAIS,aAAgB,SAACC,GAAe,GAATC,GAASC,UAAAC,OAAA,GAAAC,SAAAF,UAAA,GAAAA,UAAA,GAAF,EAChD,OAAOZ,GAAIe,OAAOL,KAAUV,EAAIe,OAAOL,KAAhC,KAAwCA,GAAQC,GAASD,GAEpEV,EAAIgB,QAAUhB,EAAIgB,SAAY,SAACC,GAC3B,GAAIA,EAAI,CACJ,GAAIC,GAAOC,eAAeF,EAAIjB,EAAIO,KAClC,IAAIW,EACA,MAAOA,GAGf,MAAOC,gBAAenB,EAAIe,OAAQf,EAAIO,OAGnCP,EAUX,QAAAoB,kBAAiCZ,GAC7B,GAAID,GAAAA,MAaJ,OAXIA,GADAC,EAAIa,OACGC,UAAUD,OACVb,EAAIe,QACJD,UAAUC,QACVf,EAAIgB,IACJF,UAAUE,IACVhB,EAAIiB,KACJH,UAAUG,KAEVH,UAAUI,MAezB,QAAAC,YAA2BrB,EAAgDC,GACvE,GAAIqB,KACJtB,GAAQuB,EAAEC,OAAOxB,EAAO,SAAAyB,GAAA,MAAMA,IAC9B,IAAIC,GAAM1B,EAAMO,MAmChB,OAlCAP,GAAQuB,EAAEI,QAAQ3B,EAAO,SAAA4B,GACrB,MAAIA,GACIL,EAAEM,SAASD,GACJF,EACAH,EAAEO,QAAQF,GACVF,EAEcE,EAAGG,MAGzBL,IAIXH,EAAES,KAAKhC,EAAO,SAAA4B,GACLA,IAGDL,EAAEM,SAASD,GACXN,EAAIW,KAAKL,GACFL,EAAEO,QAAQF,GACjBN,EAAIW,KAAKV,EAAEW,QAAQb,WAAWO,EAAG3B,KAE7B2B,EAAExB,OACEwB,EAAE3B,MACG2B,EAAE3B,KAAOA,GAAQ,GAClBqB,EAAIW,KAAKL,EAAExB,MAGfkB,EAAIW,KAAKL,EAAExB,UAKpBkB,EAaX,QAAAzB,aAA4BsC,EAAYnC,GACpC,GAAIoC,GAAKC,QAAQC,SAsCjB,OArCItC,IAASA,EAAMO,OAAS,GACxBgB,EAAES,KAAKhC,EAAO,SAAAZ,GACVgD,EAAKA,EAAGG,KAAK,WACT,GAAIC,GAAU,KAAMC,EAAW,IAC/B,OAAO,IAAIJ,SAAQ,SAACK,EAASC,GACzB,GAAIC,KACJrB,GAAES,KAAKT,EAAEO,QAAQ1C,GAAQA,GAAQA,GAAO,SAAAwC,GACpCgB,EAAOhB,IAAK,IAEhBY,EAAU,SAACK,GACPF,EAAOE,IAEXJ,EAAW,SAACK,GACRF,EAAOE,EAAE1D,OAAQ,EACZmC,EAAEwB,KAAKxB,EAAEyB,OAAOJ,GAAS,SAAAnB,GAAA,OAAOA,KACjCiB,KAGRP,EAAKc,GAAG,YAAaR,GAChBQ,GAAG,WAAYT,GACpBL,EAAKe,MAAM9D,KAEVmD,KAAK,WACEJ,EAAA,iBACAA,EAAA,eAAuB,YAAaM,GACpCN,EAAA,eAAuB,WAAYK,KAExC,SAAAK,GACKV,EAAA,iBACAA,EAAA,eAAuB,YAAaM,GACpCN,EAAA,eAAuB,WAAYK,IAEvCW,QAAQC,MAAMP,SAK3BT,EAWX,QAAAxC,OAAsByD,EAAmBC,GACrC,GAAIC,KAaJ,OAZAD,GAAUA,GAAY,SAACE,GAAD,OAAQ,GAC9BjC,EAAES,KAAKyB,KAAAC,YAAYL,GAAY,SAAAM,GAC3B,GAAIC,GAASP,EAAY,IAAMM,EAC3BE,EAAMJ,KAAAK,UAAUF,EACfC,GAAIE,cAKLR,EAAMA,EAAIS,OAAOpE,MAAMgE,EAAQN,IAJ3BA,EAAQM,IACRL,EAAItB,KAAK2B,KAMdL,EAaX,QAAAxD,cAA6BC,EAAoCC,EAAiBC,GAC9E,GAAI+D,KAqBJ,OApBA1C,GAAES,KAAKT,EAAEO,QAAQ9B,GAASA,GAASA,GAAQ,SAAAkE,GACvC,KAAIA,EAAGjE,OAASiE,EAAGjE,KAAOA,IAAS,GAGnC,GAAIiE,EAAGC,MAAO,CACV,IAAKjE,EAAIiE,MACL,MAEJhB,SAAQiB,IAAI,gCAAiCC,MAAMC,KAAKJ,EAAG9D,OAC3D6D,EAAQhC,KAAKsC,gBAAgBL,QACtB3C,GAAEiD,WAAWN,EAAG9E,OACvB+D,QAAQiB,IAAI,gCAAiCC,MAAMC,KAAKJ,EAAG9D,OAC3D6D,EAAQhC,KAAKwC,WAAWP,MAExBf,QAAQiB,IAAI,gCAAiCC,MAAMC,KAAKJ,EAAG9D,OAE3D6D,EAAQhC,KAAKyC,gBAAgBR,OAI9BD,EAYX,QAAApD,gBAAwBF,EAAgBV,GACpC,GAAIW,GAAAA,MACJ,QAAQX,GACJ,IAAKe,WAAUI,MACXR,EAAOD,EAAGS,OAAST,EAAGC,IACtB,MACJ,KAAKI,WAAUG,KACXP,EAAOD,EAAGQ,MAAQR,EAAGS,OAAST,EAAGC,IACjC,MACJ,KAAKI,WAAUE,IACXN,EAAOD,EAAGO,KAAOP,EAAGS,OAAST,EAAGC,IAChC,MACJ,KAAKI,WAAUC,QACXL,EAAOD,EAAGM,SAAWN,EAAGC,IACxB,MACJ,KAAKI,WAAUD,OACXH,EAAOD,EAAGI,QAAUJ,EAAGC,IACvB,MACJ,SACIA,EAAO,GAGf,MAAOA,GAGX,QAAAd,SAAiB6E,EAAqBC,GAClC,IAAKA,EACD,MAAOD,EAEX,IAAIpD,EAAEM,SAAS+C,IAAQrD,EAAEO,QAAQ8C,GAC7BD,EAAa1C,KAAK2C,OACf,IAAIA,EAAIxE,KAAM,CACjB,GAAImB,EAAEsD,SAASD,EAAI7C,QAAU6C,EAAI7C,OAAS,GAAK6C,EAAI7C,MAAQ4C,EAAapE,OAEpE,MADAoE,GAAaG,OAAOF,EAAI7C,MAAO,EAAG6C,EAAIxE,MAC/BuE,CAEXA,GAAa1C,KAAK2C,EAAIxE,MAE1B,MAAOuE,GAUX,QAAAF,YAAoBP,GAChB,MAAO,UAAC/B,EAAYzC,GAChB,GAAIqF,GAAKrF,EAAIS,YAAY+D,EAAG9D,KAI5B,OAHA+B,GAAK/C,KAAK2F,EAAI,WACV,MAAOb,GAAG9E,KAAKM,EAAKwE,EAAI/B,KAExBZ,EAAEsD,SAASX,EAAGnC,QAEV3B,KAAM2E,EACNhD,MAAOmC,EAAGnC,OAGXgD,GASf,QAAAR,iBAAyBL,GACrB,MAAO,UAAC/B,EAAYzC,GAChB,GAAIsF,GAASzD,EAAEiD,WAAWN,EAAGC,OAASD,EAAGC,MAAMzE,GAAOwE,EAAGC,KACpD5C,GAAEiD,WAAWjD,EAAE0D,KAAKD,KACrBA,EAAO/C,KAAK,SAAgBiD,GACxBhB,EAAGiB,cAAgBjB,EAAGiB,aAAaD,EAAOxF,KAGlDsF,EAASzD,EAAE6D,IAAIJ,EAAQ,SAAAK,GACnB,MAAI9D,GAAEM,SAASwD,GACJ3F,EAAIS,YAAYkF,GAEpBA,GAEX,IAAIN,GAAKrF,EAAIS,YAAY+D,EAAG9D,KAM5B,OALA+B,GAAK/C,KAAK2F,EAAI,WACV5B,QAAQiB,IAAI,cAAeC,MAAMC,KAAKgB,KAAKjB,MAAO3E,EAAIe,OAAO8E,MAC7DpD,EAAKgC,MAAMzE,EAAIe,OAAO8E,IAAKP,KAG3BzD,EAAEsD,SAASX,EAAGnC,QAEV3B,KAAM2E,EACNhD,MAAOmC,EAAGnC,OAGXgD,GAGf,QAAAL,iBAAyBR,GACrB,MAAO,UAAC/B,EAAYzC,GAEhB,GAAIqF,GAAKrF,EAAIS,YAAY+D,EAAG9D,KA6C5B,OA5CA+B,GAAK/C,KAAK2F,EAAI,WACV,GAAIQ,GAAMlD,QAAQC,QAAQH,EAAKoD,IAAIrB,EAAGqB,KAAO7F,EAAIe,OAAO8E,KACxD,IAAIrB,EAAGsB,MAAO,CACV,GAAIA,GAAQjE,EAAEiD,WAAWN,EAAGsB,OAAStB,EAAGsB,MAAM9F,EAAKwE,GAAMA,EAAGsB,KAC5DjE,GAAES,KAAKwD,EAAO,SAACC,GACXF,EAAMA,EAAIhD,KAAK,SAAAmD,GACX,MAAOrD,SAAQC,QAASf,EAAEiD,WAAWiB,GAAKA,EAAE/F,EAAKwE,EAAI/B,GAAQsD,GACxDlD,KAAK,SAAAoD,GACF,MAAOD,GAAKE,KAAKD,aAI1BzB,GAAG0B,OACVL,EAAMA,EAAIhD,KAAM,SAAAsD,GACZ,MAAO3B,GAAG0B,KAAKC,EAAQnG,EAAKwE,KAyBpC,OAtBAqB,GAAIhD,KAAK,SAAAsD,GACL,GAAI3B,EAAG4B,OAAQ,CACX,GAAIC,GAAUxE,EAAEiD,WAAWN,EAAG4B,QAAU5B,EAAG4B,OAAOpG,EAAKwE,GAAMA,EAAG4B,MAChE,OAAOzD,SAAQ2D,IAAIzE,EAAE6D,IAAIW,EAAS,SAAAD,GAC9B,MAAO,IAAIzD,SAAQ,SAACC,EAASK,GACzBN,QAAQC,QAAiCf,EAAEiD,WAAWsB,GAAUA,EAAOD,EAAQnG,EAAKwE,EAAI/B,GAAQ2D,GAC3FvD,KAAK,SAAAuD,GACFD,EAAOD,KAAKE,GACPG,KAAK,MAAO3D,GACZ2D,KAAK,QAAStD,UAMnC,MAAO,IAAIN,SAAQ,SAACC,EAASK,GACzBkD,EAAOD,KAAKzD,EAAK+D,KAAKxG,EAAIgB,QAAQwD,KAC7B+B,KAAK,MAAO3D,GACZ2D,KAAK,QAAStD,OAIxB4C,EAAIY,MAAM,SAAAtD,GACbM,QAAQiB,IAAIC,MAAM+B,IAAIvD,QAI1BtB,EAAEsD,SAASX,EAAGnC,QAEV3B,KAAM2E,EACNhD,MAAOmC,EAAGnC,OAGXgD,GA9iCf,GAAYxD,GAAC8E,QAAM,UAEPhC,MAAKgC,QAAM,SACvB5C,KAAA4C,QAAuC,OAQvC,SAAYrF,GAIRA,EAAAA,EAAA,MAAA,GAAA,QAIAA,EAAAA,EAAA,KAAA,GAAA,OAIAA,EAAAA,EAAA,IAAA,GAAA,MAIAA,EAAAA,EAAA,QAAA,GAAA,UAIAA,EAAAA,EAAA,OAAA,IAAA,UApBQsF,QAAAtF,YAAAsF,QAAAtF,cAAZ,IAAYA,WAAAsF,QAAAtF,SA8EIsF,SAAAlH,KAAIA,KAmmBJkH,QAAA7G,cAAaA,cA8Bb6G,QAAAxF,iBAAgBA,iBA0BhBwF,QAAAjF,WAAUA,WAmDViF,QAAAzG,YAAWA,YAkDXyG,QAAA1G,MAAKA,MA2BL0G,QAAAvG,aAAYA","file":"../TaskConfig.js","sourcesContent":["\"use strict\";\nconst _ = require('lodash');\nconst chalk = require('chalk');\nconst fs_1 = require('fs');\n(function (Operation) {\n    Operation[Operation[\"build\"] = 1] = \"build\";\n    Operation[Operation[\"test\"] = 2] = \"test\";\n    Operation[Operation[\"e2e\"] = 4] = \"e2e\";\n    Operation[Operation[\"release\"] = 8] = \"release\";\n    Operation[Operation[\"deploy\"] = 16] = \"deploy\";\n})(exports.Operation || (exports.Operation = {}));\nvar Operation = exports.Operation;\nfunction task(constructor) {\n    Object.seal(constructor);\n    Object.seal(constructor.prototype);\n}\nexports.task = task;\nfunction bindingConfig(cfg) {\n    cfg.fileFilter = cfg.fileFilter || files;\n    cfg.runSequence = cfg.runSequence || runSequence;\n    cfg.addTask = cfg.addTask || addTask;\n    cfg.generateTask = cfg.generateTask || ((tasks) => {\n        return generateTask(tasks, cfg.oper, cfg.env);\n    });\n    cfg.subTaskName = cfg.subTaskName || ((name, deft = '') => {\n        return cfg.option.name ? `${cfg.option.name}-${name || deft}` : name;\n    });\n    cfg.getDist = cfg.getDist || ((ds) => {\n        if (ds) {\n            let dist = getCurrentDist(ds, cfg.oper);\n            if (dist) {\n                return dist;\n            }\n        }\n        return getCurrentDist(cfg.option, cfg.oper);\n    });\n    return cfg;\n}\nexports.bindingConfig = bindingConfig;\nfunction currentOperation(env) {\n    let oper;\n    if (env.deploy) {\n        oper = Operation.deploy;\n    }\n    else if (env.release) {\n        oper = Operation.release;\n    }\n    else if (env.e2e) {\n        oper = Operation.e2e;\n    }\n    else if (env.test) {\n        oper = Operation.test;\n    }\n    else {\n        oper = Operation.build;\n    }\n    return oper;\n}\nexports.currentOperation = currentOperation;\nfunction toSequence(tasks, oper) {\n    let seq = [];\n    tasks = _.filter(tasks, it => it);\n    let len = tasks.length;\n    tasks = _.orderBy(tasks, t => {\n        if (t) {\n            if (_.isString(t)) {\n                return len;\n            }\n            else if (_.isArray(t)) {\n                return len;\n            }\n            else {\n                return t.order;\n            }\n        }\n        return len;\n    });\n    _.each(tasks, t => {\n        if (!t) {\n            return;\n        }\n        if (_.isString(t)) {\n            seq.push(t);\n        }\n        else if (_.isArray(t)) {\n            seq.push(_.flatten(toSequence(t, oper)));\n        }\n        else {\n            if (t.name) {\n                if (t.oper) {\n                    if ((t.oper & oper) > 0) {\n                        seq.push(t.name);\n                    }\n                }\n                else {\n                    seq.push(t.name);\n                }\n            }\n        }\n    });\n    return seq;\n}\nexports.toSequence = toSequence;\nfunction runSequence(gulp, tasks) {\n    let ps = Promise.resolve();\n    if (tasks && tasks.length > 0) {\n        _.each(tasks, task => {\n            ps = ps.then(() => {\n                let taskErr = null, taskStop = null;\n                return new Promise((reslove, reject) => {\n                    let tskmap = {};\n                    _.each(_.isArray(task) ? task : [task], t => {\n                        tskmap[t] = false;\n                    });\n                    taskErr = (err) => {\n                        reject(err);\n                    };\n                    taskStop = (e) => {\n                        tskmap[e.task] = true;\n                        if (!_.some(_.values(tskmap), it => !it)) {\n                            reslove();\n                        }\n                    };\n                    gulp.on('task_stop', taskStop)\n                        .on('task_err', taskErr);\n                    gulp.start(task);\n                })\n                    .then(() => {\n                    if (gulp['removeListener']) {\n                        gulp['removeListener']('task_stop', taskStop);\n                        gulp['removeListener']('task_err', taskErr);\n                    }\n                }, err => {\n                    if (gulp['removeListener']) {\n                        gulp['removeListener']('task_stop', taskStop);\n                        gulp['removeListener']('task_err', taskErr);\n                    }\n                    console.error(err);\n                });\n            });\n        });\n    }\n    return ps;\n}\nexports.runSequence = runSequence;\nfunction files(directory, express) {\n    let res = [];\n    express = express || ((fn) => true);\n    _.each(fs_1.readdirSync(directory), fname => {\n        let filePn = directory + '/' + fname;\n        var fst = fs_1.lstatSync(filePn);\n        if (!fst.isDirectory()) {\n            if (express(filePn)) {\n                res.push(filePn);\n            }\n        }\n        else {\n            res = res.concat(files(filePn, express));\n        }\n    });\n    return res;\n}\nexports.files = files;\nfunction generateTask(tasks, oper, env) {\n    let taskseq = [];\n    _.each(_.isArray(tasks) ? tasks : [tasks], dt => {\n        if (dt.oper && (dt.oper & oper) <= 0) {\n            return;\n        }\n        if (dt.watch) {\n            if (!env.watch) {\n                return;\n            }\n            console.log('register watch  dynamic task:', chalk.cyan(dt.name));\n            taskseq.push(createWatchTask(dt));\n        }\n        else if (_.isFunction(dt.task)) {\n            console.log('register custom dynamic task:', chalk.cyan(dt.name));\n            taskseq.push(createTask(dt));\n        }\n        else {\n            console.log('register pipes  dynamic task:', chalk.cyan(dt.name));\n            taskseq.push(createPipesTask(dt));\n        }\n    });\n    return taskseq;\n}\nexports.generateTask = generateTask;\nfunction getCurrentDist(ds, oper) {\n    let dist;\n    switch (oper) {\n        case Operation.build:\n            dist = ds.build || ds.dist;\n            break;\n        case Operation.test:\n            dist = ds.test || ds.build || ds.dist;\n            break;\n        case Operation.e2e:\n            dist = ds.e2e || ds.build || ds.dist;\n            break;\n        case Operation.release:\n            dist = ds.release || ds.dist;\n            break;\n        case Operation.deploy:\n            dist = ds.deploy || ds.dist;\n            break;\n        default:\n            dist = '';\n            break;\n    }\n    return dist;\n}\nfunction addTask(taskSequence, rst) {\n    if (!rst) {\n        return taskSequence;\n    }\n    if (_.isString(rst) || _.isArray(rst)) {\n        taskSequence.push(rst);\n    }\n    else if (rst.name) {\n        if (_.isNumber(rst.order) && rst.order >= 0 && rst.order < taskSequence.length) {\n            taskSequence.splice(rst.order, 0, rst.name);\n            return taskSequence;\n        }\n        taskSequence.push(rst.name);\n    }\n    return taskSequence;\n}\nfunction createTask(dt) {\n    return (gulp, cfg) => {\n        let tk = cfg.subTaskName(dt.name);\n        gulp.task(tk, () => {\n            return dt.task(cfg, dt, gulp);\n        });\n        if (_.isNumber(dt.order)) {\n            return {\n                name: tk,\n                order: dt.order\n            };\n        }\n        return tk;\n    };\n}\nfunction createWatchTask(dt) {\n    return (gulp, cfg) => {\n        let watchs = _.isFunction(dt.watch) ? dt.watch(cfg) : dt.watch;\n        if (!_.isFunction(_.last(watchs))) {\n            watchs.push((event) => {\n                dt.watchChanged && dt.watchChanged(event, cfg);\n            });\n        }\n        watchs = _.map(watchs, w => {\n            if (_.isString(w)) {\n                return cfg.subTaskName(w);\n            }\n            return w;\n        });\n        let tk = cfg.subTaskName(dt.name);\n        gulp.task(tk, () => {\n            console.log('watch, src:', chalk.cyan.call(chalk, cfg.option.src));\n            gulp.watch(cfg.option.src, watchs);\n        });\n        if (_.isNumber(dt.order)) {\n            return {\n                name: tk,\n                order: dt.order\n            };\n        }\n        return tk;\n    };\n}\nfunction createPipesTask(dt) {\n    return (gulp, cfg) => {\n        let tk = cfg.subTaskName(dt.name);\n        gulp.task(tk, () => {\n            let src = Promise.resolve(gulp.src(dt.src || cfg.option.src));\n            if (dt.pipes) {\n                let pipes = _.isFunction(dt.pipes) ? dt.pipes(cfg, dt) : dt.pipes;\n                _.each(pipes, (p) => {\n                    src = src.then(psrc => {\n                        return Promise.resolve((_.isFunction(p) ? p(cfg, dt, gulp) : p))\n                            .then(stram => {\n                            return psrc.pipe(stram);\n                        });\n                    });\n                });\n            }\n            else if (dt.pipe) {\n                src = src.then((stream => {\n                    return dt.pipe(stream, cfg, dt);\n                }));\n            }\n            src.then(stream => {\n                if (dt.output) {\n                    let outputs = _.isFunction(dt.output) ? dt.output(cfg, dt) : dt.output;\n                    return Promise.all(_.map(outputs, output => {\n                        return new Promise((resolve, reject) => {\n                            Promise.resolve((_.isFunction(output) ? output(stream, cfg, dt, gulp) : output))\n                                .then(output => {\n                                stream.pipe(output)\n                                    .once('end', resolve)\n                                    .once('error', reject);\n                            });\n                        });\n                    }));\n                }\n                else {\n                    return new Promise((resolve, reject) => {\n                        stream.pipe(gulp.dest(cfg.getDist(dt)))\n                            .once('end', resolve)\n                            .once('error', reject);\n                    });\n                }\n            });\n            return src.catch(err => {\n                console.log(chalk.red(err));\n            });\n        });\n        if (_.isNumber(dt.order)) {\n            return {\n                name: tk,\n                order: dt.order\n            };\n        }\n        return tk;\n    };\n}\n","import * as _ from 'lodash';\r\nimport { Gulp, WatchEvent, WatchCallback } from 'gulp';\r\nimport * as chalk from 'chalk';\r\nimport { readdirSync, lstatSync } from 'fs';\r\n\r\n/**\r\n * project development build operation.\r\n * \r\n * @export\r\n * @enum {number}\r\n */\r\nexport enum Operation {\r\n    /**\r\n     * build compile project.\r\n     */\r\n    build = 1 << 0,\r\n    /**\r\n     * test project.\r\n     */\r\n    test = 1 << 1,\r\n    /**\r\n     * e2e test project.\r\n     */\r\n    e2e = 1 << 2,\r\n    /**\r\n     * release project.\r\n     */\r\n    release = 1 << 3,\r\n    /**\r\n     * release and deploy project.\r\n     */\r\n    deploy = 1 << 4\r\n}\r\n\r\n/**\r\n * object map.\r\n * \r\n * @export\r\n * @interface IMap\r\n * @template T\r\n */\r\nexport interface IMap<T> {\r\n    [K: string]: T;\r\n}\r\n\r\n/**\r\n * src\r\n */\r\nexport type Src = string | string[];\r\n\r\n/**\r\n * Task return type.\r\n * \r\n * @export\r\n * @interface ITaskResult\r\n */\r\nexport interface ITaskResult {\r\n    /**\r\n     * task name for task sequence.\r\n     * \r\n     * @type {Src}\r\n     * @memberOf ITaskResult\r\n     */\r\n    name?: Src;\r\n    /**\r\n     * task Operation type. default all pperation.\r\n     * \r\n     * @type {Operation}\r\n     * @memberOf ITaskResult\r\n     */\r\n    oper?: Operation;\r\n    /**\r\n     * task sequence order.\r\n     * \r\n     * @type {number}\r\n     * @memberOf ITaskResult\r\n     */\r\n    order?: number;\r\n}\r\n\r\nexport type TaskResult = Src | ITaskResult;\r\nexport type Task = (gulp: Gulp, config: TaskConfig) => TaskResult | TaskResult[] | void;\r\n\r\n/**\r\n * task decorator annations.\r\n * \r\n * @export\r\n * @param {Function} constructor\r\n */\r\nexport function task(constructor: Function) {\r\n    Object.seal(constructor);\r\n    Object.seal(constructor.prototype);\r\n}\r\n/**\r\n * task loader option.\r\n * \r\n * @export\r\n * @interface LoaderOption\r\n */\r\nexport interface LoaderOption {\r\n    /**\r\n     * loader type, default module.\r\n     * \r\n     * @type {string}\r\n     * @memberOf LoaderOption\r\n     */\r\n    type?: string;\r\n    /**\r\n     * module name or url\r\n     * \r\n     * @type {string | Object}\r\n     * @memberOf LoaderOption\r\n     */\r\n    module?: string | Object;\r\n\r\n    /**\r\n     * config module name or url.\r\n     * \r\n     * @type {string | Object}\r\n     * @memberOf LoaderOption\r\n     */\r\n    configModule?: string | Object;\r\n\r\n    /**\r\n     * config module name or url.\r\n     * \r\n     * @type {string | Object}\r\n     * @memberOf LoaderOption\r\n     */\r\n    taskModule?: string | Object;\r\n\r\n    /**\r\n     * task define.\r\n     * \r\n     * @type {ITaskDefine}\r\n     * @memberOf LoaderOption\r\n     */\r\n    taskDefine?: ITaskDefine;\r\n\r\n    /**\r\n     * custom external judage the object is right task func.\r\n     * \r\n     * @param {*} mdl\r\n     * @param {string} name\r\n     * @returns {boolean}\r\n     * \r\n     * @memberOf LoaderOption\r\n     */\r\n    isTaskFunc?(mdl: any): boolean;\r\n    /**\r\n     * custom external judage the object is right task define.\r\n     * \r\n     * @param {*} mdl\r\n     * @returns {boolean}\r\n     * \r\n     * @memberOf LoaderOption\r\n     */\r\n    isTaskDefine?(mdl: any): boolean;\r\n}\r\n\r\n/**\r\n * loader to load tasks from directory.\r\n * \r\n * @export\r\n * @interface DirLoaderOption\r\n * @extends {LoaderOption}\r\n */\r\nexport interface DirLoaderOption extends LoaderOption {\r\n    /**\r\n     * loader dir\r\n     * \r\n     * @type {Src}\r\n     * @memberOf LoaderOption\r\n     */\r\n    dir?: Src;\r\n    /**\r\n     * config in directory. \r\n     * \r\n     * @type {string}\r\n     * @memberOf DirLoaderOption\r\n     */\r\n    dirConfigFile?: string;\r\n}\r\n\r\n\r\n/**\r\n * transform interface.\r\n * \r\n * @export\r\n * @interface ITransform\r\n * @extends {NodeJS.ReadWriteStream}\r\n */\r\nexport interface ITransform extends NodeJS.ReadWriteStream {\r\n    /**\r\n     * transform pipe\r\n     * \r\n     * @param {NodeJS.ReadWriteStream} stream\r\n     * @returns {ITransform}\r\n     * \r\n     * @memberOf ITransform\r\n     */\r\n    pipe(stream: NodeJS.ReadWriteStream): ITransform;\r\n}\r\n\r\n/**\r\n * output transform. support typescript output.\r\n * \r\n * @export\r\n * @interface Output\r\n * @extends {ITransform}\r\n */\r\nexport interface Output extends ITransform {\r\n    dts?: ITransform;\r\n    js?: ITransform\r\n}\r\n\r\nexport type Pipe = (config?: TaskConfig, dt?: DynamicTask, gulp?: Gulp) => ITransform | Promise<ITransform>;\r\n\r\nexport type OutputPipe = (map: Output, config?: TaskConfig, dt?: DynamicTask, gulp?: Gulp) => ITransform | Promise<ITransform>;\r\n\r\nexport interface OutputDist {\r\n    /**\r\n     * the src file filter string. default 'src'.\r\n     * \r\n     * @type {string}\r\n     * @memberOf OutputDist\r\n     */\r\n    src?: Src;\r\n\r\n    /**\r\n     * default output folder. if empty use parent setting, or ues 'dist'.\r\n     */\r\n    dist?: string;\r\n    /**\r\n     * build output folder. if empty use parent setting, or ues 'dist'.\r\n     * \r\n     * @type {string}\r\n     * @memberOf Dist\r\n     */\r\n    build?: string;\r\n    /**\r\n     * test output folder. if empty use parent setting, or ues 'dist'.\r\n     * \r\n     * @type {string}\r\n     * @memberOf Dist\r\n     */\r\n    test?: string;\r\n    /**\r\n     * e2e output folder. if empty use parent setting, or ues 'dist'.\r\n     * \r\n     * @type {string}\r\n     * @memberOf Dist\r\n     */\r\n    e2e?: string;\r\n    /**\r\n     * release output folder. if empty use parent setting, or ues 'dist'.\r\n     * \r\n     * @type {string}\r\n     * @memberOf Dist\r\n     */\r\n    release?: string;\r\n    /**\r\n     * deploy output folder. if empty use parent setting, or ues 'dist'.\r\n     * \r\n     * @type {string}\r\n     * @memberOf Dist\r\n     */\r\n    deploy?: string;\r\n}\r\n\r\n\r\n/**\r\n * dynamic gulp task.\r\n * \r\n * @export\r\n * @interface DynamicTask\r\n * @extends {OutputDist}\r\n */\r\nexport interface DynamicTask extends OutputDist {\r\n    /**\r\n     * task name\r\n     * \r\n     * @type {string}\r\n     * @memberOf DynamicTask\r\n     */\r\n    name: string;\r\n    /**\r\n     * task order.\r\n     * \r\n     * @type {number}\r\n     * @memberOf DynamicTask\r\n     */\r\n    order?: number;\r\n    /**\r\n     * task type. default for all Operation.\r\n     * \r\n     * @type {Operation}\r\n     * @memberOf DynamicTask\r\n     */\r\n    oper?: Operation;\r\n\r\n    /**\r\n     * watch tasks\r\n     * \r\n     * \r\n     * @memberOf DynamicTask\r\n     */\r\n    watch?: Array<string | WatchCallback> | ((config?: TaskConfig, dt?: DynamicTask) => Array<string | WatchCallback>);\r\n    /**\r\n     * watch changed.\r\n     * \r\n     * @param {WatchEvent} event\r\n     * @param {TaskConfig} config\r\n     * \r\n     * @memberOf DynamicTask\r\n     */\r\n    watchChanged?(event: WatchEvent, config: TaskConfig);\r\n    /**\r\n     * stream pipe.\r\n     * \r\n     * @param {ITransform} gulpsrc\r\n     * @param {TaskConfig} config\r\n     * @returns {(ITransform | Promise<ITransform>)}\r\n     * \r\n     * @memberOf DynamicTask\r\n     */\r\n    pipe?(gulpsrc: ITransform, config: TaskConfig, dt?: DynamicTask): ITransform | Promise<ITransform>;\r\n\r\n    /**\r\n     * task pipe works.\r\n     * \r\n     * \r\n     * @memberOf DynamicTask\r\n     */\r\n    pipes?: Pipe[] | ((config?: TaskConfig, dt?: DynamicTask) => Pipe[]);\r\n\r\n    /**\r\n     * output pipe task\r\n     *\r\n     * \r\n     * @memberOf DynamicTask\r\n     */\r\n    output?: OutputPipe[] | ((config?: TaskConfig, dt?: DynamicTask) => OutputPipe[]);\r\n\r\n    /**\r\n     * custom task.\r\n     * \r\n     * @param {TaskConfig} config\r\n     * @param {DynamicTask} [dt]\r\n     * @param {Gulp} [gulp]\r\n     * @returns {(void | ITransform | Promise<any>)}\r\n     * \r\n     * @memberOf DynamicTask\r\n     */\r\n    task?(config: TaskConfig, dt?: DynamicTask, gulp?: Gulp): void | ITransform | Promise<any>;\r\n\r\n}\r\n\r\n/**\r\n * the option for loader dynamic build task.\r\n * \r\n * @export\r\n * @interface DynamicLoaderOption\r\n * @extends {LoaderOption}\r\n */\r\nexport interface DynamicLoaderOption extends LoaderOption {\r\n    /**\r\n     * dynamic task\r\n     * \r\n     * @type {(DynamicTask | DynamicTask[])}\r\n     * @memberOf DynamicLoaderOption\r\n     */\r\n    dynamicTasks?: DynamicTask | DynamicTask[];\r\n}\r\n\r\n\r\n/**\r\n * task loader option.\r\n * \r\n * @export\r\n * @interface TaskLoaderOption\r\n */\r\nexport interface TaskLoaderOption {\r\n    /**\r\n     * task loader\r\n     * \r\n     * @type {(string | LoaderOption | DynamicTask | DynamicTask[])}\r\n     * @memberOf TaskOption\r\n     */\r\n    loader: string | LoaderOption | DynamicTask | DynamicTask[];\r\n\r\n    /**\r\n     * external task for \r\n     * \r\n     * @memberOf TaskConfig\r\n     */\r\n    externalTask?: Task;\r\n    /**\r\n     * custom set run tasks sequence.\r\n     * \r\n     * \r\n     * @memberOf TaskConfig\r\n     */\r\n    runTasks?: Src[] | ((oper: Operation, tasks: Src[], subGroupTask?: TaskResult, assertsTask?: TaskResult) => Src[]);\r\n\r\n    /**\r\n     * sub tasks.\r\n     * \r\n     * @type {(TaskOption | TaskOption[])}\r\n     * @memberOf TaskOption\r\n     */\r\n    tasks?: TaskOption | TaskOption[];\r\n\r\n    /**\r\n     * set sub task order in this task sequence.\r\n     * \r\n     * @type {number}\r\n     * @memberOf TaskLoaderOption\r\n     */\r\n    subTaskOrder?: number;\r\n}\r\n\r\n\r\n/**\r\n * asserts to be dealt with.\r\n * \r\n * @export\r\n * @interface Asserts\r\n */\r\nexport interface Asserts extends OutputDist, TaskLoaderOption {\r\n    /**\r\n     * asserts extends name. for register dynamic task.\r\n     * \r\n     * @type {string}\r\n     * @memberOf Asserts\r\n     */\r\n    name?: string;\r\n\r\n    /**\r\n     * tasks to deal with asserts.\r\n     * \r\n     * @type {IMap<Src | Asserts, DynamicTask[]>}\r\n     * @memberOf Asserts\r\n     */\r\n    asserts?: IMap<Src | Asserts | DynamicTask[]>;\r\n\r\n    /**\r\n     * set asserts task order in this task sequence.\r\n     * \r\n     * @type {number}\r\n     * @memberOf Asserts\r\n     */\r\n    assertsOrder?: number;\r\n}\r\n\r\n\r\n/**\r\n * task option setting.\r\n * \r\n * @export\r\n * @interface TaskOption\r\n */\r\nexport interface TaskOption extends Asserts {\r\n    /**\r\n     * the src file filter string. default 'src'.\r\n     * \r\n     * @type {string}\r\n     * @memberOf TaskOption\r\n     */\r\n    src: Src;\r\n}\r\n\r\n/**\r\n * modules task define\r\n * \r\n * @export\r\n * @interface ITaskDefine\r\n */\r\nexport interface ITaskDefine {\r\n    /**\r\n     * load config in modules\r\n     * \r\n     * @param {Operation} oper\r\n     * @param {TaskOption} option\r\n     * @returns {TaskConfig}\r\n     * \r\n     * @memberOf ITaskDefine\r\n     */\r\n    moduleTaskConfig(oper: Operation, option: TaskOption, env: EnvOption): TaskConfig\r\n\r\n    /**\r\n     * load task in modules.\r\n     * \r\n     * @param {TaskConfig} config\r\n     * @param {tasksInModule} findInModule\r\n     * @param {tasksInDir} findInDir\r\n     * @returns {Task[]}\r\n     * \r\n     * @memberOf ITaskDefine\r\n     */\r\n    moduleTaskLoader?(config: TaskConfig): Promise<Task[]>;\r\n}\r\n\r\n/**\r\n * run time task config for setup task.\r\n * \r\n * @export\r\n * @interface TaskConfig\r\n */\r\nexport interface TaskConfig {\r\n    /**\r\n     * custom global data cache.\r\n     */\r\n    globals?: any;\r\n    /**\r\n     * env\r\n     * \r\n     * @type {EnvOption}\r\n     * @memberOf TaskConfig\r\n     */\r\n    env: EnvOption;\r\n    /**\r\n     * run operation\r\n     * \r\n     * @type {Operation}\r\n     * @memberOf TaskConfig\r\n     */\r\n    oper: Operation;\r\n    /**\r\n     * task option setting.\r\n     * \r\n     * @type {TaskOption}\r\n     * @memberOf TaskConfig\r\n     */\r\n    option: TaskOption;\r\n\r\n    /**\r\n     * custom config run tasks sequence in.\r\n     * \r\n     * @param {TaskResult} [subGroupTask]\r\n     * @param {Src[]} [tasks]\r\n     * @param {TaskResult} [assertTasks]\r\n     * @returns {Src[]}\r\n     * \r\n     * @memberOf TaskConfig\r\n     */\r\n    runTasks?(subGroupTask?: TaskResult, tasks?: Src[], assertTasks?: TaskResult): Src[];\r\n    /**\r\n     * custom print help.\r\n     * \r\n     * @param {string} lang\r\n     * \r\n     * @memberOf TaskConfig\r\n     */\r\n    printHelp?(lang: string): void;\r\n\r\n    /**\r\n     * find  task in module. default implement by loader.\r\n     * \r\n     * @param {string} module\r\n     * @returns {Promise<Task[]>}\r\n     * \r\n     * @memberOf TaskConfig\r\n     */\r\n    findTasksInModule?(module: string): Promise<Task[]>;\r\n    /**\r\n     * find  task in directories. default implement by loader.\r\n     * \r\n     * @param {Src} dirs\r\n     * @returns {Promise<Task[]>}\r\n     * \r\n     * @memberOf TaskConfig\r\n     */\r\n    findTasksInDir?(dirs: Src): Promise<Task[]>;\r\n\r\n    /**\r\n     * get dist of current state.  default implement in bindingConfig.\r\n     * \r\n     * @param {OutputDist} dist\r\n     * @returns {string}\r\n     * \r\n     * @memberOf TaskConfig\r\n     */\r\n    getDist?(dist?: OutputDist): string;\r\n    /**\r\n     * filter file in directory.  default implement in bindingConfig.\r\n     * \r\n     * @param {string} directory\r\n     * @param {((fileName: string) => boolean)} [express]\r\n     * @returns {string[]}\r\n     * \r\n     * @memberOf TaskConfig\r\n     */\r\n    fileFilter?(directory: string, express?: ((fileName: string) => boolean)): string[];\r\n    /**\r\n     * filter file in directory.  default implement in bindingConfig.\r\n     * \r\n     * @param {Gulp} gulp\r\n     * @param {Src[]} tasks\r\n     * @returns {Promise<any>}\r\n     * \r\n     * @memberOf TaskConfig\r\n     */\r\n    runSequence?(gulp: Gulp, tasks: Src[]): Promise<any>;\r\n\r\n    /**\r\n     * dynamic generate tasks.  default implement in bindingConfig.\r\n     * \r\n     * @param {(DynamicTask | DynamicTask[])} tasks\r\n     * @returns {Task[]}\r\n     * \r\n     * @memberOf TaskConfig\r\n     */\r\n    generateTask?(tasks: DynamicTask | DynamicTask[]): Task[];\r\n\r\n    /**\r\n     * add task result to task sequence.\r\n     * \r\n     * @param {Src[]} sequence  task sequence.\r\n     * @param {TaskResult} taskResult\r\n     * @returns {Src[]}\r\n     * \r\n     * @memberOf TaskConfig\r\n     */\r\n    addTask?(sequence: Src[], taskResult: TaskResult): Src[];\r\n    /**\r\n     * generate sub task name\r\n     * \r\n     * @param {string} name\r\n     * @param {string} [defaultName]\r\n     * \r\n     * @memberOf TaskConfig\r\n     */\r\n    subTaskName?(name: string, defaultName?: string);\r\n}\r\n\r\n/**\r\n * event option\r\n * \r\n * @export\r\n * @interface EnvOption\r\n */\r\nexport interface EnvOption {\r\n    /**\r\n     * project root.\r\n     * \r\n     * @type {string}\r\n     * @memberOf EnvOption\r\n     */\r\n    root?: string;\r\n    /**\r\n     * help doc\r\n     * \r\n     * @type {(boolean | string)}\r\n     * @memberOf EnvOption\r\n     */\r\n    help?: boolean | string;\r\n    test?: boolean | string;\r\n    serve?: boolean | string;\r\n    e2e?: boolean | string;\r\n    release?: boolean;\r\n    deploy?: boolean;\r\n    watch?: boolean | string;\r\n    /**\r\n     * run spruce task.\r\n     */\r\n    task?: string;\r\n\r\n    /**\r\n     * project config setting.\r\n     * \r\n     * @type {string}\r\n     * @memberOf EnvOption\r\n     */\r\n    config?: string;\r\n\r\n    // key?: number;\r\n    // value?: number;\r\n    // csv?: string;\r\n    // dist?: string;\r\n    // lang?: string;\r\n\r\n    publish?: boolean | string;\r\n\r\n    /**\r\n     * group bundle.\r\n     * \r\n     * @type {Src}\r\n     * @memberOf EnvOption\r\n     */\r\n    grp?: Src;\r\n}\r\n\r\n/**\r\n * binding Config to implement default func.\r\n * \r\n * @export\r\n * @param {TaskConfig} cfg\r\n * @returns {TaskConfig}\r\n */\r\nexport function bindingConfig(cfg: TaskConfig): TaskConfig {\r\n    cfg.fileFilter = cfg.fileFilter || files;\r\n    cfg.runSequence = cfg.runSequence || runSequence;\r\n    cfg.addTask = cfg.addTask || addTask;\r\n    cfg.generateTask = cfg.generateTask || ((tasks: DynamicTask | DynamicTask[]) => {\r\n        return generateTask(tasks, cfg.oper, cfg.env);\r\n    });\r\n    cfg.subTaskName = cfg.subTaskName || ((name, deft = '') => {\r\n        return cfg.option.name ? `${cfg.option.name}-${name || deft}` : name;\r\n    });\r\n    cfg.getDist = cfg.getDist || ((ds?: OutputDist) => {\r\n        if (ds) {\r\n            let dist = getCurrentDist(ds, cfg.oper);\r\n            if (dist) {\r\n                return dist;\r\n            }\r\n        }\r\n        return getCurrentDist(cfg.option, cfg.oper);\r\n    });\r\n\r\n    return cfg;\r\n}\r\n\r\n/**\r\n * get current env Operation.\r\n * \r\n * @export\r\n * @param {EnvOption} env\r\n * @returns\r\n */\r\nexport function currentOperation(env: EnvOption) {\r\n    let oper: Operation;\r\n    if (env.deploy) {\r\n        oper = Operation.deploy;\r\n    } else if (env.release) {\r\n        oper = Operation.release;\r\n    } else if (env.e2e) {\r\n        oper = Operation.e2e;\r\n    } else if (env.test) {\r\n        oper = Operation.test;\r\n    } else {\r\n        oper = Operation.build;\r\n    }\r\n\r\n    return oper;\r\n}\r\n\r\n\r\n/**\r\n * convert setup task result to run sequence src.\r\n * \r\n * @export\r\n * @param {(Array<TaskResult | TaskResult[] | void>)} tasks\r\n * @param {Operation} oper\r\n * @returns {Src[]}\r\n */\r\nexport function toSequence(tasks: Array<TaskResult | TaskResult[] | void>, oper: Operation): Src[] {\r\n    let seq: Src[] = [];\r\n    tasks = _.filter(tasks, it => it);\r\n    let len = tasks.length;\r\n    tasks = _.orderBy(tasks, t => {\r\n        if (t) {\r\n            if (_.isString(t)) {\r\n                return len;\r\n            } else if (_.isArray(t)) {\r\n                return len;\r\n            } else {\r\n                return (<ITaskResult>t).order\r\n            }\r\n        }\r\n        return len;\r\n    });\r\n\r\n\r\n    _.each(tasks, t => {\r\n        if (!t) {\r\n            return;\r\n        }\r\n        if (_.isString(t)) {\r\n            seq.push(t);\r\n        } else if (_.isArray(t)) {\r\n            seq.push(_.flatten(toSequence(t, oper)));\r\n        } else {\r\n            if (t.name) {\r\n                if (t.oper) {\r\n                    if ((t.oper & oper) > 0) {\r\n                        seq.push(t.name);\r\n                    }\r\n                } else {\r\n                    seq.push(t.name);\r\n                }\r\n            }\r\n        }\r\n    });\r\n    return seq;\r\n}\r\n\r\n/**\r\n * run task sequence.\r\n * \r\n * @protected\r\n * @param {Gulp} gulp\r\n * @param {Src[]} tasks\r\n * @returns {Promise<any>}\r\n * \r\n * @memberOf Development\r\n */\r\nexport function runSequence(gulp: Gulp, tasks: Src[]): Promise<any> {\r\n    let ps = Promise.resolve();\r\n    if (tasks && tasks.length > 0) {\r\n        _.each(tasks, task => {\r\n            ps = ps.then(() => {\r\n                let taskErr = null, taskStop = null;\r\n                return new Promise((reslove, reject) => {\r\n                    let tskmap: any = {};\r\n                    _.each(_.isArray(task) ? task : [task], t => {\r\n                        tskmap[t] = false;\r\n                    });\r\n                    taskErr = (err) => {\r\n                        reject(err);\r\n                    };\r\n                    taskStop = (e: any) => {\r\n                        tskmap[e.task] = true;\r\n                        if (!_.some(_.values(tskmap), it => !it)) {\r\n                            reslove();\r\n                        }\r\n                    }\r\n                    gulp.on('task_stop', taskStop)\r\n                        .on('task_err', taskErr);\r\n                    gulp.start(task);\r\n                })\r\n                    .then(() => {\r\n                        if (gulp['removeListener']) {\r\n                            gulp['removeListener']('task_stop', taskStop);\r\n                            gulp['removeListener']('task_err', taskErr);\r\n                        }\r\n                    }, err => {\r\n                        if (gulp['removeListener']) {\r\n                            gulp['removeListener']('task_stop', taskStop);\r\n                            gulp['removeListener']('task_err', taskErr);\r\n                        }\r\n                        console.error(err);\r\n                    });\r\n            });\r\n        });\r\n    }\r\n    return ps;\r\n}\r\n\r\n/**\r\n * filter fileName in directory.\r\n * \r\n * @export\r\n * @param {string} directory\r\n * @param {((fileName: string) => boolean)} [express]\r\n * @returns {string[]}\r\n */\r\nexport function files(directory: string, express?: ((fileName: string) => boolean)): string[] {\r\n    let res: string[] = [];\r\n    express = express || ((fn) => true);\r\n    _.each(readdirSync(directory), fname => {\r\n        let filePn = directory + '/' + fname;\r\n        var fst = lstatSync(filePn);\r\n        if (!fst.isDirectory()) {\r\n            if (express(filePn)) {\r\n                res.push(filePn)\r\n            }\r\n        } else {\r\n            res = res.concat(files(filePn, express))\r\n        }\r\n    });\r\n    return res;\r\n}\r\n\r\n\r\n\r\n/**\r\n * dynamic build tasks.\r\n * \r\n * @export\r\n * @param {(DynamicTask | DynamicTask[])} tasks\r\n * @param {Operation} oper\r\n * @returns {Task[]}\r\n */\r\nexport function generateTask(tasks: DynamicTask | DynamicTask[], oper: Operation, env: EnvOption): Task[] {\r\n    let taskseq: Task[] = [];\r\n    _.each(_.isArray(tasks) ? tasks : [tasks], dt => {\r\n        if (dt.oper && (dt.oper & oper) <= 0) {\r\n            return;\r\n        }\r\n        if (dt.watch) {\r\n            if (!env.watch) {\r\n                return;\r\n            }\r\n            console.log('register watch  dynamic task:', chalk.cyan(dt.name));\r\n            taskseq.push(createWatchTask(dt));\r\n        } else if (_.isFunction(dt.task)) { // custom task\r\n            console.log('register custom dynamic task:', chalk.cyan(dt.name));\r\n            taskseq.push(createTask(dt));\r\n        } else {\r\n            console.log('register pipes  dynamic task:', chalk.cyan(dt.name));\r\n            // pipe stream task.\r\n            taskseq.push(createPipesTask(dt));\r\n        }\r\n    });\r\n\r\n    return taskseq;\r\n}\r\n\r\n\r\n\r\n/**\r\n * get dist.\r\n * \r\n * @param {OutputDist} ds\r\n * @param {Operation} oper\r\n * @returns\r\n */\r\nfunction getCurrentDist(ds: OutputDist, oper: Operation) {\r\n    let dist: string;\r\n    switch (oper) {\r\n        case Operation.build:\r\n            dist = ds.build || ds.dist;\r\n            break;\r\n        case Operation.test:\r\n            dist = ds.test || ds.build || ds.dist;\r\n            break;\r\n        case Operation.e2e:\r\n            dist = ds.e2e || ds.build || ds.dist;\r\n            break;\r\n        case Operation.release:\r\n            dist = ds.release || ds.dist;\r\n            break;\r\n        case Operation.deploy:\r\n            dist = ds.deploy || ds.dist;\r\n            break;\r\n        default:\r\n            dist = '';\r\n            break;\r\n    }\r\n    return dist;\r\n}\r\n\r\nfunction addTask(taskSequence: Src[], rst: TaskResult) {\r\n    if (!rst) {\r\n        return taskSequence;\r\n    }\r\n    if (_.isString(rst) || _.isArray(rst)) {\r\n        taskSequence.push(rst);\r\n    } else if (rst.name) {\r\n        if (_.isNumber(rst.order) && rst.order >= 0 && rst.order < taskSequence.length) {\r\n            taskSequence.splice(rst.order, 0, rst.name);\r\n            return taskSequence;\r\n        }\r\n        taskSequence.push(rst.name);\r\n    }\r\n    return taskSequence;\r\n}\r\n\r\n\r\n/**\r\n * promise task.\r\n * \r\n * @param {DynamicTask} dt\r\n * @returns\r\n */\r\nfunction createTask(dt: DynamicTask) {\r\n    return (gulp: Gulp, cfg: TaskConfig): TaskResult => {\r\n        let tk = cfg.subTaskName(dt.name);\r\n        gulp.task(tk, () => {\r\n            return dt.task(cfg, dt, gulp);\r\n        });\r\n        if (_.isNumber(dt.order)) {\r\n            return <ITaskResult>{\r\n                name: tk,\r\n                order: dt.order\r\n            };\r\n        }\r\n        return tk\r\n    };\r\n}\r\n/**\r\n * create dynamic watch task.\r\n * \r\n * @param {DynamicTask} dt\r\n * @returns\r\n */\r\nfunction createWatchTask(dt: DynamicTask) {\r\n    return (gulp: Gulp, cfg: TaskConfig): TaskResult => {\r\n        let watchs = _.isFunction(dt.watch) ? dt.watch(cfg) : dt.watch;\r\n        if (!_.isFunction(_.last(watchs))) {\r\n            watchs.push(<WatchCallback>(event: WatchEvent) => {\r\n                dt.watchChanged && dt.watchChanged(event, cfg);\r\n            });\r\n        }\r\n        watchs = _.map(watchs, w => {\r\n            if (_.isString(w)) {\r\n                return cfg.subTaskName(w);\r\n            }\r\n            return w;\r\n        })\r\n        let tk = cfg.subTaskName(dt.name);\r\n        gulp.task(tk, () => {\r\n            console.log('watch, src:', chalk.cyan.call(chalk, cfg.option.src));\r\n            gulp.watch(cfg.option.src, watchs)\r\n        });\r\n\r\n        if (_.isNumber(dt.order)) {\r\n            return <ITaskResult>{\r\n                name: tk,\r\n                order: dt.order\r\n            };\r\n        }\r\n        return tk;\r\n    };\r\n}\r\nfunction createPipesTask(dt: DynamicTask) {\r\n    return (gulp: Gulp, cfg: TaskConfig): TaskResult => {\r\n\r\n        let tk = cfg.subTaskName(dt.name);\r\n        gulp.task(tk, () => {\r\n            let src = Promise.resolve(gulp.src(dt.src || cfg.option.src));\r\n            if (dt.pipes) {\r\n                let pipes = _.isFunction(dt.pipes) ? dt.pipes(cfg, dt) : dt.pipes;\r\n                _.each(pipes, (p: Pipe) => {\r\n                    src = src.then(psrc => {\r\n                        return Promise.resolve((_.isFunction(p) ? p(cfg, dt, gulp) : p))\r\n                            .then(stram => {\r\n                                return psrc.pipe(stram)\r\n                            });\r\n                    });\r\n                })\r\n            } else if (dt.pipe) {\r\n                src = src.then((stream => {\r\n                    return dt.pipe(stream, cfg, dt);\r\n                }));\r\n            }\r\n            src.then(stream => {\r\n                if (dt.output) {\r\n                    let outputs = _.isFunction(dt.output) ? dt.output(cfg, dt) : dt.output;\r\n                    return Promise.all(_.map(outputs, output => {\r\n                        return new Promise((resolve, reject) => {\r\n                            Promise.resolve<NodeJS.ReadWriteStream>((_.isFunction(output) ? output(stream, cfg, dt, gulp) : output))\r\n                                .then(output => {\r\n                                    stream.pipe(output)\r\n                                        .once('end', resolve)\r\n                                        .once('error', reject);\r\n                                });\r\n\r\n                        });\r\n                    }));\r\n                } else {\r\n                    return new Promise((resolve, reject) => {\r\n                        stream.pipe(gulp.dest(cfg.getDist(dt)))\r\n                            .once('end', resolve)\r\n                            .once('error', reject);\r\n                    });\r\n                }\r\n            });\r\n            return src.catch(err => {\r\n                console.log(chalk.red(err));\r\n            });\r\n        });\r\n\r\n        if (_.isNumber(dt.order)) {\r\n            return <ITaskResult>{\r\n                name: tk,\r\n                order: dt.order\r\n            };\r\n        }\r\n        return tk;\r\n    }\r\n}\r\n"]}